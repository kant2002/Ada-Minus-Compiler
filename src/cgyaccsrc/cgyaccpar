/*
 * Parser body for CGYACC
 *
 * Modified march 31, 1988 by M.J. Landzaat 
 *
 */


/*
 * The "semantic value stack" is
 * made global here.
 */
# define YYFLAG -1000
# define YYERROR goto yyerrlab
# define YYACCEPT return(0)
# define YYABORT return(1)

/*	parser for yacc output	*/

int yydebug = 0; /* 1 for debugging */
YYSTYPE yyv[YYMAXDEPTH]; /* where the values are stored */
short   yys[YYMAXDEPTH];	/* parse stack */
short	*yyps;
YYSTYPE	*yypvt;
int yychar = -1; /* current input token number */
int yynerrs = 0;  /* number of errors */
short yyerrflag = 0;  /* error recovery flag */
yyattr_stack_adjusted = 0;  /* boolean */

yyparse() {

	short yyj, yym;
	register short yystate, yyn;
	register YYSTYPE *yypv;
	register short *yyxi;

	yystate = 0;
	yychar = -1;
	yynerrs = 0;
	yyerrflag = 0;
	yyps= &yys[-1];
	yypv= &yyv[-1];

 yystack:    /* put a state and value onto the stack */

	if (yydebug)
	   printf( "state %d, char 0%o\n", yystate, yychar);
	if (++yyps > &yys [YYMAXDEPTH])
	   yyerror ("CGYACC stack overflow");
	*yyps = yystate;
	++yypv;
	*yypv = yyval;

 yynewstate:

	yyn = yypact[yystate];

	if( yyn<= YYFLAG ) goto yydefault; /* simple state */

	if (yychar < 0)
	   if ((yychar = yylex ()) < 0)
	      yychar = 0;  /* reached EOF */
	if( (yyn += yychar)<0 || yyn >= YYLAST ) goto yydefault;

	if( yychk[ yyn=yyact[ yyn ] ] == yychar ){ /* valid shift */
		yychar = -1;
		yyval = yylval;
		yystate = yyn;
		if( yyerrflag > 0 ) --yyerrflag;
		goto yystack;
		}

 yydefault:
	/* default state action */

	if( (yyn=yydef[yystate]) == -2 ) {
	        if (yychar < 0)
		   if ((yychar = yylex ()) < 0)
	              yychar = 0;  /* reached EOF */

		/* look through exception table */

		for(yyxi=yyexca;
		    (*yyxi!=(-1))||(yyxi[1]!=yystate);
		    yyxi+=2); /* VOID */
			
		while( *(yyxi+=2) >= 0 ){
			if( *yyxi == yychar ) break;
			}
		if ((yyn = yyxi [1]) < 0)
				YYACCEPT;
		}

	if( yyn == 0 ) /* error */
	{
		/* error ... attempt to resume parsing */

		switch( yyerrflag ){

		case 0:   /* brand new error */

			yyerror( "Syntactic block" );
		yyerrlab:
			++yynerrs;

		case 1:
		case 2: /* incompletely recovered error ... try again */

			yyerrflag = 3;

			/* find a state where "error" is a legal shift action */

			while ( yyps >= yys ) {
			   yyn = yypact[*yyps] + YYERRCODE;
			   if( yyn>= 0 && 
				yyn < YYLAST && 
				yychk[yyact[yyn]] == YYERRCODE )
			      {
			      yystate = yyact[yyn];
				  /* simulate a shift of "error" */
			      goto yystack;
			      }
			   yyn = yypact[*yyps];

			   /* the current yyps has no shift on "error",
								 pop stack */

			   if( yydebug ) 
				printf( 
			"error recovery pops state %d, uncovers %d\n", 
							*yyps, yyps[-1] );
			   --yyps;
			   --yypv;
			   }

	/* there is no state on the stack with an error shift ... abort */

	yyabort:
			YYABORT;

		case 3:  /* no shift yet; eat a token */

			if( yydebug ) 
			printf( "error recovery discards char %d\n", yychar );

			if(yychar==0) goto yyabort; /*don't discard EOF, quit */
			yychar = -1;
			goto yynewstate;   /* try again in the same state */
			}
		}

	/* reduction */

	yypvt = yypv;

/* Now, choose a rule to reduce, evaluating the predicate parts of those rules
*/

	if ((yyn = yychoose_rule(yystate)) <= 0)
	{
		fprintf(stderr,"Semantic block: reduction not possible in state %d.\n",
								yystate);
		yyerror();
		return(1);
	}

	/* reduction by production yyn */

	if (yydebug)
	   printf ("reduce %d\n", yyn);

	yyps -= yyr2[yyn];
	yypv -= yyr2[yyn];
	yyval = yypv[1];
	
	yym=yyn;
		/* consult goto table to find next state */
	yyn = yyr1[yyn];
	yyj = yypgo[yyn] + *yyps + 1;
	if (yyj >= YYLAST ||
	    yychk [yystate = yyact [yyj]] != -yyn)
	    yystate = yyact [yypgo [yyn]];

	YYreduce (yym);
	goto yystack;  /* stack new state and value */

	}


/* yyeval_predicate() determines reducibility of a rule */
/* CGYACC inserts the predicates of the rules at the dollar F sign */

yyeval_predicate(p)
short p;

{
	switch(p) {
$F
	default: return(1);
	}
}


yychoose_rule(n) 		/* CG: when in state n, determine according to
				   which rule reduction is going to take place,
				   by evaluating the predicate parts of the
				   rules. The first rule whose predicate 
				   evaluates to true is the lucky one. */ 
short n;
{
	short rule;

	if ((rule = yyrsi[n]) >0) /* CG : evaluate predicate even if this
				          rule is our only choice. */
		if (yyeval_predicate(rule)) return (rule); else return(0);
	rule = -rule; /* rule is not a rule anymore, but an index in yyrst */
	while (yyrst[rule])
	{
		if (yyeval_predicate(yyrst[rule]))
			return(yyrst[rule]);
		rule++;
	}
	return(0);
}


/*
 *	The user is interested in doing actions on
 *	reductions:
 *	YACC will include a large case statement
 *	somewhere here
 */

YYreduce (x)
short x;
{
	switch (x) {
	$A
	}
	yyattr_stack_adjusted = 0;
}
