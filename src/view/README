Beschrijving viewlib.a.

viewlib is een laag bovenop de bestaande dapse, welke de volgende interface
biedt.
- short get_cun (status)
  int *status
  /*
   * feitelijk staat hier bool, maar de dapse verwacht dan int itt het front
   * dat char verwacht. De dapse gaat echter stuk wanneer bool als typedef char
   * wordt neergezet
   */
- void free_cun (cun, status)
  int *status;
  short cun;
  /*
   * cun stelt het c(ompilation)u(nit)n(number) voor dat vrij gekomen is en
   * terug geplaatst moet worden in de vrije lijst/
   */
  /*
   * De waarde die teruggegeven wordt is het gevraagde unieke nummer.
   * status moet TRUE (1) zijn bij binnenkomst.
   * het resultaat is geldig, wanneer na de terugkeer de status TRUE is.
   * status wordt FALSE, wanneer:
   * -max aantal cuns bereikt is (65535)
   * -files voor de cunlijst niet gemaakt kunnen worden
   *  (~adacomp/cunlijst/lijst[0-6])
   * -lockfile (/tmp/cunlockfile) niet gemaakt kan worden,
   *  dit wordt een aantal malen geprobeerd.
   * -er een fout is in de lijst administratie, waardoor een verwacht vrij
   *  nummer toch al is uitgegeven.
   * -een vrije lijst file, waarvan een nummer is uitgegeven niet meer bestaat.
   * -een nummer wat terugegeven wordt al vrij is.
   * In alle gevallen kan het resultaat zinloos zijn, en wordt verwacht dat
   * het proces afgebroken wordt
   */

char *f_name (string, kind, status)
char *string;
int kind;	/* SPEC en BODY */
int *status;
/*
 * string is de naam van een unit, kind is een code voor SPEC of BODY
 * Onder BODY wordt zowel een package body verstaan, als een sub body en
 * separate body.
 * De csh environment parameter ADAVIEW wordt gezocht. Dit geeft de naam van
 * de huidige view. In een centrale database wordt deze naam, tesamen met het
 * userid omgezet naar de naam van de ada library.
 * Wanneer ADAVIEW geen waarde heeft, wordt de defaultview (adaview) als
 * naam genomen. Wanneer de database die ook niet kent wordt .master in de
 * huidige directory genomen als pad naam en als zodanig in de database
 * opgeslagen. Hiermee ligt de default omgeving vast.
 * Vanuit een andere directory is deze library in de default omgeving nu ook 
 * bereikbaar en is ook per gebruiker de ADA omgeving niet meer beperkt tot
 * een directory.
 * Omdat de centrale database nog niet bestaat, geeft alleen de default view
 * een geldige status terug.
 * 
 * De functie geeft een pointer naar een string met de naam van de tree van
 * van de unit.
 */

void updatelib (string, status)
char *string;
int *status;
/*
 * Wanneer het front besluit dat de compilatie gelukt is,
 * wordt een string doorgegeven aan deze routine,
 * waarmee een entry in de library gevuld/gewijzigd wordt.
 * Hierdoor is de compilatie unit bereikbaar voor andere compilatie units
 *
 * Omdat het format van de string nog niet bekend is, werkt deze routine
 * nog niet
 */

/*
 * Het geheel is opgezet met het doel snel een werkende versie te hebben.
 * Het is zeker geen robuust geheel, terwijl het ook niet bijster efficient
 * is op sommige plaatsen.
 *
 * Het kan een vingeroefing worden voor de geheel nieuwe opzet in ADA.
 * 
 * Ton Biegstraaten, 6-8-86
 */

/*
 * Voor het updaten van de library heb ik de volgende opzet in m'n hoofd:
 * -Het front vraagt een cun.
 *  Tot het moment van aanvraag van een volgende cun hebben alle aanroepen
 *  van library functies betrekking op de aangevraagde cun.
 *  Wanneer een nieuwe cun wordt gevraagd zonder aanroep van updatelib voor
 *  de vorige, wordt deze ongeldig en weggegooid.
 *  Dus tussen een aanvraag voor een cun en het updaten van de library kan
 *  geen andere cun gevraagd worden.
 * -Na het vragen om een cun worden boomfilenamen gevraagd. Er wordt een lijst
 *  aangelegd van cun's waarvan de boom gevraagd is en van de context
 *  context specificaties van die cu's.
 *  Wanneer een gevraagde boom daar niet bij staat wordt hij toegevoegd aan
 *  de context lijst voor de nieuwe cu en wordt de context specificatie aan
 *  de lijst toegevoegd.
 *  Het resultaat is een context specificatie van de nieuwe cu.
 * -Wanneer zowel het front als het backend als pcc etc tot de conclusie
 *  gekomen zijn dat de nieuwe unit goed vertaald is, wordt updatelib 
 *  aangeroepen met een string met de volgende informatie:
 *  - De unitnaam
 *  - De padnaam van de source van de unit.
 *  - kind van de unit (PS,PB,SU,SB).
 *  - stublist.
 *  of
 *  - teken dat de compilatie mislukt is, in ieder geval voor de laatste
 *    cu.
 *
 * Hierna is er genoeg informatie om de huidige dapse als basis voor het
 * nieuwe systeem te gebruiken.
 * Een nadeel lijkt dat het opsplitsen van de compilatie in meerdere tasks
 * niet meer kan. Dit is op te vangen door bij elke aanroep van een library
 * functie de cun mee te geven, waardoor elke aanvraag uniek is.
 */
