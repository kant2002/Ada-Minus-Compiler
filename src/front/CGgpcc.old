#include	"CG.h"

/*
 *XXX	ROUTINES FOR GENERATION OF PCC CODE
 */

/* the assembler directive '.text' or '.data' is active.
 * text_flag is changed by the macro's OUTTEXT and OUTDATA.
 * the next routine will check whether one of the directives has to be issuid.
 */

static	int	text_mode = TRUE;
short	text_flag	= TRUE;

printout (a,b,c,d,e,f)
{
	if (text_mode)
	{
	    if (!text_flag)
	    { fprintf (outfile, "&%d	\n", ICDATA); text_mode = FALSE; }
	}
	else
	    if ( text_flag)
	    { fprintf (outfile, "&%d	\n", ICTEXT); text_mode = TRUE; }

	fprintf (outfile, a,b,c,d,e,f);
}
#define	C_LANGUAGE	1

init_outfile ()
{
	OUT (("&%d	\n", ICINIT));
	OUT (("&%d	%d	\n", ICLANGUAGE, C_LANGUAGE));
	OUT (("&%d	\n", ICTEXT));
}

int	new_expr ()
{
	static int xxxx = 0;

	OUT ((".%d	\n", xxxx++));
}

static char ass_chars[] =
{ 'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p',
  'q','r','s','t','u','v','w','x','y','z','A','B','C','D','E','F',
  'G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V',
  'W','X','Y','Z','_','0','1','2','3','4','5','6','7','8','9',EXTRA_LETTER
};
#define	SS	3
#define ALFABETSIZE	63

mk_s (str, d1, d2)
register char *str;
register unsigned d1, d2;
{
	register int i;

	for (i = SS - 1; i >= 0; i --)
	   { str [i] = ass_chars [d1 % ALFABETSIZE];
	     d1 = d1 / ALFABETSIZE;
	   }

	for (i = SS + SS - 1; i >= SS; i --)
	   { str [i] = ass_chars [d2 % ALFABETSIZE];
	     d2 = d2 / ALFABETSIZE;
	   }

	str [SS + SS] = '\0';
}


int	index (s1, c)
register char *s1;
register char  c;
{
	while (*s1 != '\0') {
	   if (*s1 == c)
	      return TRUE;
	   s1++;
	}
}

labconvert (node, vector)
	register ac	node;
	register char	*vector;
{
	unsigned short lun;
	unsigned short ind;
	char	*format;
	static	char	x[10];
	register int i;
/*
 * print an '_' for the entry of a global routine
 * and also for normal names 
 */
	if (g_d (node) == XSUBBODY) {
	   node = g_specif (node);
	   format = "_X%s%s";
	}
	else
	if (g_d (node) == XSUB) {
	   format = "_M%s%s";
	}
    else
	format = "_X%s%s";

    lun = lun_of   (node);
    ind = index_of (node);
    mk_s (x, lun, ind);
    if (!has_tag (node))
	sprintf (vector, "_M%s", x);
    else
    if (is_std_fn (node))
	if (index ("=/+-*<>&", g_tag (node) [0]))
	    sprintf (vector, "_M%s", x);
	else
	    sprintf (vector, "_M%s%s", x, g_tag (node));
    else
    if (node -> tag [0] == '$')
	sprintf (vector, "_%s", &node -> tag [1]);
    else
    if (node -> tag [0] == '%')
	sprintf (vector, "%s%s", x, &node -> tag[1]);
    else
	sprintf (vector, format, x, node -> tag);

}

setdatalab (node, vector)
register ac node;
register char *vector;
{
	labconvert (node, vector);
}

deflab (n)
int n;
{
	OUT (("&%d	%d	\n", ICDLABN, n));
}

defdatalab (node)
	register ac node;
{
	char datatext [AIDL];

	setdatalab (node, datatext);
	OUT (("&%d	%s\n", ICGLOBL, datatext));
	OUT (("&%d	%s\n", ICDLABS, datatext));
}

textlab (n, vector)
	register int n;
	register char *vector;
{
	sprintf (vector, ".L%d", n);
	return vector;
}

setexprlab (node, vector)
	register ac node;
	register char *vector;
{
	setdatalab (node, vector);
}

defexprlab (node)
register ac node;
{
	char datatext [AIDL];

	setdatalab (node, datatext);

	OUT (("&%d	%s\n", ICGLOBL, datatext));
	OUT (("&%d	%s\n", ICDLABS, datatext));
}

TEXTLABCON (node)
	ac node;
{
	char datatext [AIDL];
	setdatalab (node, datatext);
	ICON (0, ADDRESS, datatext);
}

PAR_OBJECT (level, offset, type)
	int level;
	int offset, type;
{
	DEREF (type);
	PAR_NAME (level, offset, pointer_type_of (type));
}

PAR_NAME (level, offset,type)
	int level;
	int offset;
	int type;
{
	PLUS (type);
	get_stlink (curr_level - level,type);
	ICON (offset, LONG, "");
}

/*
 *	Temporarily solution; We need to get the proper base address
 *	of the actual parameters of the rendezvous
 */
ENTRY_PARAMETERBASE (node, type)
register ac node;
register int type;
{
	struct _accepts *p = ast;
	ASSERT (node != NULL, ("ENTRY_PARS:1"));

	while (p != NULL) {
	   ac t = p -> served_entry;
	   if (g_specif (t) == g_enclunit (node)) {
/*
 * It's a strange way to compute the level, but believe me it work
 */
	      LOC_OBJECT (level_of (node) + 1, g_SEL_actuals (p -> current_taskselect),
                            type);
	      return;
	   }
	   p = p -> prev_accept;
	}
	ASSERT (FALSE, ("ENTRY_PARAMETERS"));
}

ENTRY_PAR (node, type)
	register ac node;
	int type;
{
	PLUS (type);
	   ENTRY_PARAMETERBASE (node, type);
	   ICON (off (node), LONG, "");
}


/* DYN_OBJECT and DYN_NAME are only used for
 * the copy out of scalar parameters.
 */

DYN_OBJECT (offset, type)
	int offset, type;
{
	DEREF (type);
	DYN_NAME (offset, type);
}

DYN_NAME (off, type)
	int off;
	int type;
{
	register int ptype = pointer_type_of (type);
	PLUS (ptype);
	REG (SP_DYN, ptype);
	off += paramoffset (type, PARSTACK);
	ICON (off, LONG, "");
}

LOC_OBJECT (level, off, type)
	int level, off;
	int type;
{
	DEREF (type);
	LOC_NAME (level, off, pointer_type_of (type));
}

LOC_NAME (level, off,type)
	short level;
	int off;
	int type;
{
	MINUS (type);
	get_stlink (curr_level - level,type);
	ICON (off, LONG, "");
}



get_stlink (n,type)
register short n;
	int type;
{
	if (n == (short)0)
	   REG (SP_FIX, type);
	else
	{
	   DEREF (type);
	   PLUS (type);
	   get_stlink (n - 1,type);
	   ICON  (LINK_OFFSET, LONG, "");
	}
}

GLOB_OBJECT (n, node, type)
	int n;
	ac node;
	int type;
{
	char datatext [AIDL];
	setdatalab (node, datatext);
	P_NAME (n, type, datatext);
}

GLOB_NAME (n, node)
	int n;
	ac node;
{
	char datatext [AIDL];
	setdatalab (node, datatext);
	ICON (n, ADDRESS, datatext);
}
LNAME (type, labelno)
int type;
int labelno;
{
	char label [20];
	sprintf (label, ".L%d", labelno);
	P_NAME (0, type, label);
}

LICON (labelno)
	int labelno;
{
	char label [AIDL];
	sprintf (label, ".L%d", labelno);
	ICON (0, ADDRESS, label);
}

P_BINARY (o, p)
int o, p;
{
	printout ("%d\t%d\t\n",o, p);
}
P_TRINARY (x, y, z)
int x, y, z;
{
	printout ("%d\t%d\t%d\t0\t\n", x, y, z);
}


P_UNARY (o, p)
int o, p;
{
	printout ("%d\t0\t%d\t\n", o, p);
}

P_REG (a, p)
int a, p;
{
	printout ("94\t0\t%d\t%d\t\n", a, p);
}

P_NAME (o, p, st)
int o, p;
char *st;
{
	printout ("2\t%d\t0\t%d\t%s\n", o, p, st);
}

P_CONST (o, p, st)
int o, p;
char *st;
{
	printout ("4\t%d\t0\t%d\t%s\n", o, p, st);
}

gensjump (node)
ac node;
{
	char	datatext[AIDL];

	setdatalab (node, datatext);
	OUT (("&%d	%s	\n", ICJLABS, datatext));
}

genjump (l)
	int l;
{
	OUT (("&%d	%d	\n", ICJLABN, l));
}

pcc_deref (x, y)
register ac x;
register int y;
{
	if (y == VAL)
	   DEREF (pcc_type_of (x));
}

/* pcc_size returns the amount of bytes 
 * allocated on the stack for the object */

pcc_size (type)
	int type;
{
	switch (type)
	{
	case FLOAT:
		return TFLOATSIZE;
	default:
		return TLONGSIZE;
	}
}

le (type)
	int type;
{
	if (type == UCHAR)
		ULE (type);
	else 
		LE (type);
}

ge (type)
	int type;
{
	if (type == UCHAR)
		UGE (type);
	else 
		GE (type);
}

sconv (type)
	int type;
{
	switch (type)
	{
	case SHORT:
		SCONV (INT);
	case UCHAR:
	case USHORT:
		SCONV (UNSIGNED);
	default:
		return;
	}
}

pcc_type_of (node)
	register ac node;
{
	if (node == NULL)
	   return NOTYPE;

	switch (g_d (node)) {
	case XOBJECT:
		return pcc_type_of (g_desc (node));

	case XOBJDESC:
		return pcc_type_of (g_objtype (node));

	case XSUBTYPE:
		return pcc_type_of (g_parenttype (node));

	case XLITERAL:
		return pcc_type_of (g_littype (node));

	case XENUMTYPE:
	case XCHARLIT:
	case XENUMLIT:
		return UCHAR;

	case XSCC:
		return UCHAR;

	case XNAME:
	case XALL:
	case XATTRIBUTE:
	case XCALL:
	case XSELECT:
	case XINDEXING:
	case XSLICE:
	case XENTRYCALL:
		return pcc_type_of (g_types (node));

	case XTYPECONV:
		return pcc_type_of (node -> newtype);

	case XEXP:
		return pcc_type_of (base_type (g_exptype (node)));

	case XSUB:
	case XEXCEPTION:
		return ADDRESS;

	case XARRAYTYPE:
	case XRECTYPE:
		return ADDRESS;

	case XFILTER:
		return pcc_type_of (g_filtype (node));

	case XNEWTYPE:
		return pcc_type_of (g_old_type (node));

	case XINTERNAL:
		switch (g_ind (node)) {
		case I_INTEGER:
			return INT;
		case I_LONG:
		case I_UNIV:
		case I_INTTYPES:
			return LONG;
		case I_SHORT:
			return CHAR;
/*
 *		case I_NO_TYPE:
 *		case I_ANY_VECTOR:
 */
		case I_ANY_ACCESS_TYPE:
		case I_ANY_SCALAR_VECTOR:
 		case I_ANY_BOOL_VECTOR:
		case I_ANY_STRING_TYPE:
 		case I_ANY_TYPE:	/* is erroneous but for the
					 * sake of the programs that
					 * use this internal type
					 */
			return ADDRESS;
		case I_STD_REAL:
			return FLOAT;
		case I_ENUM:
			return UCHAR;
		case I_NO_TYPE:
			return NOTYPE;
		DEFAULT (("cannot find ind of _internal %d\n", node -> ind));
		}
	default:
		return TADDRSIZE;	/* should be address */
	}
}

PUT (type, val)
{
	switch (type) {
	case DEF_LONG:
		glob_init (val,LONG,"");
		break;
	case DEF_WORD:
		glob_init (val,INT,"");
		break;
	case DEF_BYTE:
		glob_init (val,UBYTE,"");
		break;
	case DEF_DOUBLE:
		glob_init (val, DOUBLE, "");
		break;
	case DEF_ADDR:
		glob_init (val,ADDRESS,"");
		break;
	case DEF_STRING:
		while (*(char *) val != '\0')
		{
			OUT (("&%d	%d	\n", ICBYTE, *(char *) val++));
		}
		break;
	case DEF_SLONG:
		glob_init (0,ADDRESS,val);
		break;
	}
}

glob_init (value, type, str_value)
	int value;
	int type;
	char *str_value;
{
	switch (type) {
	case DOUBLE:
	    {   char datatext [AIDL];
/*
		sprintf (datatext,"%e",atof (value));
		OUT (("&%d	%s\n",ICDOUBLE,datatext));
 */
		OUT (("&%d	%s\n", ICDOUBLE, value));
		break;
	    }
	default:
		new_expr ();
		INIT (type);
			ICON (value, type, str_value);
		break;
		
	}
}

comment (a, b, c, d, e, f)
{
	OUT (("&%d	", ICCOM));
	OUT ((a, b, c, d, e,f));
}

pointer_type_of (type)
	int type;
{
	/* let's keep it simple for the moment ...
	 * only one level of pointer's are known,
	 * so no double references are generated.
	 */
	
	/* IMPORTANT :
	 *
	 * see ./h/pcc.h for multiple cases !
	 */

	int ptype;
	
	if (is_pointer_type (type))
		return type;

	switch (type) {

	case CHAR:
		ptype = P_CHAR;
		break;
/*
 *	case SHORT:
 *		ptype = P_SHORT;
 *		break;
 */

	case INT:
		ptype = P_INT;
		break;

	case LONG:
		ptype = P_LONG;
		break;
	
	case FLOAT:
		ptype = P_FLOAT;
		break;

/*
 *	case DOUBLE:
 *		ptype = P_DOUBLE;
 *		break;
 */
	case UBYTE:
		ptype = P_UBYTE;
		break;

/*	case UCHAR:
 *		ptype  = P_UCHAR;
 *		break;
 */
	case USHORT:
		ptype = USHORT;
		break;

/*	case UNSIGNED:
 *		ptype = P_UNSIGNED;
 *		break;
 */
	case ULONG:
		ptype = P_ULONG;
		break;

	case ADDRESS:
		ptype = type;
		break;

	DEFAULT (("pointer_type_of : unknown type to be pointered\n"));
	}

	return ptype;
}


is_pointer_type (type)
	register int type;
{
	switch (type) {
	case P_CHAR :
	case P_INT :
	case P_LONG :
	case P_FLOAT :
	case P_UCHAR :
	case P_USHORT :
	case P_ULONG :
		return TRUE;
	default:
		return FALSE;
	}
}
