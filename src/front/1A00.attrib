/*	GRAMMAR FOR DAS PASS1 			*/
/*
 * (c) copyright 1986, 1987, 1988, Delft University of Technology
 * Delft, The Netherlands
 *
 * This software remains the property of the Delft University of Tech.
 * The software is a part of the Delft Ada Subset Compiler
 *
 * Permission to use, sell, duplicate or disclose the software
 * must be obtained, in writing, from the Delft University of Tech.
 *
 * For further information contact
 *	Jan van Katwijk
 *	Department of Mathematics and Informatics
 *	Delft University of Technology
 *	julianalaan 132 Delft The Netherlands.
 *
 */
%union {
	int	f_int;
	char	*p_char;
};

/*
 *	grammar for use with the yacc preprocessor
 *	Modified Version, prepared for final compiler
 */

%token <f_int>	T_ABORT
%token <f_int>	T_ABS
%token <f_int>	T_ACCEPT
%token <f_int>	T_ACCESS
%token <f_int>	T_ALL
%token <f_int>	T_AND
%token <f_int>	T_ARRAY
%token <f_int>	T_AT
%token <f_int>	T_BEGIN
%token <f_int>	T_BODY
%token <f_int>	T_CASE
%token <f_int>	T_CONSTANT
%token <f_int>	T_DECLARE
%token <f_int>	T_DELAY
%token <f_int>	T_DELTA
%token <f_int>	T_DIGITS
%token <f_int>	T_DO
%token <f_int>	T_ELSE
%token <f_int>	T_ELSIF
%token <f_int>	T_END
%token <f_int>	T_ENTRY
%token <f_int>	T_EXCEPTION
%token <f_int>	T_EXIT
%token <f_int>	T_FOR
%token <f_int>	T_FUNCTION
%token <f_int>	T_GENERIC
%token <f_int>	T_GOTO
%token <f_int>	T_IF
%token <f_int>	T_IN
%token <f_int>	T_IS
%token <f_int>	T_LIMITED
%token <f_int>	T_LOOP
%token <f_int>	T_MOD
%token <f_int>	T_NEW
%token <f_int>	T_NOT
%token <f_int>	T_NULL
%token <f_int>	T_OF
%token <f_int>	T_OR
%token <f_int>	T_OTHERS
%token <f_int>	T_OUT
%token <f_int>	T_PACKAGE
%token <f_int>	T_PRAGMA
%token <f_int>	T_PRIVATE
%token <f_int>	T_PROCEDURE
%token <f_int>	T_RAISE
%token <f_int>	T_RANGE
%token <f_int>	T_RECORD
%token <f_int>	T_REM
%token <f_int>	T_RENAMES
%token <f_int>	T_RETURN
%token <f_int>	T_REVERSE
%token <f_int>	T_SELECT
%token <f_int>	T_SEPARATE
%token <f_int>	T_SUBTYPE
%token <f_int>	T_TASK
%token <f_int>	T_TERMINATE
%token <f_int>	T_THEN
%token <f_int>	T_TYPE
%token <f_int>	T_USE
%token <f_int>	T_WHEN
%token <f_int>	T_WHILE
%token <f_int>	T_WITH
%token <f_int>	T_XOR
%token <f_int>	T_CHAR_LIT
%token <p_char>	T_CHAR_STRING
%token <p_char>	T_RELOP
%token <p_char>	T_IDENT
%token <p_char>	T_INT_LIT
%token <p_char>	T_REAL_LIT
%token <p_char>	T_MULT
%token <p_char>	T_DIV
%token <p_char>	T_PLUS
%token <p_char>	T_MINUS
%token <p_char>	T_AMP
%token <f_int>	T_BOX
%token <p_char>	T_EXP
%token <f_int>	T_BAR
%token <f_int>	T_AS
%token <f_int>	T_COLON
%token <f_int>	T_DOT
%token <f_int>	T_COMMA
%token <f_int>	T_QUOTE
%token <f_int>	T_DD
%token <f_int>	T_LP
%token <f_int>	T_RP
%token <f_int>	T_ARROW
%token <f_int>	T_SEM_COL
%token <f_int>	T_LS
%token <f_int>	T_LF

%type	<p_char> opt_id

%attribute	C_choice_list (|bool, p_link, ac, ^ac, ac)
%attribute	C_choices (|bool, p_link, ac, ^bool, ac)
%attribute	C_part (|bool, ac, ac, ^ac)
%attribute	Comp
%attribute	Comp_unit
%attribute	real_unit (^ac, ac, int)
%attribute	c_package (^ac, ac)
%attribute	c_packbody (^ac, ac)
%attribute	c_packbegin (^ac, ac, ac)
%attribute	c_packstart (^ac, ac, ac)
%attribute	c_subdecl   (^ac, ac)
%attribute	c_subbody   (^ac, ac)
%attribute	c_substart  (^ac, ac, ac)
%attribute	c_genpack   (^ac, ac)
%attribute	c_genstart	 (^ac, ac, ac, ac, ac)
%attribute	c_genbegin	 (^ac, ac, ac, ac)
%attribute	c_gennode   (^ac, ac, ac, ac)
%attribute	sep_subbody (^ac, ac)
%attribute	sep_substart (^ac, ac, ac)
%attribute	sep_subhead  (^ac, ac, ac)
%attribute	sep_packbody (^ac, ac)
%attribute	sep_packbegin (^ac, ac, ac)
%attribute	sep_packstart (^ac, ac, ac)
%attribute	sep_taskbody (^ac, ac)
%attribute	sep_taskbegin (^ac, ac, ac)
%attribute	sep_taskstart (^ac, ac, ac)
%attribute	genpars     ()
%attribute	genparlist  ()
%attribute	genparameter ()
%attribute	genobjectpar (^ac, int, ac)
%attribute	geninoutspec (^ac)
%attribute	instantiation (^ac)
%attribute	gen_instance (^ac)
%attribute	gen_actpars (^ac, ac, int)
%attribute	gen_actpar (^ac, int)
%attribute	gen_parassoc (^ac)
%attribute	abort_l	(^ac, ac)
%attribute	abort_stat (^ac)
%attribute	accept_s (^ac, ac)
%attribute	sa_accept (^ac)
%attribute	accept_start (^ac, ac, int)
%attribute	accept_stat (^ac)
%attribute	access_type (^ac)
%attribute	add_op (^t_tag)
%attribute	aggr_start (^ac, ac, int)
%attribute	aggregate (^ac)
%attribute	allocator (^ac)
%attribute	alternatives (|ac, ac, ac, bool)
%attribute	array_start (^t_tag)
%attribute	array_type (^ac)
%attribute	as_expr (^ac)
%attribute	assignment (^ac)
%attribute	attribute (^ac)
%attribute	bas_stat (^ac)
%attribute	basic_stat (^ac)
%attribute	block (|t_tag, ^ac, ac)
%attribute	block_start (|t_tag, ^ac, ac)
%attribute	body
%attribute	body_part
%attribute	c_field (^ac)
%attribute	c_fieldlist (^ac, ac)
%attribute	c_typename (^ac)
%attribute	case (^ac, ac, int, p_link, ac)
%attribute	case_choice (|int, p_link, ac, ^ac)
%attribute	case_list (^ac, ac, int, p_link, ac)
%attribute	case_stat (^ac)
%attribute	choice (^ac)
%attribute	choice_list (^ac, ac)
%attribute	choices (^ac, bool)
%attribute	comp_assoc (^ac, int)
%attribute	comp_seq (|ac, ac, ac, bool)
%attribute	comp (|ac, ac, ac, bool)
%attribute	comp_list (^ac, ac)
%attribute	compound (^ac)
%attribute	constraint (|ac, ^ac)
%attribute	context_spec (^ac, ac)
%attribute	ct_name (^t_tag, ac)
%attribute	decl_part
%attribute	declar_part
%attribute	declaration
%attribute	declare (|t_tag, ^ac, ac)
%attribute	delay_cond (^ac)
%attribute	delay_stat (^ac)
%attribute	disc_assoc (^ac, ac)
%attribute	disc_part (^ac)
%attribute	disc_spec (^ac, ac, ac)
%attribute	disc_specs (^ac, ac)
%attribute	discr_range (^ac)
%attribute	e_or_comp (^ac, int)
%attribute	easy_spec (^ac)
%attribute	else_beg (^ac)
%attribute	else_part (^ac)
%attribute	elsif (^ac)
%attribute	elsif_part (^ac)
%attribute	entry (^ac)
%attribute	entry_list (^int)
%attribute	entry_name (^ac, ac, int)
%attribute	enum_name (^ac)
%attribute	enum_type (^ac)
%attribute	enumlit (^ac)
%attribute	enumstart (^ac, ac, int)
%attribute	ex_choice_list (|ac, ac, bool, ^ac, ac)
%attribute	ex_choices (|ac, ac, bool, ^ac, bool)
%attribute	ex_h_start (^ac, ac, bool)
%attribute	ex_handler (|ac, ac, bool, ^ac)
%attribute	ex_list (^ac)
%attribute	ex_name (^ac)
%attribute	ex_when (|ac, ac, bool, ^ac)
%attribute	except_part (^ac, ac, bool)
%attribute	exception (^ac)
%attribute	exit_stat (^ac)
%attribute	exit_unit (^ac)
%attribute	expr (^ac)
%attribute	expression (^ac, int)
%attribute	factor (^ac)
%attribute	field_list (|ac, ac, ac, bool)
%attribute	filter_ind (^ac)
%attribute	filtype (^ac)
%attribute	func_name (^ac, ac, int)
%attribute	func_par (^ac, int, ac)
%attribute	pragma	()
%attribute	proc_par (^ac, int, ac)
%attribute	func_pars (|ac, ac, int)
%attribute	function_pars (|ac, ac, int)
%attribute	function_spec (^ac)
%attribute	goto_stat
%attribute	id_opsym (^t_tag)
%attribute	if (^ac)
%attribute	if_begin (^ac, ac)
%attribute	if_part (^ac)
%attribute	if_stat (^ac)
%attribute	implied_array (^ac, ac)
%attribute	in_not (^bool)
%attribute	in_spec (^ac)
%attribute	incomplete_type (^ac)
%attribute	index (^ac)
%attribute	index_constraints (^ac, ac)
%attribute	index_list (^ac, ac)
%attribute	indices (^ac, int, ac)
%attribute	ini_all
%attribute	inout_spec (^ac)
%attribute	l_name (^ac)
%attribute	lab_stat
%attribute	leftlist (^ac, int)
%attribute	leftside (^ac)
%attributes	leftsides (^ac, ac)
%attribute	limited (^int)
%attribute	litteral (^ac)
%attribute	locals
%attribute	logop (^t_tag, int)
%attribute	loop_begin (|t_tag, ^ac, ac)
%attribute	loop_start (|t_tag, ^ac, ac)
%attribute	loop_stat (|t_tag, ^ac, ac)
%attribute	lplblk (|t_tag, ^ac)
%attribute	ls_name (^ac)
%attribute	mulop (^t_tag)
%attribute	name (^ac)
%attribute	newtype_decl (^ac)
%attribute	object_decl (^ac, ac)
%attribute	opt_collid (^t_tag)
%attribute	opt_except (^ac)
%attribute	opt_expr (^ac)
%attribute	opt_guard (^ac)
%attribute	opt_id
%attribute	opt_stats (^ac)
%attribute	opt_whenexpr (^ac)
%attribute	other_constraint (^ac)
%attribute	p_body (^ac, ac)
%attribute	p_node (^ac, ac)
%attribute	pack_start (^ac, ac)
%attribute	package (^ac)
%attribute	gen_package (^ac)
%attribute	genbegin (^ac, ac, ac, ac)
%attribute	gennode  (^ac, ac)
%attribute	packbody
%attribute	param_assoc (^ac)
%attribute	primary (^ac)
%attribute	priv_node (^ac, ac)
%attribute	private_type (^ac)
%attribute	privpart
%attribute	proc_call (^ac)
%attribute	proc_name (^ac, ac, int)
%attribute	proc_pars (|ac, ac, int)
%attribute	procedure_pars (|ac, ac, int)
%attribute	procedure_spec (^ac)
%attribute	qual_expr (^ac)
%attribute	raise_stat (^ac)
%attribute	range (^ac)
%attribute	range_constraint (^ac)
%attribute	record_start (^ac, ac, ac, ac, bool)
%attribute	record_type (^ac)
%attribute	relation (^ac)
%attribute	ren_pack
%attribute	ren_sub
%attribute	renamer
%attribute	renobject
%attribute	repr_clause
%attribute	repr_clauses
%attribute	repr_start (^t_tag, bool)
%attribute	return_stat (^ac)
%attribute	reverse (^int)
%attribute	s_choicelist (^ac, ac)
%attribute	s_choices (^ac, int)
%attribute	s_name (^ac)
%attribute	sel_comp (^t_tag, int)
%attribute	select (^ac, int, ac, int)
%attribute	select_call (^ac)
%attribute	select_choice (|int, ac, int, ^ac)
%attribute	select_entry (^ac)
%attribute	select_list (^ac, int, ac, int)
%attribute	select_stat (^ac)
%attribute	selection (|ac, ac, bool, ^ac, ac, ac, bool)
%attribute	selector (|ac, ac, ac, bool)
%attribute	sep_funcid (^ac, ac, ac, int)
%attribute	sep_procid (^ac, ac, ac, int)
%attribute	c_node (^ac, ac, ac)
%attribute	separate (^ac)
%attribute	simple_expr (^ac)
%attribute	simple_name (^ac)
%attribute	stat (^ac)
%attribute	statement (^ac)
%attribute	statements (^ac, ac)
%attribute	stub (^ac)
%attribute	sub_packbody
%attribute	subbody (^ac)
%attribute	subhead (^ac, ac)
%attribute	subspec (^ac)
%attribute	substart (^ac, ac)
%attribute	subtype (^ac)
%attribute	subtype_ind (^ac)
%attribute	t_body (^ac, ac)
%attribute	t_mark (^ac)
%attribute	tagged_stat (^ac)
%attribute	task_start (^ac, ac)
%attribute	taskbody (^ac)
%attribute	taskname (^ac, ac, t_tag)
%attribute	taskobject (^ac)
%attribute	tn (^ac, ac, t_tag)
%attribute	tasktype (^ac, ac)
%attribute	tasktypestart (^ac, ac)
%attribute	term (^ac)
%attribute	type_decl (^ac)
%attribute	type_id (^t_tag)
%attribute	type_mark (^ac)
%attribute	type_name (^ac)
%attribute	type_start (^t_tag, ac)
%attribute	unit (^ac, int)
%attribute	unit_list (^ac)
%attribute	unop (^t_tag)
%attribute	use_init
%attribute	use_inwith (^ac, ac)
%attribute	useclause
%attribute	var_part (|ac, ac, ac, bool)
%attribute	variant (|ac, ac, ac, bool)
%attribute	with_use (^ac, ac)
%attribute	withclause (^ac, ac)
%attribute	x_name (^ac)
%%

Comp:		ini_all Comp_unit |
		Comp ini_all Comp_unit;

ini_all:	=
		{ IInit ();
		  s_add (":#sf:%s", m_prog);
		};

Comp_unit:	use_init unit_list (^t) =
		{ /* package standard !!!!		*/
	          generate_code (mainlun, NULL, $t, SPEC, errors);
		} |
		real_unit (^t, w, k) =
	        { generate_code (mainlun, $w, $t, $k, errors);
	        };

real_unit (^t, w, k):
		c_package (^t, w) T_SEM_COL =
		{ $k = SPEC;
		  s_d_add (":#kd:PS:%s:%d", g_tag ($t), mainlun);
		} |
		c_packbody (^t, w) T_SEM_COL =
		{ $k = XBODY;
                  if (is_generic (g_specif ($t))) {
		     $k =  GEN | $k;
                     s_d_add (":#kd:GPB:%s:%d", g_tag ($t), mainlun);
		  }
                  else
		     s_d_add (":#kd:PB:%s:%d", g_tag ($t), mainlun);
		} |
		c_subdecl (^t, w) T_SEM_COL =
		{ $k = SPEC;
		  s_d_add (":#kd:SS:%s:%d", g_tag ($t), mainlun);
		} |
		c_subbody (^t, w) T_SEM_COL =
		{ $k = XBODY;
		  s_d_add (":#kd:SB:%s:%d", g_tag ($t), mainlun);
		} |
		c_genpack (^t, w) =
		{ $k = GEN | SPEC;
		  s_d_add (":#kd:GPS:%s:%d", g_tag ($t), mainlun);
		} |
		sep_subbody (^t, w) T_SEM_COL =
		{ $k = XBODY;
		  s_d_add (":#kd:SUS:%s:%d", procname ($t), mainlun);
		} |
		sep_packbody (^t, w) T_SEM_COL =
		{ $k = XBODY;
		  s_d_add (":#kd:SUP:%s:%d", procname ($t), mainlun);
		}|
		sep_taskbody (^t, w) T_SEM_COL =
		{ $k = XBODY;
		  s_d_add (":#kd:SUS:%s:%d", procname ($t), mainlun);
		};

c_package (^t, w):
		c_node (^t, w, ct) locals privpart T_END opt_id =
		{ DELSCOPE ($t, $ct);
		  CHECK_OPTIDENT (g_tag ($t), $5, "%s in unbalance %s");
		  DECL_CHECK (FALSE, $t, "erroneous declaration in %s");
		  del_optid ($5);
		} |
		context_spec (^x, y) T_PACKAGE T_IDENT T_IS T_NEW instantiation (^t1) =
		{ ac t = instantiate ($3, $t1);
		  $w = $x;
		  $t = t;
		};

c_node (^t, w, ct):
		context_spec (^x, y) T_PACKAGE T_IDENT T_IS =
		{ $t = mk_package ($3);
		  $w = $x;
		  OBJDECL ($t, "package id %s not unique");
		  $ct = NEWSCOPE ($t);
		};

c_packbody (^t, w):
		c_packbegin (^t, w, ct) T_END opt_id =
		{ DELSCOPE ($t, $ct);
		  CHECK_OPTIDENT (g_tag ($t), $3, "%s in unbalance");
		  del_optid ($3);
		} |
		c_packbegin (^t, w, ct) T_BEGIN statements (^x, y)
		                        opt_except  (^z) T_END opt_id =
		{ DELSCOPE ($t, $ct);
		  CHECK_OPTIDENT (g_tag ($t), $6, "unbalance in %s");
		  s_PB_stats ($t, $x);
		  s_PB_exh   ($t, $z);
		  del_optid  ($6);
		};

c_packbegin (^t, w, ct):
		c_packstart (^t, w, ct) decl_part =
		{ DECL_CHECK (TRUE, $t, 
		              "declaration in %s or its specification incomplete");
		};

c_packstart (^t, w, ct):
		context_spec (^x, y) T_PACKAGE T_BODY T_IDENT T_IS =
		{ ac t, y;
		  struct lib_unit *r;
		  r = read_tree ($4, SPEC);
		  if (r == (struct lib_unit *)NULL) {
		     error ("Cannot locate package %s", $4);
		     exit (111);
		  }
		  withprocess (r);
		  OBJDECL (r -> unit, "Cannot happen");
		  t = mk_with (r -> unit, g_tag (r -> unit));
		  if ($y == NULL)
		     $x = t;
		  else
		     s_next ($y, t);

		  say_start ("package body", $4);
		  if (is_instantiated (packspec (r -> unit))) {
		     error ("Package %s instantiated before elaboration of body\n",
			                            $4);
		  }
		  $t = mk_pbody ($4, packspec (r -> unit));
		  introduce ($t);
		  $ct = NEWSCOPE ($t);
		  $w = $x;
		};

c_subdecl (^t, w):
		context_spec (^x, y) subspec (^z) =
		{ $t = $z;
		  $w = $x;
		  say_start ("sub program specification %s\n", g_tag ($z));
		  chk_6_7_4 ($z);
		};

c_subbody (^t, w):
		c_substart (^t, w, ct) decl_part T_BEGIN
		           statements (^x, y) opt_except (^z) T_END opt_id =
		{ DECL_CHECK (TRUE, $t, "incomplete decls (%s)");
		  CHECK_OPTIDENT (g_tag ($t), $7, "unbalance in %s");
		  s_SBB_stats ($t, $x);
		  s_SBB_exh   ($t, $z);
		  DELSCOPE    ($t, $ct);
		  del_optid   ($7);
		};

c_substart (^t, w, ct):
		context_spec (^x, y) subspec (^z) T_IS =
		{ struct lib_unit *t;
		  int status = TRUE;

		  chk_6_7_4 ($z);
		  say_start ("subprogram body", g_tag ($z));
		  t = read_tree (g_tag ($z), SPEC);
		  if (t == NULL) {
		     SUBDECL ($z);
		     s_d_add (":#kd:SS:%s:%d", g_tag ($z), mainlun);
		     generate_code (mainlun, $x, $z, SPEC, errors);

		     mainlun = (int)get_cun (&status);
		     if (!status) {
		        fail ((short)mainlun, &status);
		        exit (111);
		     }
		     new_lun (mainlun); in_antag ();
		   /* The body only has to refer to its spec in the with list */
		     $w = mk_with ($z, g_tag ($z));
		     $t = mk_sbody (mk_tag (g_tag ($z), IDL), $z);
		     introduce ($t);
		     $ct = NEWSCOPE ($t);
		  }
		  else
		  {  if ((g_d (t -> unit) != XSUB) ||
		        (!eq_subs (t -> unit, $z, TRUE, TRUE)) ) {
		         error ("Non-sub or non-matching sub (%s) in lib\n",
	                                         g_tag ($z)    );
		         exit (22);
		     }
		     withprocess (t);
		     $w = mk_with (t -> unit, g_tag ($z));
		     s_next ($w, $x);
		     SUBDECL (t -> unit);
		     $t = mk_sbody (mk_tag (g_tag ($z), IDL), t -> unit);
		     introduce ($t);
		     $ct = NEWSCOPE ($t);
		  }
		};

c_genpack (^t, w):
		c_genstart (^t, w, x, ct1, ct2) locals privpart T_END opt_id  T_SEM_COL =
		{ DELSCOPE ($x, $ct2);
		  DELSCOPE ($t, $ct1);
		  OBJDECL ($t, "generic package not unique %s");
		  CHECK_OPTIDENT (g_tag ($x), $5, "%s in unbalance");
		  DECL_CHECK (FALSE, $x, "erroneous declaration in %s");
		  del_optid ($5);
		};

c_genstart (^t, w, x, ct1, ct2):
		c_genbegin (^t, w, x, ct1) T_PACKAGE T_IDENT T_IS =
		{ $x = mk_package ($3);
		  s_tag ($t, mk_tag ($3, IDL));
		  set_generic ($x);
		  say_start ("generic package", $3);
		  s_genunit ($t, $x);
		  add_def ($x);
		  $ct2 = NEWSCOPE ($x);
		};

c_genbegin (^t, w, x, ct1):
		c_gennode (^t, w, x, ct1) genpars;

c_gennode (^t, w, x, ct1):
		context_spec (^z, y) T_GENERIC =
		{ $t = mk_generic ();
		  $w = $z;
		  $x = NULL;	/* the tree	*/
		  say_start ("generic compilation unit", " ");
		  $ct1 = NEWSCOPE ($t);
		};

genpars:	|
		genparlist;

genparlist:	genparameter T_SEM_COL |
		genparlist genparameter T_SEM_COL ;

genparameter:	type_start (^t, l) T_IS T_PRIVATE =
		{ ac t = mk_genpartype ($t, GENPRIVTYPE);
		  OBJDECL (t, "%s declared more than once");
		  set_genpar (t);
		} |
		type_start (^t, l) T_IS T_RANGE T_BOX =
		{ ac t = mk_genpartype ($t, NEWINTTYPE);
		  if ($l != NULL) {
		     error ("illegal discriminants in generic parameter %s\n",
							$t);
		  }
		  OBJDECL (t, "%s declared more than once");
		  set_genpar (t);
		} |
		type_start (^t, l) T_IS T_DELTA T_BOX =
		{ ac t = mk_genpartype ($t, NEWFLOATTYPE);
		  if ($l != NULL) {
		      error ("Illegal discriminants in generic parameter %s\n",
							$t);
		  }
		  OBJDECL (t, "%s declared more than once");
		  set_genpar (t);
		}|
		type_start (^t, dl) T_IS T_ACCESS type_name (^t1) =
		{ ac t;
		  t = mk_acctype ($t, $t1);
		  PREDECL (t);
		  NO_DISCRS ($dl, g_tag (t),
                       "illegal discriminants for %s (parameter in generic)");
		  set_genpar (t);
		} |
		type_start (^t, l) T_IS T_LP T_BOX T_RP =
		{ ac t = mk_genpartype ($t, SCALARTYPE);
		  NO_DISCRS ($l, $t,
                          "illegal discriminants in generic param %s");
		  OBJDECL (t, "%s (generic parameter) declared more than once");
		  set_genpar (t);
		} |
		T_WITH subspec (^t) =
		{ SUBDECL ($t);
		  set_genpar ($t);
		  chk_6_7_4 ($t);
		} |
		T_WITH subspec (^t) T_IS T_BOX =
		{ SUBDECL ($t);
		  set_genpar ($t);
		  set_sdefault ($t);
		  chk_6_7_4 ($t);
		} |
		T_WITH subspec (^t) T_IS expr (^t1) =
		{ ac f;
		  chk_6_7_4 ($t);
		  SUBDECL ($t);
		  set_genpar ($t);
		  $t1 = bu_expr ($t1);
		  if ($t1 == NULL) {
		     error ("Error in subprogram default %s\n", g_tag ($t));
		  }
		  else
		  { f = FIND_RENAMEDSUBS ($t, g_primary ($t1),
		               "Error in subprogram default %s");
		    s_sub_default ($t, f);
		  }
		} |
		array_start (^t0) T_LP index_list (^f, l) T_RP T_OF subtype_ind (^t)=
		{ ac t;
		  $t = CONST_TYPE ($t, $t0,
                               "Unvalid array element for parameter %s");
		  t = mk_array ($t0, $f, $t);
		  PREDECL (t);
		  set_genpar ($t);
		} |
		genobjectpar (^t, c, d) =
		{ LIST_INTRO ($t, "generic parameter %s not unique");
		} ;

genobjectpar (^t, c, d):
		T_IDENT T_COLON geninoutspec (^t1) =
		{ ac t = mk_object ($1, $t1);
		  $c = 1;
		  $d = $t1;
		  $t = t;
		} |
		T_IDENT T_COMMA genobjectpar (^t, c, d) =
		{ ac t = mk_object ($1, cp_tree ($d));
		  set_genpar (t);
		  $c += 1;
		  s_next (t, $t);
		  $t = t;
		};

opt_in:		|
		T_IN;

geninoutspec (^t):
		opt_in c_typename (^t1) opt_expr (^t2) =
		{ $t2 = SOLVE_EXPR ($t2, $t1, "type error in generic default");
		  $t = mk_desc ($t1, INMODE | 0400, $t2);
		} |
		T_IN T_OUT c_typename (^t1) =
		{ $t = mk_desc ($t1, INOUTMODE | 0400, NULL);
		};


sep_subbody (^t, w):
		sep_substart (^t, w, ct) decl_part T_BEGIN
		             statements (^x, y) opt_except (^z) T_END opt_id =
		{ DECL_CHECK (TRUE, $t, "incomplete declarations (%s)");
		  CHECK_OPTIDENT (g_tag ($t), $7, "unbalance in %s");
		  s_SBB_stats ($t, $x);
		  s_SBB_exh   ($t, $z);
		  DELSCOPE    ($t, $ct);
		  del_optid   ($7);
		};

sep_substart (^t, w, ct):
		sep_subhead (^t, w, r) T_IS =
		{ $t = mk_sbody (mk_tag (g_tag ($r), IDL), $r);
		  $ct = NEWSCOPE ($t);
		};

sep_subhead (^t, w, r):
		sep_procid (^x, fn, ct1, cnt) procedure_pars (|fn, ct1, cnt) =
		{ DELSCOPE ($fn, $ct1);
		  s_rettype ($fn, notype);
		  $r = g_stub_spec ((ac)get_sstub (env, $fn));
		  $w = $x;
		  $t = $fn;
		} |
		sep_funcid (^x, fn, ct1, cnt) function_pars (|fn, ct1, cnt)
		           T_RETURN type_name (^t1) =
		{ DELSCOPE ($fn, $ct1);
		  s_rettype ($fn, $t1);
		  $r = g_stub_spec ((ac)get_sstub (env, $fn));
		  $w = $x;
		  $t = $fn;
		};

sep_procid (^p, fn, ct, cnt):
		context_spec (^x, y) separate (^a) T_PROCEDURE T_IDENT=
		{ if ($y == NULL)
		     $p = $a;
		  else
		  {  s_next ($y, $a);
		     $p = $x;
		  }
		  p_proc ($a, $4);
		  $fn = mk_sub ($4, FALSE);
		  $ct = NEWSCOPE ($fn);
		  $cnt = 0;
		};

sep_funcid (^p, fn, ct, cnt):
		context_spec (^x, y) separate (^a) T_FUNCTION T_IDENT =
		{ if ($x == NULL)
		     $p = $a;
		  else
		  {  s_next ($y, $a);
		     $p = $x;
		  }
		  p_proc ($a, $4);
		  $fn = mk_sub ($4, FALSE);
		  $ct = NEWSCOPE ($fn);
		  $cnt = 0;
		};

sep_packbody (^t, w):
		sep_packbegin (^t, w, ct) T_END opt_id =
		{ DELSCOPE ($t, $ct);
		  CHECK_OPTIDENT (g_tag ($t), $3, "%s in unbalance");
		  del_optid ($3);
		} |
		sep_packbegin (^t, w, ct) T_BEGIN statements (^x, y)
		              opt_except (^z)  T_END opt_id =
		{ DELSCOPE ($t, $ct);
		  CHECK_OPTIDENT (g_tag ($t), $6, "unbalance %s");
		  s_PB_stats ($t, $x);
		  s_PB_exh   ($t, $z);
		  del_optid  ($6);
		};

sep_packbegin (^t, w, ct):
		sep_packstart (^t, w, ct) decl_part =
		{ DECL_CHECK (TRUE, $t, "declarations in %s");
		};

sep_packstart (^t, w, ct):
		context_spec (^x, y) separate (^a) T_PACKAGE T_BODY T_IDENT T_IS=
		{ ac t;
		  if ($y  == NULL)
		     $w = $a;
		  else
		  { s_next ($y, $a);
		    $w = $x;
		  }
		  s_d_add (":#kd:PB:%s:%d", $5, mainlun);
		  p_proc ($a, $5);	/* establish environment	*/
		  t = get_pbstub (env, $5);
		  if (t == NULL) {
		     error ("cannot find stub %s", $5);
		     exit (111);
		  }

		  $t = mk_pbody ($5, packspec (g_stub_spec (t)));
		  if (is_generic (g_specif ($t))) {
		     error ("Separate generic subbodies not supported\n");
		  }

		  $ct = NEWSCOPE ($t);
		};

sep_taskbody (^t, w):
		sep_taskbegin (^t, w, ct) T_BEGIN statements (^x, y)
		                          opt_except (^z) T_END opt_id =
		{ DELSCOPE ($t, $ct);
		  CHECK_OPTIDENT (g_tag ($t), $6, "unbalance in %s");
		  s_task_stats ($t, $x);
		  s_task_exh   ($t, $z);
		  del_optid    ($6);
		};

sep_taskbegin (^t, w, ct):
		sep_taskstart (^t, w, ct) decl_part =
		{ DECL_CHECK (TRUE, $t, "declarations in %s");
		};

sep_taskstart (^t, w, ct):
		context_spec (^x, y) separate (^a) T_TASK T_BODY T_IDENT T_IS =
		{ ac t;
		  if ($y == NULL)
		     $w = $a;
		  else
		  {  s_next ($y, $a);
		     $w = $x;
		  }
		  s_d_add (":#kd:PB:%s:d", $5, mainlun);
		  p_proc ($a, $5);
		  t = get_tbstub (env, $5);
		  if (t == NULL) {
		     error ("Cannot find stub %s", $5);
		     exit (111);
		  }

		  $t = mk_tbody ($5, g_stub_spec (t));
		  $ct = NEWSCOPE ($t);
		};

separate (^x):
		T_SEPARATE T_LP ct_name (^t, top) T_RP =
		{ s_add (":#su:%s", $t);
		  prev = NULL;
		  env = ((struct lib_unit *)$top) -> unit;
		  $x = mk_separate ($t);
		  s_septree ($x, $top);
		} ;

ct_name (^x, a):
		T_IDENT =
		{ struct lib_unit *xx;
		  struct lib_unit *t = read_tree ($1, XBODY);
		  if (t == (struct lib_unit *)NULL) {
		     error ("Fatal: cannot find %s in library", $1);
		     exit (121);
		  }
		  xx = read_tree ($1, SPEC);
		  if (xx == (struct lib_unit *)NULL) {
		     error ("Fatal: cannot happen:2");
		     exit (121);
		  }
		  withprocess (xx);	/* the specification	*/
		  $x = tmpvec ($1);
		  withprocess (t);
		  $a = (ac)t;
		} |
		ct_name (^x, a) T_DOT T_IDENT =
		{ struct lib_unit *t;
		  $x = add_tmpvec (add_tmpvec ($x, "."), $3);
		  t = read_tree ($x, XBODY);
		  if (t == (struct lib_unit *)NULL)
		     sys_error ("Help");	
		  withprocess (t);
		  $a = (ac)t;	/* the deepest one	*/
		};

use_init:	=
		{ special_cun (STD_LUN);
		  mainlun = STD_LUN;
		  new_lun (mainlun);
		  in_antag ();
		  i_open_scopes ();
		  new_start ();
		};

context_spec (^x, y):	=
		{ int status = TRUE;
		  mainlun = (int)get_cun (&status);
		  if (!status) {
		     fail ((short) mainlun, &status);
		     if (!status)
		        fprintf (stderr, "cun %d can't be removed, get help\n", mainlun);
		     exit (111);
		  }
		  rd_standard ();
		  new_lun (mainlun); in_antag ();
		  i_open_scopes ();
		  new_start ();
		  $x = $y = NULL;
		} |
		context_spec (^x, y) with_use (^x1, y1) T_SEM_COL =
		{ if ($x == NULL) {
		     $x = $x1;
		     $y = $y1;
		  } else
		  {  s_next ($y, $x1);
		     $y = $y1;
		  }
		} ;

with_use (^x, y):
		withclause (^x, y) |
		use_inwith (^x, y);

withclause (^x, y):
		T_WITH T_IDENT =
		{ struct lib_unit *t = read_tree ($2, SPEC);
		  if (t == (struct lib_unit *)NULL) {
		     error ("Cannot find specification %s", $2);
		     exit (111);
		  }
		  $x = mk_with (t -> unit, $2);
		  OBJDECL (g_withunit ($x), "Cannot happen");
		  OBJDECL (t -> unit, "WAT IS DAT NU???");
		  $y = $x;
		} |
		withclause (^x, y) T_COMMA T_IDENT =
		{ struct lib_unit *t = read_tree ($3, SPEC);
		  if (t == (struct lib_unit *)NULL) {
		     error ("Cannot find specification %s", $3);
		     exit (111);
		  }
		  s_next ($y, mk_with (t -> unit, $3));
		  $y = g_next ($y);
		  OBJDECL (g_withunit ($y), "Cannot happen");
		  OBJDECL (t -> unit, "Cannot happen:21");
		};

use_inwith (^x, y):
		T_USE ls_name (^t) =
		{ $x = mk_use (td_n_name (bu_name ($t)));
		  $y = $x;
		} |
		use_inwith (^x, y) T_COMMA ls_name (^t) =
		{ ac r = mk_use (td_n_name (bu_name ($t)));
		  s_next ($y, r);
		  $y = r;
		};

useclause:	T_USE ls_name (^t) =
		{ introduce (mk_use (td_n_name (bu_name ($t))));
		} |
		useclause T_COMMA ls_name (^t) =
		{ introduce (mk_use (td_n_name (bu_name ($t))));
		} ;
pragma:		T_PRAGMA T_IDENT = {
		   do_pragma_0 ($2, NULL);
		} |
		T_PRAGMA T_IDENT T_LP ls_name (^t) T_RP =
		{ do_pragma_1 ($2, $t);
		} |
		T_PRAGMA T_IDENT T_LP ls_name (^t1) T_COMMA ls_name (^t2) T_RP =
		{ do_pragma_2 ($2, $t1, $t2);
		} |
		T_PRAGMA T_IDENT T_LP ls_name (^t1) T_COMMA ls_name (^t2) T_COMMA
	                                    T_CHAR_STRING T_RP =
		{ do_pragma_3 ($2, $t1, $t2, $8);
		} ;

instantiation (^t):
		ls_name (^t) =
		{ $t = mk_call ($t, NULL);
		} |
		ls_name (^t) T_LP gen_actpars (^f, l, k) T_RP =
		{ $t = mk_call ($t, $f);
		} ;

gen_actpars (^f, l, k):
		gen_actpar (^f, k1) =
		{ $l = $f;
		  $k = $k1;
		} |
		gen_actpars (^f, l, k) T_COMMA gen_actpar (^t, k1) =
		{ $k = acceptable ($k, $k1, "parameter order in generic illegal");
		  s_next ($l, $t);
		  $l = $t;
		};

gen_actpar (^t, k):
		gen_parassoc (^t) =
		{ $k = XCALL;
		} |
		expr (^t) =
		{ $k = XINDEXING;
		};

gen_parassoc (^t):
		T_IDENT T_ARROW expr (^t) =
		{ $t = mk_namass ($1, $t);
		} |
		T_CHAR_STRING T_ARROW ls_name (^t) =
		{ $t = mk_namass (chk_char ($1,
                      "Illegal operator (%s) as left hand in generic par"), $t);
		} ;

unit_list (^t):	exception (^t) T_SEM_COL locals;

subbody (^t):	subhead (^t, ct)
			T_BEGIN statements (^x, y) opt_except (^z) T_END opt_id =
		{
		  CHECK_OPTIDENT (g_tag (g_specif ($t)), $6,
					       "unbalance in proc body %s");
		  s_SBB_stats ($t, $x);
		  s_SBB_exh ($t, $z);
		  DELSCOPE ($t, $ct);
		  del_optid ($6);
		} ;

subhead (^t, ct):
		substart (^t, ct) decl_part =
		{ DECL_CHECK (FALSE, $t,
	                      "declaration in %s incomplete, bodies missing");
		} ;

substart (^t, ct):
		subspec (^z) T_IS
		{ ac r;
		  r = FIND_SUBSPEC ($z, env,
		           "procedure (function) declaration: probably incorrect specification for %s");
		  $t = mk_sbody (mk_tag (g_tag (r), IDL), r);
		  introduce ($t);
		  $ct = NEWSCOPE ($t);
		} ;

gen_package (^t1):
		genbegin (^t1, ct1, t2, ct2) locals privpart T_END opt_id =
		{ DELSCOPE ($t2, $ct2);
		  DELSCOPE ($t1, $ct1);
		  CHECK_OPTIDENT (g_tag ($t1), $5,
                                "generic package: unbalance in %s");
		  OBJDECL ($t1, "Generic package %s not unique");
		  DECL_CHECK (FALSE, $t1, 
                          "generic package: incomplete list of declarations %s");
		  del_optid ($5);
		};

genbegin (^t1, ct1, t2, ct2):
		gennode (^t1, ct1) genpars T_PACKAGE T_IDENT T_IS =
		{ $t2 = mk_package ($4);
		  s_tag ($t1, mk_tag ($4, IDL));
		  set_generic ($t2);
		  s_genunit ($t1, $t2);
		  add_def ($t2);
		  $ct2 = NEWSCOPE ($t2);
		};

gennode (^t, ct):
		T_GENERIC =
		{ $t = mk_generic ();
		  $ct = NEWSCOPE ($t);
		};

package (^t1):	p_node (^t1, ct1) locals privpart T_END opt_id =
		{ DELSCOPE ($t1, $ct1);
		  CHECK_OPTIDENT (g_tag ($t1), $5, 
                             "Package %s: unbalance in opening tag");
		  DECL_CHECK (FALSE, $t1, 
                            "Package %s: erroneous declarations");
		  del_optid ($5);
		} ;

gen_instance (^t1):
		T_PACKAGE T_IDENT T_IS T_NEW instantiation (^t) =
		{ ac t = instantiate ($2, $t);
		};


p_node (^t, ct):
		T_PACKAGE T_IDENT T_IS
		{ $t = mk_package ($2);
		  OBJDECL ($t, "Package %s: identifier not unique");
		  $ct = NEWSCOPE ($t);
		} ;

taskname (^t, ct, tag):
		T_TASK T_IDENT =
		{ $t = mk_task (mk_tag (gen_tag (), IDL));
		  INTRODUCE ($t);
		  $ct = NEWSCOPE ($t);
		  $tag = $2;
		};

taskobject (^t):
		tn (^t, ct, tag) =
		{ ac t, r;
		  DELSCOPE ($t, $ct);
		  off_intro ($t);
		  t = mk_object ($tag, mk_desc ($t, KVAR, NULL));
		  OBJDECL (t, "%s (task) declared more than once");
		  $t = t;
		};

tn (^t, ct, tag):
		taskname (^t, ct, tag)   |
		taskname (^t, ct, tag) T_IS entry_list (^c) T_END opt_id ;

tasktypestart (^t, ct):	T_TASK T_TYPE T_IDENT =
		{ ac t;
		  t = mk_task ($3);
		  PREDECL (t);
		  $ct = NEWSCOPE (t);
		  $t = t;
		};

tasktype (^t, ct):	tasktypestart (^t, ct) |
		tasktypestart (^t, ct) T_IS entry_list (^c) T_END opt_id ;


entry_list (^c):	entry (^t) =
		{ $c = 1;
		  s_entry_nr ($t, 1);
		} |
		entry_list (^c) entry (^t) =
		{ $c = $c + 1;
		  s_entry_nr ($t, $c);
		};

entry (^t):	entry_name (^t, ct, cnt)
		        procedure_pars (|t, ct, cnt) T_SEM_COL =
		{ s_rettype ($t, notype);
		  DELSCOPE ($t, $ct);
		};

entry_name (^t, ct, cnt):	T_ENTRY T_IDENT =
		{ $t = mk_entry ($2);
		  SUBDECL ($t);
		  $ct = NEWSCOPE ($t);
		  $cnt = 0;
		};

privpart:	=
		{ ac t = mk_prpart ();
		  introduce (t);
		  DELSCOPE (t, NEWSCOPE (t));
		} |
		priv_node (^t, ct) locals =
		{ DELSCOPE ($t, $ct);
		};

priv_node (^t, ct):	T_PRIVATE =
		{ $t = mk_prpart ();
		  introduce ($t);
		  $ct = NEWSCOPE ($t);
		} ;

packbody:	pack_start (^t, ct) T_END opt_id =
		{ DELSCOPE ($t, $ct);
		  CHECK_OPTIDENT (g_tag ($t), $3, "%s in unbalance");
		  del_optid ($3);
		} |
		pack_start (^t, ct)
			T_BEGIN statements (^x, y) opt_except (^z) T_END opt_id =
		{
		  DELSCOPE ($t, $ct);
		  CHECK_OPTIDENT (g_tag ($t), $6, 
                         "Package body: %s in unbalance");
		  s_PB_stats ($t, $x);
		  s_PB_exh ($t, $z);
		  del_optid ($6);
		} ;

pack_start (^t, ct):
		p_body (^t, ct) decl_part =
		{ DECL_CHECK (FALSE, $t, 
                         "Package body: %s declaration");
		} ;

p_body (^t, ct):
		T_PACKAGE T_BODY T_IDENT T_IS =
		{ $t = mk_pbody ($3,
                          packspec (FIND_PACKSPEC ($3, 
                                    "Package body %s: Cannot find spec")));
		  if (is_instantiated (g_specif ($t))) {
		     error ("Specification instantiated before body elab %s\n",
			                                      $3);
		  }
		  introduce ($t);
		  $ct = NEWSCOPE ($t);
		} ;

decl_part:	declar_part |
		declar_part repr_clauses;

repr_clauses:	repr_clause |
		repr_clauses repr_clause;

repr_start (^t, err):	T_FOR simple_name (^t) T_USE ;

repr_clause:	repr_start (^t, e1) aggregate (^t2) T_SEM_COL =
                { error ("Ada-- does currently not support this kind of repr ");
		} |
		repr_start (^v, e1) T_AT simple_expr (^t2) T_SEM_COL=
		{ ac t = mk_foruse (chk_varname (td_n_name (bu_name ($v))),
			                         STATIC_EXPR ($t2, std_univ,
	                                                     "illegal expr"));
		} ;

declar_part:	locals |
		locals sub_packbody T_SEM_COL body_part ;

locals:		|
		locals declaration T_SEM_COL ;

declaration:	object_decl (^t, t1) =
		{ off_intro ($t);
		} |
		type_decl (^t) =
		{ POSTDECL ($t);
		} |
		package (^t) |
		gen_package (^t) |
		gen_instance (^t) |
		subspec (^t) =
		{ chk_6_7_4 ($t);
		  SUBDECL ($t);
		} |
		useclause  |
		pragma	|
		renamer |
		taskobject (^t) |
		exception (^t) ;

exception (^t):	ex_list (^t) |
		T_IDENT T_COLON T_EXCEPTION T_RENAMES ls_name (^t1) =
		{ $t = mk_exception ($1);
		  OBJDECL ($t, "Exception declaration: renaming %s not unique");
		  s_rnam ($t, get_exc (td_n_name (bu_name ($t1))));
		};

ex_list (^t):	T_IDENT T_COLON T_EXCEPTION =
		{ $t = mk_exception ($1);
		  OBJDECL ($t, "Exception declaration: %s not unique");
		} |
		T_IDENT T_COMMA ex_list (^t) =
		{ ac t = mk_exception ($1);
		  OBJDECL (t, "Exception declaration: %s not unique");
		  $t = t;
		} ;

body_part:	|
		body_part body T_SEM_COL ;

sub_packbody:	subbody (^t) |
		taskbody (^t) |
		stub (^t) |
		packbody;

body:		subbody (^t) |
		package (^t) |
		gen_package (^t) |
		gen_instance (^t) |
		packbody |
		stub (^t) |
		taskbody (^t) |
		pragma	|
		useclause |
		taskobject (^t) |
		tasktype (^t, ct) = 
		{ DELSCOPE ($t, $ct);
                  POSTDECL ($t);
		} ;

stub (^t):	T_PACKAGE T_BODY T_IDENT T_IS T_SEPARATE =
		{ ac r;
		  if (!sep_pb (env))
		     error ("Package body stub not allowed here (%s)", $3);
                  else
		  {  r = FIND_PACKSPEC ($3, "Body stub %s: no spec, fatal");
		     if (r == NULL)
		        exit (04);
		     s_add (":#st:%s", $3);
		     $t = mk_stub ($3, r);
		     introduce ($t);
		     s_pack_body (r, $t);
		  }
		} |
		subspec (^t) T_IS T_SEPARATE =
		{ ac t, r;
		  if (!sep_sub (env))
		     error (
                       "Procedure body stub (%s) not allowed here", g_tag ($t));
		  else
		  {  t = FIND_SUBSPEC ($t, env, "decl: subspec %s");
		     s_add (":#st:%s", g_tag (t));
		     r = mk_stub (mk_tag (g_tag (t), IDL), t);
		     s_body_imp (t, r);
		     INTRODUCE (r);
		     $t = r;
		  }
		} |
		T_TASK T_BODY T_IDENT T_IS T_SEPARATE =
		{ ac r;
		  if (!sep_tb (env))
		     error ("Task body stub (%s) not allowed here", $3);
		  else
		  {  r = FIND_TASKSPEC ($3,
                           "Task body stub %s: no specification Fatal");
		     if (r == NULL)
		        exit (05);
		     s_add (":#st:%s", $3);
		     $t = mk_stub ($3, r);
		     introduce ($t);
		     s_taskbody (r, $t);
		  }
		};

taskbody (^t):	task_start (^t, ct) T_BEGIN
			statements (^x, y) opt_except (^z) T_END opt_id =
		{ DELSCOPE ($t, $ct);
		  CHECK_OPTIDENT (g_tag ($t), $6, "Task body %s in unbalance");
		  del_optid ($6);
		  s_task_stats ($t, $x);
		  s_task_exh   ($t, $z);
		} ;

task_start (^t, ct):	t_body (^t, ct) decl_part =
		{ DECL_CHECK (FALSE, $t,
		              "Task body declarations in %s incomplete");
		};

t_body (^t, ct):	T_TASK T_BODY T_IDENT T_IS =
		{ ac t = FIND_TASKSPEC ($3,
                         "Cannot find specification for task body %s (Fatal)");
		  if (t == NULL) {
		     exit (104);
		  }
		  $t = mk_tbody ($3, t);
		  introduce ($t);
		  $ct = NEWSCOPE ($t);
		  s_pack_body (t, $t);
		};

/*
 *	- renaming object declaration
 *	  that makes it necessary to delay allocation
 *	  of a record until we know for sure what we
 *	  really want
 */
object_decl (^t, r):	T_IDENT T_COLON easy_spec (^x) =
		{ $t = mk_object ($1, $x);
		  OBJDECL ($t, "%s declared twice");
		  $r = $x;
		} |
		T_IDENT T_COLON subtype_ind (^t) opt_expr (^t1) =
		{ ac t;
		  $t = CONST_TYPE ($t, $1, "unconstrained type for object %s");
		  $t1 = SOLVE_EXPR ($t1, $t, "illegal type init expr");
		  if ($t1 != NULL && !has_eq_and_ass ($t))
	             error ("Initialization for %s not allowed", $1);
		  $r = mk_desc ($t, KVAR, $t1);
		  t = mk_object ($1, $r);
		  OBJDECL (t, "%s declared twice");
		  $t = t;
		} |
		T_IDENT T_COMMA object_decl (^t, r) =
		{ $t = mk_object ($1, cp_tree ($r));
		  OBJDECL ($t, "%s declared twice");
		} ;

easy_spec (^t):	T_CONSTANT subtype_ind (^t) as_expr (^t1) =
		{ $t1 = SOLVE_EXPR ($t1, $t, "illegal type init expr");
	          if ($t1 != NULL && !has_eq_and_ass ($t))
		     error ("Initialization not allowed");
		  $t = mk_desc ($t, KCONST, $t1);
		} |
		T_CONSTANT subtype_ind (^t) =
		{ if (!is_local_private ($t))
		     error ("Initialization requires expression");
		  if (!has_eq_and_ass ($t))
		     error ("Initialization not allowed");
		  $t = mk_desc ($t, KCONST, NULL);
		} |
		T_CONSTANT as_expr (^t)  =
		{ $t = SOLVE_EXPR ($t, types_of ($t), "error in number");
		  $t = mk_desc (type_of ($t), KNUMB, $t);
		} |
		implied_array (^t, f) opt_expr (^t1) =
		{ $t1 = SOLVE_EXPR ($t1, $f, "illegal type init expr");
		  $t = mk_desc ($f, KVAR, $t1);
		} |
		T_CONSTANT implied_array (^t, f) as_expr (^t1) =
		{ $t1 = SOLVE_EXPR ($t1, $f, "error in array constant");
		  $t = mk_desc ($f, KCONST, $t1);
		} ;

type_decl (^z):	record_type (^z) |
		private_type (^z) |
		array_type (^z) |
		enum_type (^z) |
		incomplete_type (^z) |
		subtype (^z) |
		access_type (^z) |
		tasktype (^z, ct) =
		{ DELSCOPE ($z, $ct);
		} |
		newtype_decl (^z) ;

newtype_decl (^z):
		type_start (^t, dl) T_IS T_RANGE range (^t1) =
		{ ac t, r, s;
		  NO_DISCRS ($dl, $t, "New type: illegal discriminants in %s");
		  t = TD_FILTER (bu_filter (mk_filter (NULL, $t1)),
		     "Cannot determine range types in new type %s", $t);
		  if (t != NULL) {
		     if (!is_static (t))
		        error ("Range in new integer type non-static %s", $t);
		     r = smallest_int (g_constraint (t));
		     s = mk_newtype (r, mk_tag (gen_tag (), IDL), NEWINTTYPE);
		     OBJDECL (s, "Cannot happen %s");
		     coerce_filter (t, s);
		     t = mk_subtype ($t, t);
		     PREDECL (t);
		     set_sttype (t);
		  }
		  $z = t;
		} |
		type_start (^t, dl) T_IS T_NEW c_typename (^t1) =
		{ ac t = mk_newtype ($t1, $t);
		  if (is_sttype ($t1))
		     set_sttype (t);
		  PREDECL (t);
		  NO_DISCRS ($dl, $t, "illegal discriminants in %s");
		  inherit (t, $t1);
		  $z = t;
		} |
		type_start (^t, dl) T_IS
                       T_NEW c_typename (^ct) constraint (|ct, ^t1)=
		{ ac t, r;
		  t = mk_newtype ($ct, mk_tag (gen_tag (), IDL));
		  if (is_sttype ($ct))
		     set_sttype (t);
		  NO_DISCRS ($dl, $t,
                                  "No discriminants in type possible %s");
		  INTRODUCE (t);
		  inherit (t, $ct);
		  r = mk_subtype ($t, mk_filter (t, $t1));
		  if (SOLVE_FILTER (g_parenttype (r), t, $t,
                               "Error in derived type constraint %s") == NULL)
		     r = mk_subtype ($t, t);
		  else
		     PREDECL (r);
		  $z = r;
		} ;

access_type (^z):
		type_start (^t, dl) T_IS T_ACCESS type_name (^t1) =
		{ ac t;
		  t = mk_acctype ($t, $t1);
		  PREDECL (t);
		  NO_DISCRS ($dl, g_tag (t), "illegal discriminants %s");
		  $z = t;
		} |
		type_start (^t, dl) T_IS T_ACCESS
					filtype (^ct) constraint (|ct, ^t1) =
		{ ac t, r;
		  t = mk_acctype (mk_tag (gen_tag (), IDL), $ct);
		  NO_DISCRS ($dl, $t, "illegal discriminants in %s");
		  INTRODUCE (t);
		  r = mk_subtype ($t, mk_filter (t, $t1));
	          if (SOLVE_FILTER (g_parenttype (r), t, $t,
					"error in access decl %s") == NULL) {
		     r = mk_subtype ($t, any_type);
		  }
		  else
		     PREDECL (r);
		  $z = r;
		} ;

/*
 *	record_start:	p = ct (= old env)
 *                      x = rectype node
 *                      y = containing variant
 *                      z = dummy
 */
record_type (^p):
		record_start (^p, x, y, z, b) field_list (|x, y, z, b)
				T_END T_RECORD =
		{ if (g_dis ($x) != NULL) {
		     ac dt = type_of (g_comp (g_dis ($x)));
		     CHECK_VARIANT ($x, dt, "illegal ranges %s", $x);
		  }
		  DELSCOPE ($x, $p);
		} ;

record_start (^p, q, y, z, b):
		type_start (^t, l) T_IS T_RECORD =
		{ $q = mk_recnode ($t);
		  s_flags ($q, g_flags ($q) | HAS_ASSIGN);	/* default	*/
		  PREDECL ($q);
		  $p = NEWSCOPE ($q);
		  LIST_INTRO ($l, "(%s) double appearing");
		  off_intro ($l);
		  $y = $q;	/* current variant	*/
		  $z = (ac) NULL;	/* dummy	*/
		} ;

type_start(^t, l):	type_id (^t) =
		{ $l = NULL; /* discriminants */
		} |
		type_id (^t) disc_part (^l) ;

type_id (^t):	T_TYPE T_IDENT =
		{ $t = $2;	/* keep the tag */
		} ;

disc_part (^t):	disc_specs (^t, l) T_RP;

disc_specs (^t, l):
		T_LP disc_spec (^t, l, d) |
		disc_specs (^t, l) T_SEM_COL disc_spec (^t1, l1, d) =
		{ s_next ($l, $t1);
		  $l = $l1;
		} ;

disc_spec (^t, l, d):
		T_IDENT T_COLON c_typename (^t1) opt_expr (^t2) =
		{ $t1 = IS_SCALAR ($t1, $1, "discr type non scalar %s");
		  $t2 = SOLVE_EXPR ($t2, $t1, "illegal expression for discrim");
		  $d = mk_desc ($t1, KDISCR, $t2);
		  $t = mk_object ($1, $d);
		  $l = $t;
		} |
		T_IDENT T_COMMA disc_spec (^t, l, d) =
		{ ac t = mk_object (t, cp_tree ($d));
		  s_next (t, $t);
		  $t = t;
		} ;

private_type (^z):
		type_start (^t, l) T_IS limited (^i) T_PRIVATE =
		{ ac t;
		  $z = mk_privtype ($t, $l, $i);
		  PREDECL ($z);
		  t = NEWSCOPE ($z);
		  LIST_CHECK ($l);
		  DELSCOPE ($z, t);
		} ;

limited (^x):	=
		{ $x = FALSE;
		} |
		T_LIMITED =
		{ $x = TRUE;
		};

incomplete_type (^z):
		type_start (^t, l) =
		{ ac t;
		  $z = mk_incomplete ($t, $l);
		  PREDECL ($z);
		  t = NEWSCOPE ($z);
		  LIST_CHECK ($l);
		  DELSCOPE ($z, t);
		} ;

enum_type (^z):	enumstart (^z, l, cnt) T_RP =
		{ s_nenums ($z, $cnt);
		  set_sttype ($z);
		} ;

enumstart (^z, l, c):
		enum_name (^z) enumlit (^l) =
		{ s_fenumlit ($z, $l);
		  s_enuml_ord ($l, 0);
		  s_enclunit ($l, $z);
		  if (enum_check ($l))
		     error ("enumeration literal %s not unique", g_tag ($l));
		  add_def ($l);
		  $c = 1;
		} |
		enumstart (^z, l, c) T_COMMA enumlit (^l1) =
		{ s_enclunit ($l1, $z);
		  s_enuml_ord ($l1, $c);
		  s_next ($l, $l1);
		  if (enum_check ($l1))
		     error ("enumeration literal %s not unique", g_tag ($l1));
		  add_def ($l1);
		  $c = $c + 1;
		  $l = $l1;
		} ;

enum_name (^z):	type_start (^t, l) T_IS T_LP =
		{ ac t;
		  t = mk_enum ($t);
		  PREDECL (t);
		  NO_DISCRS ($l, $t, "illegal discriminant in spec %s");
		  $z = t;
		} ;

enumlit (^x):	T_IDENT =
		{ $x = mk_enlit ($1, NULL);
		} |
		T_CHAR_LIT =
		{ $x = mk_charlit ($1, NULL);
		} ;

array_type (^z):
		array_start (^t0) T_LP index_list (^f, l) T_RP T_OF subtype_ind (^t) =
		{ $t = CONST_TYPE ($t, $t0,
                       "Array element of type %s insufficiently constrained");
		  $z = mk_array ($t0, $f, $t);
		  PREDECL ($z);
		  if (has_eq_and_ass ($t))
		     s_flags ($z, g_flags ($z) | HAS_ASSIGN);
		} |
		array_start (^t) T_LP index_constraints (^f, l) T_RP T_OF
						subtype_ind (^t1) =
		{ ac uncons, subt;
		  $t1 = CONST_TYPE ($t1, $t,
                       "Array element of type  %s unconstrained");
		  uncons = conv_array (NULL, $t1);
		  INTRODUCE (uncons);
		  $z = bu_filter (mk_filter (uncons, $f));
		  set_indices (uncons, $f);
		  if (has_eq_and_ass ( $t1))
		     s_flags (uncons, g_flags (uncons) | HAS_ASSIGN);
		  subt = TD_FILTER ($z, "Error in implied array type %s", $t);
		  $z = mk_subtype ($t, subt);
		  PREDECL ($z);
		} ;

array_start (^t):	type_start (^t, dl) T_IS T_ARRAY =
		{ NO_DISCRS ($dl, $t, "illegal discriminants in array type %s");
		} ;

index_list (^t, l):
		index (^t) =
		{ $l = $t;
		} |
		index_list (^t, l) T_COMMA index (^t1) =
		{ s_next ($l, $t1);
		  $l = $t1;
		} ;

index (^t):	c_typename (^t) T_RANGE T_BOX =
		{ $t = mk_index (IS_SCALAR ($t, NULL,
                                             "index type non-scalar"));
		} ;

index_constraints (^t, l):
		discr_range (^t) =
		{ $l = $t;
		} |
		index_constraints (^t, l) T_COMMA discr_range (^t1) =
		{ s_next ($l, $t1);
		  $l = $t1;
		} ;

discr_range (^t): range (^t) |
		simple_expr (^t) =
		{ $t = get_name_from_expr ($t);
		  $t = IS_SCALAR ($t, g_tag (base_type ($t)),
			"Cannot handle non-scalar type %s in discrete range");
	          $t = mk_range ($t, NULL, NULL);
		} |
		c_typename (^t1) range_constraint (^t2) =
		{ s_rangetype ($t2, $t1);
		  $t1 = IS_SCALAR ($t1, g_tag ($t1),
			"Cannot handle non-scalar type %s in discrete range");
		  $t = $t2;
		} ;

implied_array (^t, f):
		T_ARRAY T_LP index_constraints (^t0, l) T_RP T_OF subtype_ind (^t1) =
		{ ac uncons, subt;
		  ac t;
		  $t1 = CONST_TYPE ($t1, NULL,
		             "Array element type insufficiently constrained");
		  uncons = conv_array (NULL, $t1);
		  if (has_eq_and_ass ($t1))
		     s_flags (uncons, g_flags (uncons) | HAS_ASSIGN);
		  INTRODUCE (uncons);
		  t = bu_filter (mk_filter (uncons, $t0));
		  set_indices (uncons, $t0);
		  subt = TD_FILTER (t, "Error in implied array", NULL);
		  t = mk_subtype (mk_tag (gen_tag (), IDL), subt);
		  INTRODUCE (t);
		  $t = uncons;
		  $f = t;
		} ;

subtype (^z):	T_SUBTYPE T_IDENT T_IS filter_ind (^t)  =
		{ if ($t == notype) {
		     error ("Subtype %s declared as integer", $2);
		     $t = std_integer;
		  }
		  $z = mk_subtype ($2, $t);
		  if (is_sttype ($t))
		     set_sttype ($z);
		  PREDECL ($z);
		} ;

filter_ind (^t):
		c_typename (^t)
		|
		c_typename (^t) constraint (|t, ^t1) =
		{ $t = SOLVE_FILTER (mk_filter ($t, $t1), $t, NULL,
					    "type error in subtype constraint");
		} ;

subtype_ind (^t):
		filter_ind (^t) =
		{ ac p, q;
		  if (g_d ($t) == XFILTER) {
		     p = mk_subtype (mk_tag (gen_tag (), IDL), $t);
		     if (is_sttype ($t))
		        set_sttype (p);
		     INTRODUCE (p);
		     $t = p;
		  }
		} ;

filtype (^t):	type_name (^t);

type_name (^t):	ls_name (^t) =
		{ $t = type_name (td_n_name (bu_name ($t)));
		} ;

c_typename (^t):	type_name (^t) =
		{ if ($t == NULL)
		     $t = any_type;
		  else
		     $t = c_typename ($t);
		} ;

t_mark (^t):	type_name (^t) =
		{ if ($t == NULL)
		     $t = any_type;
		  else
		     $t = c_typename ($t);
		} ;

constraint (|ct, ^t):
		range_constraint (^t) =
		{ if (!is_scalar ($ct)) {
		     error ("Cannot take range constraint on non scalar");
		  }
		} |
		other_constraint (^t);

/*
 *	record fields again
 */
field_list (|x, y, z, b):
		comp_seq (|x, y, z, b) var_part (|x, y, z, b) |
		comp_seq (|x, y, z, b) |
		var_part (|x, y, z, b) |
		T_NULL T_SEM_COL ;

comp_seq (|x, y, z, b):
		comp (|x, y, z, b) T_SEM_COL |
		comp_seq (|x, y, z, b) comp (|x, y, z, b) T_SEM_COL ;

comp (|x, y, z, b):
		comp_list (^t, d) =
		{ LIST_INTRO ($t, "error in record component %s");
		  off_intro ($t);
		  if (!has_eq_and_ass ($t))
		     no_eq_and_ass_in ($x);
		};

comp_list (^t, d):
		T_IDENT T_COLON subtype_ind (^t1) opt_expr (^t2) =
		{ ac t = NULL;
		  $t2 = SOLVE_EXPR ($t2, $t1, "error in default expression");
		  if ($t2 != NULL)
		     t = mk_thunk ($t2);
		  $t1 = CONST_TYPE ($t1, "type in %s not constrained", $1);
		  $d = mk_desc ($t1, KCOMP, t);
		  $t = mk_object ($1, $d);
		} |
		T_IDENT T_COMMA comp_list (^t, d) =
		{ ac t = mk_object ($1, cp_tree ($d));
		  s_next (t, $t);
		  $t = t;
		};

/*
 *	Just a reminder:
 *			x is enclosing variant/record
 *			y is current variant
 *			d is used for environment management
 *			o is an inherited flag
 */
var_part (|x, y, d, o):
		selection (|y, d, o, ^y1, d1, d2, o2)
					alternatives (|y1, d1, d2, o2)
				T_END T_CASE T_SEM_COL ;

selection (|y, d, o, ^y1, d1, d2, o2):
		T_CASE T_IDENT T_IS =
		{ ac xx;
		  if ((xx = res_param ($y, $2)) == NULL)
		     error ("%s case selector, no discriminant", $2);
		  s_dis ($y, mk_rsel (xx));
		  $y1 = $y;	/* just a copy */
		  $o2 = FALSE;	/* local others flag	*/
		} ;

alternatives (|y, d1, d2, o):
		variant (|y, d1, d2, o) =
		{ s_fvariant ($y, $d1);
		} |
		alternatives (|y, d1, d2, o) variant (|y, d1, d2, o);

variant (|y, d1, d2, o):
		selector (|y, d1, d2, o) T_ARROW field_list (|y, d1, d2, o) =
		{  if (g_dis ($d1) != NULL) {
		      ac dt = type_of (g_comp (g_dis ($d1)));
		      CHECK_VARIANT ($d1, dt,
		                           "illegal ranges in variant %s", 
                                           encl_rectype ($y) );
		  }
		  restore_env ($d1, $d2);
		} ;

selector (|y, d1, d2, o):
		T_WHEN choices (^t, o2) =
		{ $d1 = mk_varnode ();
		  INTRODUCE ($d1);
		  if ($o)
		     warning ("too much alternatives %s", g_tag ($y));
		  $o = $o2;
		  s_varchoice ($d1, $t);
		  $d2 = NEWSCOPE ($d1);
		} ;

choices (^c, o):	T_OTHERS =
		{ $c = mk_range (NULL, NULL, NULL);
		  $o = TRUE;
		} |
		choice_list (^c, l) =
		{ $o = FALSE;
		} ;

choice_list (^f, l):	choice (^f) =
		{ $l = $f;
		} |
		choice_list (^f, l) T_BAR choice (^f2) =
		{ s_next ($l, $f2);
		  $l = $f2;
		} ;

choice (^t):	c_typename (^t1) range_constraint (^t2) =
		{ s_rangetype ($t2, $t1);
		  bu_expr ($t2);
		  $t = $t2;
		} |
		simple_expr (^t) =
		{ $t = bu_expr (mk_range (NULL, $t, NULL));
		} |
		range (^t) =
		{ $t = bu_expr ($t);
		};

range_constraint (^t):
		T_RANGE range (^t) ;

other_constraint (^t):
		T_LP c_fieldlist (^t, l) T_RP ;

c_fieldlist (^f, l):	c_field (^f) =
		{ $l = $f;
		} |
		c_fieldlist (^f, l) T_COMMA c_field (^f2) =
		{ s_next ($l, $f2);
		  $l = $f2;
		} ;

c_field (^t):	ls_name (^t) =
		{ $t = mk_component (NULL, $t);
		} |
		c_typename (^t1) range_constraint (^t2) =
		{ s_rangetype ($t2, $t1);
		  $t = mk_component (NULL, $t2);
		} |
		range (^t) =
		{ $t = mk_component (NULL, $t);
		} |
		expr (^t1) =
		{ $t = mk_component (NULL, $t1);
		} |
		disc_assoc (^t, k);

disc_assoc (^t, k):
		s_choices (^t, k) T_ARROW expr (^t1) =
		{ $t = mk_component ($t, $t1);
		} ;

s_choices (^t, k):
		T_OTHERS =
		{ $k = COMP_OTHERS;
		  $t = mk_range (NULL, NULL, NULL);
		} |
		s_choicelist (^t, l) =
		{ $k = COMP_ASSOC;
		} ;

s_choicelist (^t, l):
		T_IDENT =
		{ $t = mk_range (NULL,
		          mk_expr (NULL, mk_applied (mk_unresrec ($1))), NULL);
		  $l = $t;
		} |
		s_choicelist (^t, l) T_BAR T_IDENT =
		{ ac t = mk_range (NULL,
		            mk_expr (NULL, mk_applied (mk_unresrec ($3))), NULL);
		  s_next ($l, t);
		  $l = t;
		};

range (^t):	simple_expr (^t) T_DD simple_expr (^t1) =
		{ $t = mk_range (NULL, $t, $t1);
		} |
		x_name (^t) T_QUOTE T_RANGE =
		{ ac t = mk_attr (A_RANGE, NULL);
		  s_next (t, $t);
		  $t = mk_range (NULL, mk_expr (NULL, t), NULL);
		};

subspec (^t):	function_spec (^t) |
		procedure_spec (^t);

function_spec (^t): func_name (^t, ct, cnt) function_pars (|t, ct, cnt)
		        T_RETURN type_name (^t2) =
		{  s_rettype ($t, $t2);
		   DELSCOPE ($t, $ct);
		};
procedure_spec (^t):
		proc_name (^t, ct, cnt) procedure_pars (|t, ct, cnt) =
		{ s_rettype ($t, notype);
		  DELSCOPE ($t, $ct);
		};

func_name (^t, ct, cnt):	T_FUNCTION T_IDENT =
		{ $t = mk_sub ($2, FALSE);
		  $ct  = NEWSCOPE ($t);
		  $cnt = 0;
		} |
		T_FUNCTION T_CHAR_STRING =
		{ $t = mk_sub (string_to_tag ($2), TRUE);
		  $ct = NEWSCOPE ($t);
		  $cnt= 0;
		};

proc_name (^t, ct, cnt):	T_PROCEDURE T_IDENT =
		{ $t = mk_sub ($2, FALSE);
		  $ct  = NEWSCOPE ($t);
		  $cnt = 0;
		} ;

function_pars (|t, ct, cnt):	|
		T_LP func_pars (|t, ct, cnt) T_RP =
		{ if (is_std_fn ($t)) {
		     ch_funpars ($t, $cnt);
		  }
		  off_intro (g_fformal ($t));
		};

procedure_pars (|t, ct, cnt):	|
		T_LP proc_pars (|t, ct, cnt) T_RP =
		{ off_intro (g_fformal ($t));
		} ;

func_pars (|p, ct, cnt):
		func_par (^tt, c, d) =
		{ $cnt = $c;
		  LIST_INTRO ($tt, "parameter %s not unique");
		} |
		func_pars (|p, ct, cnt) T_SEM_COL func_par (^tt, c, d) =
		{ $cnt = $cnt + $c;
		  LIST_INTRO ($tt, "parameter %s not unique");
		} ;

proc_pars (|p, ct, cnt):
		proc_par (^tt, c, d) =
		{ $cnt = $c;
		  LIST_INTRO ($tt, "parameter %s not unique");
		} |
		proc_pars (|p, ct, cnt) T_SEM_COL proc_par (^tt, c, d) =
		{ $cnt = $cnt + $c;
		  LIST_INTRO ($tt, "parameter %s not unique");
		} ;

proc_par (^t, c, d):	T_IDENT T_COLON inout_spec (^t1) =
		{ $t = mk_object ($1, $t1);
		  $c = 1;
		  $d = $t1;
		} |
		T_IDENT T_COMMA proc_par (^t, c, d) =
		{ ac t = mk_object ($1, cp_tree ($d));
		  s_next (t, $t);
		  $c += 1;
		  $t = t;
		};

func_par (^t, c, d):	T_IDENT T_COLON in_spec (^t1) =
		{ ac t = mk_object ($1, $t1);
		  $c = 1;
		  $d = $t1;
		  $t = t;
		} |
		T_IDENT T_COMMA func_par (^t, c, d) =
		{ ac t = mk_object ($1, cp_tree ($d));
		  $c += 1;
		  s_next (t, $t);
		  $t = t;
		};

in_spec (^t):	c_typename (^t1) opt_expr (^t2) =
		{ $t2 = SOLVE_EXPR ($t2, $t1, "type error in default");
		  $t = mk_desc ($t1, INMODE, $t2);
		} |
		T_IN c_typename (^t1) opt_expr (^t2) =
		{ $t2 = SOLVE_EXPR ($t2, $t1, "type error in default");
		  $t = mk_desc ($t1, INMODE, $t2);
		};

inout_spec (^t):	in_spec (^t) |
		T_OUT c_typename (^t1) =
		{ $t = mk_desc ($t1, OUTMODE, NULL);
		} |
		T_IN T_OUT c_typename (^t1) =
		{ $t = mk_desc ($t1, INOUTMODE, NULL);
		} ;

renamer:	renobject |
		ren_sub |
		ren_pack ;

renobject:	T_IDENT T_COLON c_typename (^t) T_RENAMES name (^t1) =
		{ ac t;
		  $t = CONST_TYPE ($t, "Unconstrained type %s", $1);
		  t = mk_renobj ($1, $t);
		  s_name (t, c_object (td_name (bu_name ($t1), $t)));
		  OBJDECL (t, "%s (renaming declaration) not unique");
		} ;

ren_sub:	subspec (^t) T_RENAMES expr (^t1) =
		{ ac t = mk_rensub ($t);
		  ac t2 = FIND_RENAMEDSUBS (t, g_primary (bu_expr ($t1)),
		                 "Error in renamed sub %s\n");
		  if (t2 != NULL)
		  {  chk_6_7_5 (t, t2);
		     s_subname (t, t2);
		     INTRODUCE (t);
		  }
		} ;

ren_pack:	T_PACKAGE T_IDENT T_RENAMES ls_name (^t) =
		{ ac t;
		  t = pack_name (td_n_name (bu_name ($t)));
		  if (t != NULL) {
		     t = mk_renpack ($2, t);
		     OBJDECL (t, "%s declared twice");
		     off_intro (t);
		  }
		} ;

aggr_start (^t, l, k):
		T_LP comp_assoc (^t, k1) =
		{ $l = $t;
		  $t = mk_aggnode ($t, any_aggregate);
		  $k = $k1;
		} |
		T_LP expr (^t1) T_COMMA e_or_comp (^t2, k2) =
		{ ac t = mk_component (NULL, $t1);
		  s_next (t, $t2);
		  $t = mk_aggnode (t, any_aggregate);
		  $l = $t2;
		  $k = $k2;
		} |
		aggr_start (^t, l, k)
			T_COMMA e_or_comp (^t2, k2) =
		{ component_ordering ($k, $k2, "illegal ordering in aggregate comp's\n");
		  s_next ($l, $t2);
		  $l = $t2;
		  $k = $k2;
		} ;

e_or_comp (^t, k):
		expr (^t) =
		{ $t = mk_component (NULL, $t);
		  $k = COMP_EXPR;
		} |
		comp_assoc (^t, k) ;

comp_assoc (^t, k):
		leftlist (^t1, k1) T_ARROW expr (^t2) =
		{ $t = mk_component ($t1, $t2);
		  $k = $k1 ? COMP_OTHERS : COMP_ASSOC;
		} ;

leftlist (^t, o):
		T_OTHERS =
		{ $t = mk_range (NULL, NULL, NULL);
		  $o = TRUE;
		} |
		leftsides (^t, l) =
		{ $o = FALSE;
		} ;

leftsides (^t, l):
		leftside (^t) =
		{ $l = $t;
		} |
		leftsides (^t, l) T_BAR leftside (^t1) =
		{ s_next ($l, $t1);
		  $l = $t1;
		} ;

leftside (^t):	t_mark (^t1) range_constraint (^t2) =
		{ s_rangetype ($t2, $t1);
		  $t = $t2;
		} |
		T_IDENT =
		{ ac p;
		  $t = mk_range (NULL, mk_expr (NULL,
				        mk_applied (mk_unresrec ($1))), NULL);
		} |
		simple_expr (^t) =
		{ $t = mk_range (NULL, $t, NULL);
		} |
		range (^t);

opt_expr (^t):	=
		{ $t = NULL;
		} |
		as_expr (^t);

as_expr (^t):
		T_AS expr (^t) =
		{ $t = bu_expr ($t);
		} ;

aggregate (^t):
		aggr_start (^t, l, k) T_RP;

expr (^t):	expression (^t, o);

expression (^t, o) :
		relation (^t) =
		{ $o = NULL;
		} |
		expression (^t, o) logop (^t2, lo) relation (^t1) =
		{ if ($o == NULL || $o == $lo) {
		     $o = $lo;
		     if (is_and_then ($o))
		        $t = mk_andthen ($t, $t1, $o);
		     else
		        $t = call_std_function ($t2, $t, $t1);
		  }
		  else
		     error ("illegal operator sequence");
		} ;

relation (^t):	simple_expr (^t)  |
		simple_expr (^t) T_RELOP simple_expr (^t1) =
		{ ac t;
		  if (is_NOT_EQ ($2)) {
		     t = call_std_function (mk_tag ("=", 2), $t, $t1);
		     $t = call_std_function (mk_tag ("NOT", 4), t, NULL);
		  }
		  else
		     $t = call_std_function ($2, $t, $t1);
		} |
		simple_expr (^t1) in_not (^n) discr_range (^t2) =
		{ ac t;
		  if ($t1 != NULL && $t2 != NULL) {
		     $t = mk_expr (NULL, mk_in ($t1,  mk_filter (NULL, $t2), $n));
		  }
		  else
		     $t = NULL;
		} ;

logop (^t, op):	T_AND =
		{ $op = T_AND;
		  $t = mk_tag ("AND", 4);
		} |
		T_OR =
		{ $op = T_OR;
		  $t = mk_tag ("OR", 3);
		} |
		T_XOR =
		{ $op = T_XOR;
		  $t = mk_tag ("XOR", 4);
		} |
		T_AND T_THEN =
		{ $op = S_AND_THEN;
		  $t = NULL;
		} |
		T_OR T_ELSE =
		{ $op = S_OR_ELSE;
		  $t = NULL;
		} ;

in_not (^not):	T_IN =
		{ $not = FALSE;
		} |
		T_NOT T_IN =
		{ $not = TRUE;
		} ;

simple_expr (^t):	term (^t) |
		unop (^t1) term (^t2) =
		{ $t = call_std_function ($t1, $t2, NULL);
		} |
		simple_expr (^t) add_op (^t1) term (^t2) =
		{ $t = call_std_function ($t1, $t, $t2);
		} ;

term (^t):	factor (^t) |
		term (^t) mulop (^op) factor (^t2) =
		{ $t = call_std_function ($op, $t, $t2);
		} ;

unop (^op):	T_PLUS =
		{ $op = $1;
		} |
		T_MINUS =
		{ $op = $1;
		} |
		T_NOT =
		{ $op = mk_tag ("NOT", 4);
		} |
		T_ABS =
		{ $op = mk_tag ("ABS", 4);
		} ;

add_op (^op):	T_PLUS =
		{ $op = $1;
		} |
		T_MINUS =
		{ $op = $1;
		} |
		T_AMP =
		{ $op = $1;
		} ;

mulop (^op):	T_MULT =
		{ $op = $1;
		} |
		T_DIV =
		{ $op = $1;
		} |
		T_MOD =
		{ $op = mk_tag ("MOD", 4);
		} |
		T_REM =
		{ $op = mk_tag ("REM", 4);
		} ;

factor (^e):	primary (^e) |
		primary (^e) T_EXP primary (^e2) =
		{ $e = call_std_function ($2, $e, $e2);
		} ;

primary (^t):	litteral (^t) =
		{ $t = mk_expr (NULL, $t);
		} |
		T_CHAR_LIT =
		{ $t = mk_expr (NULL, mk_applied (mk_unchar ($1)));
		} |
		name (^t) =
		{ $t = mk_expr (NULL, $t);
		} |
		allocator (^t) =
		{ $t = mk_expr (any_access_type, $t);
		} |
		qual_expr (^t) |
		T_LP expression (^t, o) T_RP =
		{ $t = mk_expr (NULL, mk_parexpr ($t));
		} |
		aggregate (^t) =
		{ $t = mk_expr (NULL, $t);
		};

litteral (^t):	T_INT_LIT =
		{ $t = mk_literal ($1, std_univ);
		} |
		T_REAL_LIT =
		{ $t = mk_literal ($1, std_real);
		} |
		T_NULL =
		{ $t = mk_literal (alloc_lit (S_NULLLIT, "", 1), any_access_type);
		} |
		T_CHAR_STRING =
		{ $t = mk_literal ($1, any_string_type);
		} ;

allocator (^t):	T_NEW c_typename (^t1) other_constraint (^t2) =
		{ $t = mk_alloc (mk_filter ($t1, $t2), any_access_type);
		} |
		T_NEW c_typename (^t1) =
		{ $t = mk_alloc ($t1, any_access_type);
		} |
/*
 *	The notion c_typename below differs from the - probably
 *	expected - notion type_mark, due to syntacal problems with
 *	typemark here
 */
		T_NEW c_typename (^t1) T_QUOTE aggr_start (^t2, l, k) =
		{ s_aggtype ($t2, $t1);
		  $t = mk_alloc (mk_expr (NULL, $t2), any_access_type);
		} |
		T_NEW c_typename (^t1) T_QUOTE T_LP expr (^t2) T_RP =
		{ s_exptype ($t2, $t1);
		  $t = mk_alloc ($t2, any_access_type);
		} ;

qual_expr (^t):	type_mark (^t1) T_LP expr (^t2) T_RP =
		{ s_exptype ($t2, $t1);
		  $t = $t2;
		} |
		type_mark (^t1) aggr_start (^t2, l, k) T_RP =
		{ s_aggtype ($t2, $t1);
		  $t = mk_expr (NULL, $t2);
		} ;

type_mark (^t):	
		x_name (^t) T_QUOTE =
		{ $t = c_typename (type_name (td_n_name (bu_name ($t))));
		} ;

sel_comp (^t, k):
		id_opsym (^t) =
		{ $k = ID_OPSYM;
		} |
		T_CHAR_LIT =
		{ $k = CH_LIT;
		  $t = mk_chartag ($1);
		} ;

id_opsym (^t):	T_IDENT =
		{ $t = $1;
		} |
		T_CHAR_STRING =
		{ $t = string_to_tag ($1);
	          if (!std_oper ($t))
		     warning ("illegal standard operator %s", $t);
		} ;

s_name (^t):	T_IDENT =
		{ $t = mk_applied (mk_unresrec ($1));
		} ;

l_name (^t):
		s_name (^t) T_DOT sel_comp (^t1, k) =
		{ $t = mk_select ($t, $t1, $k);
		} |
		l_name (^t) T_DOT sel_comp (^t1, k) =
		{ $t = mk_select ($t, $t1, $k);
		} ;

simple_name (^t):	ls_name (^t) =
		{ $t = simple_name (td_n_name (bu_name ($t)));
		};

ls_name (^t):	s_name (^t) |
		l_name (^t) ;

name (^t):
		x_name (^t) |
		x_name (^t) T_QUOTE attribute (^t1) =
		{ if (g_attr_value ($t1) == A_BASE) {
		     error ("illegal use of base atribute, ignored");
		  }
		  else
		  { s_next ($t1, $t);
		    $t = $t1;
		  }
		} ;

x_name (^t):	ls_name (^t) |
		x_name (^t) T_DOT id_opsym (^t1) =
		{ $t = mk_select ($t, $t1, ID_OPSYM);
		} |
		s_name (^t) T_DOT T_ALL =
		{ $t = mk_all ($t);
		} |
		l_name (^t) T_DOT T_ALL =
		{ $t = mk_all ($t);
		} |
		x_name (^t) T_DOT T_ALL =
		{ $t = mk_all ($t);
		} |
		x_name (^t) T_QUOTE attribute (^t1) =
		{ if (g_attr_value ($t1) != A_BASE) {
		     error ("illegal attributing, only base attrib here");
		     s_attr_value ($t1, A_BASE);
		  }
		  s_next ($t1, $t);
		  $t = $t1;
		} |
		x_name (^t) T_LP indices (^f, k, l) T_RP =
		{ if ($k == XCALL)
		     $t = mk_call ($t, $f);
		  else if ($k == XSLICE)
		     $t = mk_slice ($t, $f);
		  else
		     $t = mk_arrselect ($t, $f);	/* name botch with index	*/
		} ;

attribute (^t):	T_IDENT =
		{ int t = srch_attr ($1);
		  if (t >= 0)
		     $t = mk_attr (t, NULL);
		  else
		     { error ("illegal attribute %s\n", $1);
		       $t = mk_attr (A_BASE, NULL);
		     }
		} |
		T_IDENT T_LP expr (^t1) T_RP =
		{ int t = srch_attr ($1);
		  if (t >= 0)
		     $t = mk_attr (t, $t1);
		  else
		     { error ("illegal attribute %s\n", $1);
		       $t = mk_attr (A_BASE, NULL);
		     }
		} ;

indices (^f, k, l):
		unit (^t, k) =
		{ $f = $t;
		  $l = $t;
		} |
		indices (^f, k, l) T_COMMA unit (^t1, k1) =
		{ $k = acceptable ($k, $k1, "error in parameter/index list");
		  s_next ($l, $t1);
		  $l = $t1;
		};

unit (^t, k):
		t_mark (^t1) range_constraint (^t2) =
		{ $k = XSLICE;
		  $t = $t2;
		  s_rangetype ($t, $t1);
		} |
		range (^t) =
		{ $k = XSLICE;
		} |
		expr (^t) =
		{ $k = XINDEXING;
		} |
		param_assoc (^t) =
		{ $k = XCALL;
		} ;

param_assoc (^t):
		T_IDENT T_ARROW expr (^t) =
		{ $t = mk_namass ($1, $t);
		} ;

opt_except (^t):	=
		{ $t = NULL;
		} |
		except_part (^t, l, o) =
		{ ac xx = nalloc (XEXHANDLER);
		  s_EXH_items (xx, $t);
		  $t = xx;
		};

except_part (^t, l, o):
		ex_h_start (^t, l, o) ex_handler (|t, l, o, ^t1) =
		{ $l = $t1;
		  $t = $t1;
		} |
                except_part (^t, l, o) ex_handler (|t, l, o, ^t2) =
		{ s_next ($l, $t2);
		  $l = $t2;
		} ;

ex_h_start (^h, t, o):
		T_EXCEPTION =
		{ $o = FALSE;
		  $h = NULL;
		  $t = NULL;
		  intro_ex_h ();
		} ;

ex_handler (|t, l, o, ^t):
		ex_when (|t, l, o, ^t) statements (^x, y) =
		{ s_WI_stats ($t, $x);
		} ;

ex_when (|t, l1, o, ^t):	T_WHEN ex_choices (|t, l1, o, ^l, o2) T_ARROW =
		{ if ($o)
		     warning ("alternative following OTHERS");
		  $o = $o2;
		  $t = mk_whenitem ($l);
		} ;

ex_choices (|t1, l1, o1, ^t, o):
		T_OTHERS =
		{ $t = mk_range (NULL, NULL, NULL);
		  $o = TRUE;
		} |
		ex_choice_list (|t1, l1, o1, ^t, l) =
		{ $o = FALSE;
		} ;

ex_choice_list (|t, l1, o, ^f, l):
		ex_name (^f) =
		{ chk_exceptions ($t, NULL, $f);
		  $l = $f;
		} |
		ex_choice_list (|t, l1, o, ^f, l ) T_BAR ex_name (^t2) =
		{ chk_exceptions ($t, $f, $t2);
		  s_next ($l, $t2);
		  $l = $t2;
		} ;

ex_name (^t):	ls_name (^t) =
		{ $t = get_exc (td_n_name (bu_name ($t)));
		  if ($t != NULL) {
	             $t = mk_range (NULL, mk_expr (NULL, mk_applied ($t)), NULL);
		  }
		  else
		     $t = mk_range (NULL, NULL, NULL);	/* Other */
		} ;

statements (^f, l):
		stat (^f) =
		{ $l = $f;
		} |
		statements (^f, l) stat (^t) =
		{
		   if ($l == NULL) {
		     $f = $t;
		     $l = $t;
		  }
		  else
		  if ($t != NULL) {
		     s_next ($l, $t);
		     $l = $t;
		  }
		} ;

stat (^t):	lab_stat =
		{ $t = NULL;
		} |
		statement (^t) T_SEM_COL ;

statement (^t):	basic_stat (^t) |
		compound (^t) ;

compound (^t):	if_stat (^t) |
		case_stat (^t) |
		select_stat (^t) |
		sa_accept (^t) |
		tagged_stat (^t) ;

lab_stat:	T_LS T_IDENT T_LF ;

if_stat (^t):	if_begin (^t, l) T_END T_IF |
		if_begin (^t, l) else_part (^t1) T_END T_IF =
		{ s_next ($l, $t1);
		} ;

if_begin (^t, l):	if_part (^t) =
		{ $l = g_IF_items ($t);
		} |
		if_begin (^t, l) elsif_part (^t2) =
		{ s_next ($l, $t2);
		  $l = $t2;
		} ;

if_part (^t):	if (^t) T_THEN statements (^x, y) =
		{ s_IF_stats (g_IF_items ($t), $x);
		} ;

if (^t):	T_IF expr (^t) =
		{ $t = SOLVE_EXPR (bu_expr ($t), std_boolean,
		                             "illegal if expression");
		  $t = mk_if (mk_ifitem ($t));
		} ;

elsif_part (^t):	elsif (^t) T_THEN statements (^x, y) =
		{ s_IF_stats ($t, $x);
		} ;

elsif (^t):	T_ELSIF expr (^t) =
		{ $t = SOLVE_EXPR (bu_expr ($t), std_boolean,
			                        "illegal if expression");
		  $t = mk_ifitem ($t);
		} ;

else_part (^t):	else_beg (^t) statements (^x, y) =
		{ s_IF_stats ($t, $x);
		} ;

else_beg (^t):	T_ELSE =
		{ $t = mk_ifitem (NULL);
		} ;

case_stat (^x):	case_list (^x, l, o, ls, et) T_END T_CASE =
		{ if (!verif_domain (stat_range ($et), $ls, $o))
		        error ("domain error in case statement");
		  rem_list ($ls);
		} ;

case_list (^t, l, o, ls, et):
		case (^t, l, o, ls, et) case_choice (|o, ls, et, ^r) =
		{ s_CASE_items ($t, $r);
		  $l = $r;
		} |
		case_list (^t, l, o, ls, et) case_choice (|o, ls, et, ^r) =
		{ s_next ($l, $r);
		  $l = $r;
		} ;

case_choice (|o, ls, et, ^r):
		C_part (|o, ls, et, ^r) statements (^x, y) =
		{ s_WI_stats ($r, $x);
		} ;

C_part (|o, ls, et, ^r):
		T_WHEN C_choices (|o, ls, et, ^o2, r2) T_ARROW =
		{ if ($o)
		     error ("alternative following OTHERS");
		  $o = $o2;
		  $r = mk_whenitem ($r2);
		} ;

case (^t, l, o, ls, et):
		T_CASE expr (^t1) T_IS =
		{ $t1 = bu_expr ($t1);
		  $t1 = SOLVE_EXPR ($t1, types_of ($t1),
				"illegal type in choice");
		  if ($t1 == NULL) {
		     $et = std_univ;
		  }
		  else
		  {  s_exptype ($t1, IS_SCALAR (g_exptype ($t1), NULL,
			               "non scalar type in choice"));
		     $et = g_exptype ($t1);
		  }
		  $t = mk_case ($t1);
		  $o = FALSE;
		  $ls = new_list ();
		  $l = NULL;
		} ;

C_choices (|o, ls, et, ^o2, r):
		T_OTHERS =
		{ $r = mk_range (NULL, NULL, NULL);
		  $o2 = TRUE;
		} |
		C_choice_list (|o, ls, et, ^f, l) =
		{ $o2 = FALSE;
		  $r = $f;
		} ;

C_choice_list (|o, ls, et, ^f, l):
		choice (^t) =
		{ if (!$o) {
		     $t = static_range ($et, $t);
		     if ($t != NULL)
		        l_insert ($t, $ls);
		  }
		  $f = $t;
		  $l = $t;
		} |
		C_choice_list (|o, ls, et, ^f, l) T_BAR choice (^t) =
		{ if (!$o) {
		     $t = static_range ($et, $t);
		     if ($t != NULL)
		        l_insert ($t, $ls);
		  }
		  if ($l == NULL) {
		     $f = $l = $t;
		  }
		  else
		  if ($t != NULL) {
		     s_next ($l, $t);
		     $l = $t;
		  }
		} ;

select_stat (^t):
		select_list (^t, td, ls, cnt) T_END T_SELECT =
		{ s_SEL_count ($t, $cnt);
		} |
		select_list (^t, td, ls, cnt) T_ELSE statements (^x, y) T_END T_SELECT =
		{ ac t1 = mk_whenitem (NULL);
		  s_WI_stats (t1, mak_delay (NULL));
		  s_next (g_WI_stats (t1), $x);
		  if ($td != 0) {
		     error ("illegal ELSE alternative in selective wait");
		  }
		  s_next ($ls, t1);
		  $ls = t1;
		  s_SEL_count ($t, $cnt + 1);
		};


select_list (^t, td, ls, cnt):
		select (^t, td, ls, cnt) select_choice (|td, ls, cnt, ^r) =
		{ s_SELECT_items ($t, $r);
		  $ls = $r;
		  $cnt = 1;
		} |
		select_list (^t, td, ls, cnt) T_OR select_choice (|td, ls, cnt, ^r) =
		{ s_next ($ls, $r);
		  $ls = $r;
		  $cnt ++;
		} ;

select (^t, td, ls, cnt):	T_SELECT =
		{ $t = mk_tselect ();
		  $td = 0;
		  $cnt = 0;
		  $ls   = NULL;
		} ;

select_choice (|td, ls, cnt, ^r):
		opt_guard (^t) accept_stat (^t1) T_SEM_COL opt_stats (^t2) =
		{ $r = mk_whenitem ($t);
		  s_next ($t1, $t2);
		  s_WI_stats ($r, $t1);
		} |
		opt_guard (^t1) T_TERMINATE T_SEM_COL =
		{ if ($td != 0) {
		     error ("illegal alternative in selective wait");
		  }
		  $r = mk_whenitem ($t1);
		  s_WI_stats ($r, nalloc (XTERMINATE));
		  $td = XTERMINATE;
		} |
		opt_guard (^t1) delay_stat (^t2) T_SEM_COL opt_stats (^x) =
		{ if ($td != 0) {
		     error ("illegal alternative in selective wait");
		  }
		  $r = mk_whenitem ($t1);
		  s_next ($t2, $x);
		  s_WI_stats ($r, $t2);
		  $td = XDELAY;
		} ;

opt_guard (^x):	=
		{ $x = NULL;
		} |
		T_WHEN expr (^x) T_ARROW =
		{ $x = SOLVE_EXPR (bu_expr ($x), std_boolean,
					"illegal type guard");
		};

delay_stat (^t):
		T_DELAY simple_expr (^x) =
		{ $x = SOLVE_EXPR (bu_expr ($x), std_long,
				                 "illegal delay expression");
		  $t = mak_delay ($x);
		};

abort_stat (^t):
		abort_l (^t, l) ;

abort_l (^h, t):
		T_ABORT name (^x) =
		{ $h = mk_abort (chk_task (td_n_name (bu_name ($x))));
		  $t = $h;
		} |
		abort_l (^h, t) T_COMMA name (^x) =
		{ ac t = mk_abort (chk_task (td_n_name (bu_name ($x))));
		  s_next ($t, t);
		  $t = t;
		};

sa_accept (^x):
		accept_stat (^y) =
		{ ac t, t1;
		  int line;
		  /* turn it into select accept ... else null; end select	*/
		  if ($y != NULL)
		     line = g_lineno ($y);
		  else
		     line = -1;
		  t = mk_whenitem (NULL);
		  s_lineno (t, line);
		  s_WI_stats (t, mak_inf_delay (NULL));
		  t1 = mk_whenitem (NULL);
		  s_lineno (t1, line);
		  s_WI_stats (t1, $y);
		  s_next (t1, t);
		  $x = mk_tselect ();
		  s_lineno ($x, line);
		  s_SELECT_items ($x, t1);
		  s_SEL_count ($x, 2);
		};

accept_stat (^x):
		accept_s (^x, ct) T_DO statements (^f, l) T_END opt_id =
		{ s_accept_stats ($x, $f);
		  DELSCOPE ($x, $ct);
		  CHECK_OPTIDENT (g_tag (g_specif ($x)), $5,
	                                          "Mismatching ident %s\n");
		}|
		accept_s (^x, ct) =
		{ DELSCOPE ($x, $ct);
		};

accept_s (^t, ct):
		accept_start (^t, ct, cnt) procedure_pars (|t, ct, cnt) =
		{ ac t;
		  DELSCOPE ($t, $ct);
		  t = FIND_ENTRY ($t, env, "Cannot find entry for %s\n");
		  t = mk_accept (t);
		  $ct = NEWSCOPE (t);
		  $t = t;
		} ;

accept_start (^t, ct, cnt):
		T_ACCEPT T_IDENT =
		{ $t = mk_entry ($2);
		  $ct = NEWSCOPE ($t);
		  $cnt = 0;
		  s_rettype ($t, notype);
		} ;

opt_stats (^x):	=
		{ $x = NULL;
		} |
		statements (^x, y);

tagged_stat (^x):
		opt_collid (^t1) lplblk (|t1, ^t) opt_id =
		{ CHECK_OPTIDENT ($t1, $3, "mismatching ident %s");
		  del_optid ($3);
		  $x = $t;
		} ;

opt_collid (^t):
		=
		{ $t = (char *)NULL;
		} |
		T_IDENT T_COLON =
		{ $t = $1;
		} ;

opt_id:		=
		{ $$ = NULL;
		} |
		T_IDENT |
		T_CHAR_STRING =
		{ $$ = string_to_tag ($1);
		} ;

lplblk (|t, ^t1):
		loop_stat (|t, ^t1, e) =
		{ DELSCOPE ($t1, $e);
		} |
		block (|t, ^t1, e) =
		{ DELSCOPE ($t1, $e);
		  DECL_CHECK (FALSE, $t1, "decls in block %s");
		} ;

block (|t, ^t1, e):
		block_start (|t, ^t1, e) statements (^x, y)
					       opt_except (^z) T_END =
		{ s_BLK_stats ($t1, $x);
		  s_BLK_exh ($t1, $z);
		} ;

block_start (|t, ^t1, e):
		T_BEGIN =
		{ $t1 = mk_block ($t, env);
		  if ($t != NULL)
		     decl_tagstat ($t1);
		  $e = NEWSCOPE ($t1);
		} |
		declare (|t, ^t1, e) decl_part T_BEGIN ;

declare (|t, ^t1, e):
		T_DECLARE =
		{ $t1 = mk_block ($t, env);
		  if ($t != NULL)
		     decl_tagstat ($t1);
		  $e = NEWSCOPE ($t1);
		} ;

loop_stat (|t, ^t1, e):
		loop_begin (|t, ^t1, e) statements (^x, y) T_END T_LOOP =
		{ if (g_d ($t1) == XLOOPBLOCK)
		     s_LPB_stats ($t1, $x);
		  else
		     s_FB_stats ($t1, $x);
		} ;

loop_begin (|t, ^t1, e):
		loop_start (|t, ^t1, e) T_LOOP;

loop_start (|t, ^t1, e):
		=
		{ $t1 = mk_loopblock ($t, env, NULL);
		  if ($t != NULL)
		     decl_tagstat ($t1);
		  $e = NEWSCOPE ($t1);
		} |
		T_WHILE expr (^t1) =
		{ $t1 = SOLVE_EXPR (bu_expr ($t1), std_boolean,
				                   "while loop expression error");
		  $t1 = mk_loopblock ($t, env, $t1);
		  if ($t != NULL)
		     decl_tagstat ($t1);
		  $e = NEWSCOPE ($t1);
		} |
		T_FOR T_IDENT reverse (^d) discr_range (^t2) =
		{ ac t, q, r;
		   $t1 = mk_forblock ($t, env, $d);
		   if ($t != NULL)
		      decl_tagstat ($t1);
		   $e = NEWSCOPE ($t1);
		   t = TD_FILTER (bu_filter (mk_filter (NULL, $t2)),
		          "Error in forloop type %s\n", $2);
		   r = mk_subtype (mk_tag (gen_tag (), IDL), t);
		   INTRODUCE (r);
		   r = mk_object ($2, mk_desc (r, KCONST, NULL));
		   INTRODUCE (r);
		   off_intro (r);
		} ;

reverse (^d):	T_IN =
		{ $d = FORWARD;
		} |
		T_IN T_REVERSE =
		{ $d = BACKWARDS;
		} ;

basic_stat (^t):	T_NULL =
		{ $t = NULL;
		} |
		bas_stat (^t);

bas_stat (^t):	exit_stat (^t) |
		return_stat (^t) |
		goto_stat |
		assignment (^t) |
		raise_stat (^t) |
		proc_call (^t) |
		delay_stat (^t) |
		abort_stat (^t) |
		select_entry (^t) ;

exit_stat (^t):	exit_unit (^t) opt_whenexpr (^t1) =
		{ s_exitcond ($t, $t1);
		};

exit_unit (^t1):	T_EXIT =
		{ $t1 = mk_exit (encl_loop ());
		} |
		T_EXIT ls_name (^t) =
		{ $t1 = mk_exit (get_loop (td_n_name (bu_name ($t))));
		};

opt_whenexpr (^t):	=
		{ $t = NULL;
		} |
		T_WHEN expr (^t1) =
		{ $t = SOLVE_EXPR (bu_expr ($t1), std_boolean, "illegal exit expression");
		} ;

return_stat (^t):	T_RETURN =
		{ $t = mk_return ();
		} |
		T_RETURN expr (^t1) =
		{ ac t = mk_return ();
		  ac r = g_enclsub (t);
		  if (r != NULL) {
		     if (g_rettype (g_specif (r)) == notype) {
		        error ("Procedure %s with return expression\n",
					       g_tag (g_specif (r)) );
		        $t1 = NULL;
		     }	
		     else
		     $t1 = SOLVE_EXPR (bu_expr ($t1), g_rettype (g_specif (r)),
			                 "type error in return expression");
		  }
		  else
		     $t1 = NULL;

		  s_retexpr (t, $t1);
		  $t = t;
		} ;

goto_stat:	T_GOTO ls_name (^t) =
		{ error (" goto's not supported in DAC");
		} ;

raise_stat (^t):	T_RAISE =
		{ if (!is_in_ex_h (env))
		     error ("re-raise outside an exception handler");
		  $t = mk_raise (NULL);
		} |
		T_RAISE ls_name (^t) =
		{ $t = mk_raise (get_exc (td_n_name (bu_name ($t))));
		} |
		T_RAISE ls_name (^t) T_IN name (^t2) =
		{ $t = mk_raise (get_exc (td_n_name (bu_name ($t))));
		  s_exc_task ($t, chk_task (td_n_name (bu_name ($t2))));
		};


assignment (^t):	name (^t) T_AS expr (^t1) =
		{ $t = td_assign (mk_assign (bu_name ($t), bu_expr ($t1)));
		} ;

proc_call (^t):	name (^t) =
		{ $t = td_proc (bu_name ($t));
		  if ($t == NULL) {
		     error ("Error in procedure/entry call");
		  }
		  else
		  { if ($t != NULL && g_d ($t) == XENTRYCALL) {
		       s_call_delay ($t, mak_inf_delay ());
		       s_call_stats ($t, NULL);
		    }

		    $t = mk_subcall ($t);
		  }
		} ;

select_call (^t):	T_SELECT name (^t) T_SEM_COL =
		{ $t = td_proc (bu_name ($t));
		  if ($t != NULL) {
		     if (g_d ($t) != XENTRYCALL) {
		        error ("Entry call expected here");
		     }
		  }
		};

delay_cond (^t):	T_OR T_DELAY simple_expr (^t) T_SEM_COL =
		{ $t = mak_delay ($t);
		} |
		T_ELSE =
		{ $t = mak_delay (NULL);
		};

select_entry (^t):
		select_call (^y) statements (^u, v) delay_cond (^z) statements (^f, l) T_END T_SELECT =
		{ if ($y != NULL) {
		     s_call_delay ($y, $z);
		     s_call_stats ($y, $f);
			
		     s_call_next  ($y, $u);
		     $t = mk_subcall ($y);
		  }
		} |
		select_call (^y) statements (^u, v) delay_cond (^z) T_END T_SELECT =
		{ if ($y != NULL) {
		     s_call_delay ($y, $z);
		     s_call_next  ($y, $u);
		     $t = mk_subcall ($y);
		  }
		  else
		     $t = NULL;
		};


%%
#
#include	"includes.h"
#include	"lex.yy.c"

del_optid (x)
register char *x;
{	if (*x!= NULL)
	   del_tag (x);
}

