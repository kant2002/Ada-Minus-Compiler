
# line 19 "1A00.attrib"
typedef union  {
	int	f_int;
	char	*p_char;
} YYSTYPE;
# define T_ABORT 257
# define T_ABS 258
# define T_ACCEPT 259
# define T_ACCESS 260
# define T_ALL 261
# define T_AND 262
# define T_ARRAY 263
# define T_AT 264
# define T_BEGIN 265
# define T_BODY 266
# define T_CASE 267
# define T_CONSTANT 268
# define T_DECLARE 269
# define T_DELAY 270
# define T_DELTA 271
# define T_DIGITS 272
# define T_DO 273
# define T_ELSE 274
# define T_ELSIF 275
# define T_END 276
# define T_ENTRY 277
# define T_EXCEPTION 278
# define T_EXIT 279
# define T_FOR 280
# define T_FUNCTION 281
# define T_GENERIC 282
# define T_GOTO 283
# define T_IF 284
# define T_IN 285
# define T_IS 286
# define T_LIMITED 287
# define T_LOOP 288
# define T_MOD 289
# define T_NEW 290
# define T_NOT 291
# define T_NULL 292
# define T_OF 293
# define T_OR 294
# define T_OTHERS 295
# define T_OUT 296
# define T_PACKAGE 297
# define T_PRAGMA 298
# define T_PRIVATE 299
# define T_PROCEDURE 300
# define T_RAISE 301
# define T_RANGE 302
# define T_RECORD 303
# define T_REM 304
# define T_RENAMES 305
# define T_RETURN 306
# define T_REVERSE 307
# define T_SELECT 308
# define T_SEPARATE 309
# define T_SUBTYPE 310
# define T_TASK 311
# define T_TERMINATE 312
# define T_THEN 313
# define T_TYPE 314
# define T_USE 315
# define T_WHEN 316
# define T_WHILE 317
# define T_WITH 318
# define T_XOR 319
# define T_CHAR_LIT 320
# define T_CHAR_STRING 321
# define T_RELOP 322
# define T_IDENT 323
# define T_INT_LIT 324
# define T_REAL_LIT 325
# define T_MULT 326
# define T_DIV 327
# define T_PLUS 328
# define T_MINUS 329
# define T_AMP 330
# define T_BOX 331
# define T_EXP 332
# define T_BAR 333
# define T_AS 334
# define T_COLON 335
# define T_DOT 336
# define T_COMMA 337
# define T_QUOTE 338
# define T_DD 339
# define T_LP 340
# define T_RP 341
# define T_ARROW 342
# define T_SEM_COL 343
# define T_LS 344
# define T_LF 345
#define yyclearin yychar = -1
#define yyerrok yyerrflag = 0
extern int yychar;
extern short yyerrflag;
#ifndef YYMAXDEPTH
#define YYMAXDEPTH 150
#endif
YYSTYPE yylval, yyval;
# define YYERRCODE 256

# line 3082 "1A00.attrib"

#
#include	"includes.h"
#include	"lex.yy.c"

del_optid (x)
register char *x;
{	if (*x!= NULL)
	   del_tag (x);
}


#ifndef ATT_SIZE
#define ATT_SIZE	150
#endif

union _attr_elem {
  bool  _t0;
  p_link  _t1;
  ac  _t2;
  int  _t3;
  t_tag  _t4;
} _attr_stack [ATT_SIZE];
union _attr_elem *_ap =      &_attr_stack [ATT_SIZE - 1];
short yyexca[] ={
-1, 1,
	0, -1,
	281, 3,
	282, 3,
	297, 3,
	300, 3,
	309, 3,
	315, 3,
	318, 3,
	323, 3,
	-2, 0,
-1, 2,
	323, 64,
	-2, 65,
-1, 3,
	323, 64,
	-2, 65,
-1, 161,
	276, 391,
	-2, 457,
-1, 236,
	276, 391,
	-2, 457,
-1, 237,
	276, 391,
	-2, 457,
-1, 394,
	276, 391,
	-2, 457,
-1, 413,
	276, 391,
	-2, 457,
-1, 492,
	302, 223,
	-2, 375,
-1, 523,
	276, 423,
	-2, 457,
-1, 527,
	276, 428,
	316, 428,
	-2, 457,
-1, 540,
	276, 391,
	-2, 457,
-1, 569,
	333, 308,
	342, 308,
	-2, 317,
-1, 574,
	333, 307,
	342, 307,
	-2, 367,
-1, 594,
	336, 380,
	338, 380,
	340, 380,
	-2, 374,
-1, 607,
	274, 419,
	275, 419,
	276, 419,
	-2, 457,
-1, 614,
	333, 308,
	342, 308,
	-2, 317,
-1, 618,
	276, 391,
	-2, 457,
-1, 619,
	276, 391,
	-2, 457,
-1, 623,
	276, 391,
	-2, 457,
-1, 677,
	343, 184,
	-2, 222,
-1, 714,
	276, 396,
	316, 396,
	-2, 457,
-1, 721,
	274, 421,
	275, 421,
	276, 421,
	-2, 457,
-1, 737,
	302, 223,
	-2, 375,
-1, 758,
	274, 454,
	276, 454,
	294, 454,
	-2, 457,
-1, 760,
	274, 454,
	276, 454,
	294, 454,
	-2, 457,
-1, 811,
	302, 223,
	337, 254,
	341, 254,
	-2, 375,
-1, 819,
	333, 262,
	342, 262,
	-2, 367,
-1, 841,
	336, 380,
	338, 380,
	340, 380,
	-2, 374,
-1, 866,
	274, 455,
	276, 455,
	294, 455,
	-2, 457,
	};
short termi[] ={

  -1,   0, 323, 323,  -1, 323,  -1, 343, 343, 343,
 343,  -1, 343, 343, 343,  -1, 297, 276,  -1,  -1,
  -1, 276, 265,  -1, 297, 286,  -1,  -1,  -1,  -1,
  -1,  -1,  -1, 343,  -1, 335,  -1,  -1,  -1,  -1,
  -1,  -1,  -1,  -1, 323,  -1, 343, 297,  -1,  -1,
  -1,  -1,  -1, 340,  -1,  -1, 323, 323, 323, 323,
  -1, 344, 265,  -1,  -1,  -1, 265,  -1, 344, 344,
  -1, 323,  -1,  -1,  -1,  -1,  -1, 343, 286, 281,
 340,  -1,  -1, 335, 323,  -1, 323, 306, 323,  -1,
 278, 323, 276, 343,  -1,  -1,  -1,  -1,  -1,  -1,
  -1,  -1,  -1,  -1,  -1,  -1,  -1, 335,  -1,  -1,
  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, 323,
 323, 323,  -1,  -1,  -1,  -1, 286, 323, 340, 341,
 323,  -1,  -1,  -1, 323, 314,  -1, 286, 323,  -1,
  -1, 266, 266, 323, 323, 323, 323, 323, 306,  -1,
  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
  -1, 276,  -1,  -1, 343, 323,  -1,  -1,  -1,  -1,
  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
  -1,  -1,  -1,  -1, 276, 276, 276,  -1,  -1,  -1,
  -1, 323, 334,  -1, 324,  -1, 344,  -1, 316,  -1,
 273, 335,  -1,  -1, 323, 323, 313, 324,  -1,  -1,
 336, 336, 324, 323, 344,  -1,  -1, 340, 323, 343,
  -1,  -1,  -1,  -1,  -1, 265, 265, 266, 266, 276,
  -1,  -1,  -1, 276, 344,  -1, 276, 276, 286, 343,
  -1, 299,  -1, 323,  -1, 341, 323,  -1, 323,  -1,
 341,  -1, 335, 323, 341,  -1, 335,  -1, 305,  -1,
 335,  -1,  -1,  -1, 324, 323, 268, 323,  -1,  -1,
 286,  -1,  -1,  -1, 276,  -1,  -1, 343, 343, 316,
  -1, 323, 335, 323,  -1, 323, 286, 277, 297, 277,
  -1,  -1,  -1, 323,  -1, 290, 286, 323, 323,  -1,
  -1,  -1,  -1, 341,  -1, 323, 323, 323, 276,  -1,
  -1, 316,  -1,  -1, 345, 284, 276,  -1, 344, 313,
  -1, 324, 267,  -1, 344, 295, 308, 344,  -1,  -1,
  -1,  -1, 344, 344, 288,  -1,  -1, 324, 323,  -1,
  -1, 324,  -1,  -1,  -1,  -1,  -1, 324,  -1,  -1,
  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, 324,
  -1,  -1,  -1,  -1,  -1,  -1, 323, 340, 341,  -1,
 324,  -1,  -1, 323, 294,  -1,  -1, 259, 324, 344,
  -1,  -1, 323, 323, 323,  -1, 343, 344, 286,  -1,
 261, 261,  -1,  -1, 276,  -1, 343, 324, 295, 315,
  -1,  -1, 309, 344, 344, 323, 323,  -1, 344,  -1,
  -1,  -1,  -1, 276, 276, 276,  -1,  -1,  -1, 331,
 331, 323, 331,  -1, 331, 341,  -1, 302,  -1,  -1,
  -1, 323,  -1, 335,  -1, 323, 296,  -1,  -1, 323,
 323, 323,  -1,  -1, 323, 323, 323, 323, 278,  -1,
  -1,  -1,  -1,  -1, 305, 323,  -1,  -1, 340,  -1,
 335, 276, 276, 290, 323, 323, 299, 323, 324, 323,
  -1,  -1,  -1, 303,  -1, 343,  -1,  -1, 276,  -1,
 342, 295, 286, 323, 323, 341, 341,  -1, 302,  -1,
  -1, 338, 302,  -1, 323, 276,  -1,  -1, 323, 323,
 276,  -1, 323,  -1, 286, 286,  -1, 323,  -1,  -1,
  -1,  -1,  -1,  -1,  -1,  -1,  -1, 344, 295,  -1,
  -1,  -1, 284, 276, 344,  -1,  -1, 276, 342,  -1,
  -1,  -1, 302,  -1,  -1,  -1, 276,  -1,  -1, 276,
 276,  -1, 265,  -1, 285,  -1, 324,  -1,  -1,  -1,
 324, 324, 324,  -1, 285,  -1,  -1,  -1, 324,  -1,
  -1,  -1,  -1,  -1, 324, 341,  -1, 337, 342,  -1,
  -1,  -1,  -1, 302, 333,  -1,  -1, 323, 340, 324,
 341,  -1, 324,  -1, 323,  -1, 344, 270,  -1, 343,
 343, 343, 342, 276,  -1,  -1,  -1,  -1, 341,  -1,
 302,  -1,  -1,  -1, 339, 342,  -1, 274,  -1,  -1,
  -1, 276,  -1, 343,  -1,  -1,  -1,  -1, 276, 276,
 286, 286,  -1, 276, 343, 276,  -1,  -1,  -1,  -1,
  -1, 341,  -1,  -1, 293, 323, 331,  -1, 323, 323,
  -1, 323,  -1,  -1,  -1, 323, 296,  -1,  -1,  -1,
  -1, 323,  -1,  -1,  -1,  -1,  -1, 324, 323,  -1,
  -1,  -1, 324, 323, 334,  -1, 334,  -1,  -1, 324,
 268,  -1,  -1, 323,  -1, 341,  -1, 343, 302,  -1,
 339,  -1,  -1,  -1, 267,  -1, 323,  -1,  -1,  -1,
  -1,  -1,  -1,  -1, 293, 293, 324, 331,  -1, 324,
 302,  -1,  -1,  -1, 343,  -1, 286,  -1,  -1,  -1,
  -1,  -1,  -1,  -1, 276, 342,  -1,  -1,  -1,  -1,
  -1, 274,  -1, 323,  -1, 308, 288, 276,  -1, 324,
  -1,  -1,  -1,  -1,  -1,  -1, 302,  -1,  -1,  -1,
  -1,  -1,  -1, 324, 324, 323,  -1,  -1, 340, 341,
  -1,  -1,  -1,  -1,  -1, 276, 308, 324, 274,  -1,
 274,  -1,  -1, 324,  -1, 323,  -1, 324,  -1,  -1,
 343,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
  -1,  -1, 323, 286, 266, 276, 276, 309, 309, 276,
  -1,  -1,  -1,  -1,  -1, 323,  -1,  -1,  -1,  -1,
  -1,  -1,  -1, 323,  -1,  -1,  -1,  -1,  -1, 341,
  -1, 337, 302,  -1,  -1,  -1,  -1,  -1, 342,  -1,
  -1,  -1,  -1,  -1, 341,  -1,  -1,  -1,  -1, 323,
  -1,  -1, 343,  -1, 323,  -1, 323, 323,  -1,  -1,
  -1, 336,  -1,  -1,  -1,  -1, 323,  -1, 323,  -1,
  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
 324,  -1, 308,  -1, 343,  -1, 274,  -1,  -1, 341,
  -1,  -1,  -1,  -1, 286,  -1,  -1,  -1,  -1,  -1,
  -1,  -1,  -1,  -1,  -1,  -1, 323,  -1, 323, 323,
 324, 323, 293, 341,  -1,  -1,  -1,  -1, 341,  -1,
  -1,  -1, 342, 342,  -1, 341,  -1,  -1,  -1,  -1,
  -1,  -1,  -1,  -1,  -1, 323,  -1, 321,  -1, 323,
 324, 323,  -1,  -1, 341,  -1,  -1,  -1,  -1 };
# define YYNPROD 504
# define YYLAST 1755
short yyact[]={

 209, 899, 810, 453, 428, 573, 599, 531, 509, 203,
 594, 368, 572, 718, 274, 708, 100, 865, 566, 432,
 659, 751, 486, 661, 426, 308, 660, 348, 353, 656,
 344, 222, 496,  45, 221, 346, 223, 115, 487, 104,
  99,  85, 457, 479, 280,  97,  98, 655, 220, 102,
 456, 101, 251, 255, 510, 181, 158, 187, 151, 644,
 520, 343, 443, 204, 444, 213, 894, 162, 555, 556,
 557, 873, 438, 207, 439, 430, 194, 431, 843, 790,
 588, 224, 204, 907, 213, 202, 547, 760, 759, 191,
 212, 758, 207, 683, 612, 194, 242, 149, 168, 606,
 587, 862, 477, 476, 202, 417, 401, 193, 191, 212,
 313, 262, 190, 240, 205, 140, 553, 168, 548,  89,
  42, 271, 554,  41, 235, 467, 193,  40, 423, 201,
  39, 190,  38, 205, 421,  37, 204, 423, 213, 555,
 556, 557,  36, 549, 921, 420, 207, 302, 201, 194,
 165, 920, 472, 550, 769, 469, 890, 312, 202, 555,
 556, 557, 191, 212, 204, 742, 213, 468, 470, 165,
 699, 168, 847, 418, 207, 743, 419, 194, 919, 922,
 193, 767, 918, 762, 917, 190, 202, 205, 916, 696,
 191, 212, 369, 892, 371, 761, 567, 886, 744, 168,
 365, 885, 201, 381, 365, 471, 722, 366, 193, 363,
 555, 556, 557, 190, 422, 205, 928, 365, 686, 400,
 743, 699, 365, 165, 861, 908, 204, 829, 213, 309,
 201, 828, 794, 748, 662, 663, 207, 355, 364, 194,
 154, 361, 362, 765, 429, 756, 397, 764, 202, 860,
 389, 165, 191, 212, 429, 582, 696, 359, 442, 750,
 695, 168, 414, 415, 635, 846, 451, 429, 694, 383,
 193, 700, 663, 384, 365, 190, 204, 205, 213, 662,
 763, 635, 658, 582, 492, 634, 207, 581,  86, 194,
 285, 507, 201, 491, 284, 726, 506, 383, 202, 577,
 669, 384, 191, 212, 309, 309, 429, 579, 465, 889,
 508, 168, 283, 165, 246, 243, 514, 663, 449, 383,
 193, 382, 398, 384,  88, 190, 492, 205, 147, 582,
 670, 365, 267, 265, 638, 491, 639, 483, 448, 484,
  91, 445, 201, 446, 440, 743, 441, 365, 266, 373,
 267, 365, 211, 247, 146, 248,  90, 365,  91, 145,
 492, 888, 391, 165, 576, 390, 307, 429, 306, 491,
 380, 657, 458, 370, 891, 848, 834, 745, 723, 580,
 365, 564, 797, 563, 631, 492, 538, 342, 365, 576,
 600, 555, 556, 557, 491,  58, 136, 629, 628, 492,
 514, 154, 281, 576, 388, 376, 646, 365, 491, 392,
 153, 119, 121, 106,  59, 610, 561, 645, 914, 405,
 611, 565, 429, 433, 130, 135, 630, 277,  84, 120,
 345, 562, 154, 591, 365, 589, 429, 107, 596, 625,
 406, 429, 309, 657, 154, 160, 429, 159, 653, 609,
 840, 637, 458, 559, 560, 651, 429, 455, 282, 664,
 595, 450, 309, 803, 622, 674, 675, 654, 429, 624,
 429, 595, 677, 153, 511, 513, 874, 512, 491, 716,
 553, 309, 492, 597, 429, 665, 554, 692, 293, 690,
 154, 491, 642, 154, 648, 429, 405, 294, 649, 153,
 652, 575, 281, 709, 668, 650, 666, 154, 511, 513,
 292, 512, 154, 291, 712, 698, 458, 550, 525, 719,
 706, 455, 685, 555, 556, 557,  84, 293, 703, 693,
  79, 258, 705, 703, 543,  83, 294, 701, 545, 704,
 156, 138, 155, 513, 153, 512, 153, 511, 513, 282,
 512, 256, 737, 270, 252, 153, 365, 621, 282, 724,
 365, 491, 365, 620, 544, 505, 727, 583, 365, 504,
 501, 153, 713, 482, 365, 592, 154, 731, 460,  83,
 492, 602, 393, 492, 576, 314, 740, 576, 738, 491,
 735, 309, 491, 741, 304, 309, 153, 301, 137, 300,
 746, 753, 747, 299, 309, 296, 153, 309, 309, 286,
 272, 270, 260, 249, 238, 157, 150,  35, 153, 153,
 924, 633, 378, 547, 518, 372, 481, 766, 325, 684,
 341, 615, 213, 783, 732, 524, 429, 387, 322, 429,
 210, 516, 429, 194, 785, 786, 429, 429, 776, 789,
 878, 777, 429, 775, 781, 548, 780, 774, 153, 799,
 796, 309, 772, 773, 811, 771, 778, 365, 779, 481,
 737, 429, 491, 491, 709, 309, 877, 617, 325, 491,
 549, 305, 906, 792, 793, 590, 309, 309, 800, 827,
 863, 309, 824, 850, 822, 805, 823, 737, 152, 830,
 335, 833, 831, 535, 339, 854, 491, 491, 463, 365,
 253, 841, 447, 402, 490, 338, 264, 682, 662, 153,
 697, 636, 676,  58, 492, 499,  71, 464, 825, 826,
 737, 849, 264, 491, 537, 838, 641, 915, 837, 491,
 835, 866,  59, 836, 492, 795, 492, 673, 576, 327,
 576, 326, 337, 491, 365, 491, 533, 502, 857, 842,
 859, 152, 753, 698, 845, 855, 492, 365, 853, 328,
 576, 600, 870, 365, 153, 491, 749, 365, 867, 752,
 851, 541, 309, 495, 463, 489, 144, 152, 153, 309,
 569, 290, 402, 153, 844, 788, 429, 787, 153, 881,
 153, 711, 141, 161, 429, 143, 710, 691, 153, 608,
 236, 237, 503, 494, 424, 604, 142, 153, 153, 868,
 153, 416, 153, 309, 295, 872, 289, 534, 613, 614,
 893, 287, 152, 356, 152, 492, 153, 429, 429, 887,
 896, 897, 895, 152, 491, 273, 882, 153, 880, 719,
 241, 139, 884,  72, 806, 153, 365, 739, 730, 152,
 814, 492, 904,  58, 136, 576, 584, 667, 436, 720,
 491, 153, 521, 425, 218, 707, 498, 702, 498, 782,
 121, 654,  59, 258, 152, 498, 601, 811, 879, 912,
 320, 321, 315, 784, 152, 192, 491, 120, 514, 680,
 365, 876, 192, 192, 408, 875, 152, 152, 852,  68,
 791, 768, 533,  61, 672, 407, 429, 671, 627, 923,
  67, 925, 927, 626,  60, 522, 515, 473, 412, 365,
 365, 261, 909, 910, 309, 733, 911, 379, 374, 832,
 752, 856, 278, 276, 757, 526, 152, 298,  34,  95,
  58,  48, 297, 519,  92, 728, 394, 404, 403, 234,
 869, 214, 602,  69, 871,  81,  44, 360, 216,  59,
 679, 323,  77,  87, 128,   2, 413,   3,  53, 126,
  75, 734, 490, 534,  57,   4, 105,  56, 153,  31,
 586, 153,  33, 196, 153, 192, 340, 189, 153, 153,
 183, 180, 179,  80, 153, 178, 177, 152,  78, 176,
 569, 175, 169, 569, 729, 334, 817, 332, 336, 333,
 233, 331, 330, 153, 329, 188, 153, 208, 148, 200,
 192,  62, 195, 182, 377, 199, 186, 530, 385, 386,
 259, 528, 324, 901, 198, 185, 318, 319, 192, 239,
 206,  80,  66, 489, 317,  70,  78, 905,  73,  74,
 523, 197, 152, 316, 184, 174, 527, 173, 192, 536,
 192, 192, 172, 500, 539, 540, 152, 493, 171, 170,
 167, 152, 166, 814, 164, 163, 152, 913, 152, 717,
 715, 517, 311, 680, 604, 310, 152, 603, 598, 367,
 490, 358, 357, 354, 558, 152, 152,  80, 152, 552,
 152, 427,  78, 288, 347, 551, 901, 926, 546, 571,
 568, 593, 124, 123, 152, 122, 643, 490, 680, 607,
 839, 250, 254,  55, 454, 152,  54,  50,  49, 821,
 818, 815, 809, 152, 689, 618, 619, 687, 153, 480,
 623, 488, 192, 478, 533, 279, 153, 485, 192, 152,
 490, 192, 275, 134, 808, 813, 192, 192, 129, 466,
 375, 489, 245, 244, 569,  82, 858, 127, 352, 678,
 116, 114, 153, 113, 395, 396, 112, 111, 864, 153,
 153, 110, 108, 532, 109, 452, 604, 231, 489, 808,
 226, 153, 770, 103,  96,  93, 616, 585, 192, 219,
 366, 351, 363, 192, 437, 820, 259, 459, 475, 474,
 399, 192, 217, 461, 462, 534, 215,  63, 192, 232,
 229, 489,  94, 497, 578, 131, 125, 192, 192, 817,
 355, 364, 192, 819, 361, 362, 133, 192, 349, 350,
 117, 132, 118, 230, 225, 900, 898,  52,  51, 714,
 359,  46, 409, 410, 411, 533, 721, 601, 153, 303,
  27,  22,  26,  21, 153, 204, 152, 213,  47, 152,
  30,  29, 152,  25,  20, 207, 152, 152, 194, 435,
 434, 569, 152,  76, 725,  28,  24, 202,  19,  18,
  23, 191, 212, 640, 816,  17,  16,  15, 647,  14,
 168, 152,  13, 647, 152,  12,  11, 604,  10, 193,
 204,   9, 213,   8, 190,   7, 205,   6, 755,  32,
 207,   5,   1, 194,   0,   0, 534, 681,   0,   0,
   0, 201, 202, 352,   0,   0, 191, 212,   0, 532,
   0, 192,   0,   0,   0, 168,   0, 192, 192,   0,
   0, 192, 165,   0, 193,   0,   0, 352, 542, 190,
 192, 205,   0, 192, 192, 366, 351, 363,  64,   0,
 570,   0,   0,   0,   0,   0, 201,   0, 813,   0,
   0,   0,   0,   0,  43,   0,   0,   0,  65, 366,
 351, 363,   0,   0,   0, 355, 364, 165, 574, 361,
 362,   0,   0, 349, 350,   0,   0,   0, 754, 736,
 192,   0,   0,   0,   0, 359,   0, 192, 352, 355,
 364,   0, 154, 361, 362,   0, 152, 349, 350,   0,
 797, 192,   0,   0, 152,   0,   0,   0,   0, 359,
   0,   0, 192, 192,   0,   0,   0, 192,   0,   0,
 366, 351, 363,   0,   0, 688,   0,   0, 257,   0,
 152,   0,   0, 263,   0,   0,   0, 152, 152,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0, 152,
 355, 364, 807, 154, 361, 362, 268, 269, 349, 350,
   0,   0,   0, 427,   0,   0, 798,   0, 352, 801,
 359,   0,   0, 802, 804,   0,   0,   0,   0, 804,
   0,   0,   0,   0,   0,   0,   0, 816,   0,   0,
   0, 812,   0,   0,   0,   0,   0, 736,   0,   0,
 366, 351, 363,   0,   0,   0,   0,   0, 192,   0,
 352,   0,   0,   0,   0, 192, 152,   0,   0,   0,
   0,   0, 152,   0, 736,   0,   0,   0, 352,   0,
 355, 364,   0, 154, 361, 362,   0,   0, 349, 350,
   0, 632, 366, 351, 363,   0,   0, 529,   0, 192,
 359, 532, 192, 352, 192,   0,   0, 736,   0,   0,
 366, 351, 363,   0,   0,   0,   0,   0,   0,   0,
   0, 352, 355, 364,   0, 154, 361, 362,   0,   0,
 349, 350,   0,   0,   0, 366, 351, 363,   0,   0,
 355, 364, 359, 154, 361, 362,   0,   0, 349, 350,
   0,   0,   0, 366, 351, 363,   0,   0,   0,   0,
 359, 352,   0,   0,   0, 355, 903,   0, 902, 361,
 362,   0,   0, 349, 350,   0,   0,   0,   0,   0,
   0, 883,   0, 355, 364, 359, 605, 361, 362,   0,
   0, 349, 350, 366, 351, 363,   0,   0,   0,   0,
  58, 136,   0, 359,   0,   0,   0,   0,   0,   0,
 192,   0, 532,   0,   0,   0, 119, 121,   0,  59,
  58, 136,   0, 355, 364,   0, 574, 361, 362, 130,
 135, 349, 350,  84, 120,   0, 227, 121,   0,  59,
   0,   0, 107, 359,   0,   0,   0,   0,   0, 130,
 228,   0,   0,  84, 120,   0,   0,   0,   0,   0,
   0,   0, 107,   0, 812 };
short yypact[]={

-1000,-1000,-1000,-1000,-1000, 294,-1000,-201,-208,-211,
-213,-1000,-216,-220,-223,-1000, 669, 648,-1000,-1000,
-1000, 644, 698,-1000, 429, 567,-1000,-1000, 212, -52,
 -16,-1000,-1000,-224,-1000,  21,-1000,-1000,-1000,-1000,
-1000,-1000,-1000, 114, 275, 565,-228, 505,-1000,-1000,
-1000,  22,  17, -12, -16, -52, 293,  78, 219, 292,
 124,1063, 696, 594,1429, 114, 694, 124,1063,1063,
-1000, 291,-1000,-1000,-1000,-1000, 212,-230, 564, 442,
 -25,-1000, -26,  18, 290,-1000, 231, 404, 228,-1000,
 605, 289, 655,-232,-1000,-1000,-1000,-1000,-1000,-1000,
 411,  -4,-1000,-1000,-1000,-1000,-1000,  13,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000, 288,
  78, 287,-1000,-1000,-1000,-1000, 559, 135, -28, -47,
 286, 545, 212, 540, 190, 213,-1000, 538, 282,-1000,
-1000, 686, 681, 280, 276, 274,  78, 271, 375,-1000,
-1000,-1000,  32,  30,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,-121,-1000,-1000,-233, 262,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000, 616, 362, 475,-1000, 435, 314,
1310,  78,  39,  78,1310,  12,1063,-1000, 312, 306,
 664,  35,  78, -17,  78,  78, 324,1310, -52,-1000,
  29,  26,1310, 259,1063, 594,-1000, -18,  78,-237,
-1000,-1000,-1000,-1000, 427, 693, 692, 230, 174, 639,
-1000,-1000,-1000, 652,1063,-1000,-121,-121, 535,-238,
-1000,-126, 528,  78,-1000,-266, 100, 583, 256,-1000,
-269,-1000,   9,  78,-279,-1000,   6,1409, 407,-1000,
   3, 124,-1000,1409,1310,  78, 253, 255, 114, 114,
 422,-1000, -32,-135, 651, 235,-1000,-240,-241, 310,
-1000, 250,   2,1310,-1000, 190, 527, 608, 428, 608,
-1000,-1000,-1000, 247,-1000, 467, 526, 246, 242,-1000,
-1000,-1000,-1000, -45,-1000,  78, 227, 227, 650,-1000,
 308, 308,-1000,-1000,-285, 588, 649,-1000,1063, 322,
-1000,1310, 678,-1000,1063,1292, 395,1063, 306, 124,
-1000,-1000,1063,1063, 493,-1000,-1000,1310, 241,-1000,
-1000,1310,-1000, 361,-1000, 195, 127, -83,-1000,-1000,
-1000,-1000,-1000,  49,-1000,-1000,-1000,-1000,-1000,1085,
-1000,-1000,-1000,-1000,-1000, -39,  78, -33, -54,-1000,
1310, 581,  63,  78,-194,-1000,-1000, 373,1310,1063,
-1000,-1000, 137, 222,1353,-1000,-244,1063, 523,-1000,
 188, 154,-1000,-1000,-121,-1000,-249,1310,1085, 316,
-1000,-1000, 368,1063,1063, 240, 234, 124,1063,-1000,
-1000,-1000, 124,-121, 647, 642,-1000,-1000,-1000,  67,
  66,  78,  53,-1000,1250, -56,-1000, 419,-1000,-1000,
-1000, 100,-1000,  -1,-1000,  78, 440,-1000,-1000, 231,
 121, 231,-1000,-1000, 228, 170, 228,  78, 603,-1000,
-1000,-1000,-1000,  37, -23, 109,  37,-1000, -40,-1000,
  -5, 641, 638, 457,  78,  78, 423,  78,1310,  78,
-1000,-1000,-1000, 414,-1000,-250,-1000,-1000, 353,-1000,
-124,1170, 521,  78, 226, -73, -81,-1000, 418,-1000,
-118, -67,-1000,-1000,  78, 601,-1000, -52, 209, 197,
 599,-1000,  78,-1000, 520, 515,-1000, 191,-1000,-1000,
-1000,-1000,-1000,-1000,-1000, 124,-1000,1063, 184,-1000,
-1000,-1000, 585,1063,1063,-1000,-1000,1063,-136,-1000,
  45,-1000, 416,-118,-1000,-1000,1018,-1000,-1000,  19,
-121,-1000, 690,-1000, 573,-1000,1310, 321, 661,-1000,
1310,1310, -83,-1000, 572,-1000,-1000,-1000, -83,-1000,
-1000,-1000,-1000, 127, -83,-176,-1000,   8,-144,-169,
-1000,  44,-1000, 416,-1000,-1000,-1000, 137,-105,1085,
 -82,-1000,1085,-1000,  78,-1000, -31, 674,-1000,-252,
-255,-256,-147, -93,-1000, -60,-1000,-1000, -94,-1000,
 416,-1000,-1000,-1000,-169,-161,-1000,1063,-1000,-1000,
-1000, 635,-1000,-189,-169,-1000, 582,-1000,-121,-121,
 511, 509,-1000,-121,-264, 634, 124, 124,-1000,-1000,
-1000,-109,-1000,-1000, 452,  78,  51,-1000,  78, 100,
  37,  78,-1000,-1000,-1000,  78, 167,  37,-1000,-1000,
-1000,  78,-1000,-1000,-1000,-1000,-1000,1310,  78,-1000,
-1000,-1000,1310, 920,  37,-1000,  37, -68,-1000,1310,
 189, 124, 124,  78,-1000,-110,-1000,-1000, -68,-1000,
-118, -68,-1000,-1000, 672,-1000, 135,-1000,-1000,  43,
-1000,-1000,  37,-1000, 450, 445,1310,1109,-1000,1310,
 148,-1000, 124,-1000,-265,-1000, 508, 124,-1000, -75,
-1000,-1000,-1000,-1000,1063,-170,-1000,  42,-1000,-1000,
-1000,1063,-1000,1310,-1000, 385, 492, 632,-1000,1310,
 398,-1000,-1000,-1000,  63,-1000, 416,-1000, 127,-1000,
-1000,-1000,-1000,1085,1310,1393,-1000,-1000, -91,-117,
-1000,-1000,-1000,-1000,-1000,-175, 382,1310,1063,-1000,
1063,-1000, 124,1310,-1000,1353,-1000,1310, 124,-1000,
-272,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,  -4,
-1000,-1000, 153, 506, 174, 629, 625, 367, 341, 612,
-1000, 124,-1000,-1000,-1000,  78,-1000,-1000,  37,-1000,
-1000,-1000,-1000,  78,  37,-1000,-1000,-1000,-1000,-140,
-1000,-1000, 416,-1000,-1000,-1000,  25, -27,-186,-1000,
-1000,  41,-1000,-1000,-148,-1000,-1000,-1000,-1000,  78,
-1000,-1000,-277,-1000,1310,-1000,  78,  78,-1000,  63,
-1000,-1000,-1000,-1000,-1000,-1000,1335,-1000,  78,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-118,  -8,
1085,-1000, 374,-1000,-260,-1000,1063,-1000,-1000,-116,
-1000,-1000,-1000,-1000, 498, 124, 124,-1000,-1000, 124,
-1000,-1000,-1000,-1000,-1000,-1000, 920,-1000, 188, 154,
1310,  95, 444,-153,-1000,-1000,-1000,-1000,-159,-1000,
-1000,-1000,-191,-198,-1000,-162,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,  78,-1000, 299,-1000,1335,
1310,  78,-1000,-1000,-125,-1000,-1000,-1000,-1000 };
short yypgo[]={

   0,  56,1332, 975, 985,1331,1329,1327,1325,1323,
1321,1318,1316,1315,1312,1309,1307,1378, 954,1306,
  15,1305, 741,  25,1300,1031,  16,1299,1298,1296,
1295, 980,1293, 972, 979,   4, 196, 974, 873,   3,
 965,1290,1289, 867,  47,1284,1283,1281,  41,1280,
 973,1278,1273,1272,1271,1270,1269,1261,1258,1257,
   0,  51,  49,1256,   1,1255, 986,  48,1254,1253,
  46,1252,1251,  45,1250,  40,1246,  39,1236, 783,
1235,  37,  32,1233,1232,  36,1230,1229,1227,1226,
 968,1222,1220, 967, 430,1209,1206,1205, 949,1204,
1203, 948,1202,  34,  31,1200,1197,1195,  29,  50,
1194,1192,1191,1187,1186,1183,1181,1180, 501,  20,
1179,1177,  14,1175,1173,1172,  19,1169,1168,1163,
 791,  22,  24,  38,  26,  42,   5,  23,1162, 943,
 942,  44,1155,1153,  43,1149,1147,1144,   7,1142,
   2,1141,1140,1139,   9,1138,1137,1136,1133,1132,
1131,  53,  52,1126,  59,1125,1123,1122, 833,  11,
  18,  21,1120,1119,  12,  61,  30,1118,1115,  35,
1114,1109,  27,1104,  28,1103,1102,1101,1099,   8,
  54, 640, 352,  10,1098,   6,1097,1095,1092, 641,
1091,1090,1089,  13,  67,1085,1084,1082,1080,1079,
1078,1072,1067,1065,1064,1063,1061,1054,1050,1047,
1046,1045,1044, 971,1042,1041,1037,1036,1035, 405,
1034,  57,  17,  55,1033,1032,1029,1027,1025,1024,
1022,1021,1019,1018,1017,1015,1014,1012,1011,1009,
1006,1005,1002,1001,1000, 997, 996, 993, 990 };
short yyr1[]={

   0,   2,   2,   3,   4,   4,   7,   7,   7,   7,
   7,   7,   7,   7,   8,   8,  16,   9,   9,  21,
  24,  10,  11,  27,  12,  28,  29,  30,  31,  31,
  32,  32,  33,  33,  33,  33,  33,  33,  33,  33,
  33,  33,  40,  40,  42,  42,  41,  41,  13,  45,
  46,  46,  47,  49,  14,  14,  52,  53,  15,  54,
  55,  51,  56,  56,   5,  19,  19,  57,  57,  58,
  58,  59,  59,  61,  61,  62,  62,  62,  62,  20,
  20,  63,  63,  64,  64,  65,  65,   6,  67,  68,
  69,  70,  71,  72,  73,  75,  74,  76,  77,  78,
  78,  80,  81,  81,  79,  79,  82,  83,  18,  18,
  84,  85,  85,  86,  87,  25,  25,  89,  89,  91,
  90,  90,  88,  88,  17,  17,  97,  97,  97,  97,
  97,  97,  97,  97,  97,  97,  97,  66,  66, 101,
 101,  96,  96,  95,  95,  95,  95, 102, 102, 102,
 102, 102, 102, 102, 102, 102, 102, 102, 104, 104,
 104, 103, 105, 106,  98,  98,  98, 107, 107, 107,
 107, 107,  99,  99,  99,  99,  99,  99,  99,  99,
  99, 117, 117, 117, 116, 116, 110, 121,  34,  34,
 123, 124, 125, 125, 126, 126, 111, 127, 127, 114,
 113, 128, 128, 129, 130, 130, 112, 112,  37,  38,
  38, 132, 131, 131, 133, 133, 133, 109, 115, 135,
 135,  39, 120,  35,  43, 136, 119, 119, 122, 122,
 122, 122, 138, 138, 140, 141, 141, 139, 142, 143,
 143, 144, 145, 146, 146, 147, 147, 148, 148, 148,
 134, 137, 149, 149, 150, 150, 150, 150, 150, 151,
 152, 152, 153, 153, 118, 118,  26,  26, 155, 156,
 157, 157, 158,  50,  50,  48,  48, 159, 159, 160,
 160, 162, 162, 161, 161, 164, 164, 163, 163, 163,
 100, 100, 100, 165, 166, 167, 169, 169, 169, 171,
 171, 170, 172, 172, 173, 173, 174, 174, 174, 174,
  44,  44, 108,  93,  36, 175, 175, 176, 176, 176,
 177, 177, 177, 177, 177, 178, 178,  94,  94,  94,
 179, 179, 180, 180, 180, 180, 181, 181, 181, 183,
 183, 183, 183, 182, 182, 184, 184, 184, 184, 184,
 184, 184, 185, 185, 185, 185, 186, 186, 186, 186,
 187, 187, 188, 189, 189, 190, 190, 191, 192, 192,
  92,  60,  60, 168, 168, 154, 154, 154, 154, 154,
 154, 154, 193, 193, 194, 194, 195, 195, 195, 195,
 196,  23,  23, 197, 197, 198, 199, 200, 201, 201,
 202, 202, 203,  22,  22, 204, 204, 206, 206, 208,
 208, 208, 208, 208, 205, 209, 209, 214, 214, 216,
 218, 217, 219, 215, 220, 210, 221, 221, 223, 224,
 222, 225, 225, 226, 226, 211, 211, 227, 227, 228,
 229, 229, 229, 230, 230, 233, 234, 235, 235, 212,
 231, 231, 236, 237, 232, 232, 213, 238, 238,   1,
   1,   1, 239, 239, 241, 242, 242, 243, 240, 244,
 245, 245, 245, 246, 246, 207, 207, 247, 247, 247,
 247, 247, 247, 247, 247, 247, 248, 255, 255, 256,
 256, 249, 249, 250, 252, 252, 252, 251, 253, 257,
 258, 258, 254, 254 };
short yyr2[]={

   0,   2,   3,   0,   2,   1,   2,   2,   2,   2,
   1,   2,   2,   2,   5,   6,   4,   3,   6,   2,
   5,   2,   7,   3,   6,   4,   2,   2,   0,   1,
   2,   3,   3,   4,   4,   4,   5,   2,   4,   4,
   6,   1,   3,   3,   0,   1,   3,   3,   7,   2,
   2,   4,   4,   4,   3,   6,   2,   6,   6,   2,
   6,   4,   1,   3,   0,   0,   3,   1,   1,   2,
   3,   2,   3,   2,   3,   2,   5,   7,   9,   1,
   4,   1,   3,   1,   1,   3,   3,   3,   6,   2,
   2,   5,   5,   1,   5,   5,   3,   2,   1,   1,
   5,   3,   1,   5,   1,   2,   3,   2,   0,   2,
   1,   3,   6,   2,   4,   1,   2,   1,   2,   3,
   3,   4,   1,   4,   0,   3,   1,   1,   1,   1,
   1,   1,   1,   1,   1,   1,   1,   1,   5,   3,
   3,   0,   3,   1,   1,   1,   1,   1,   1,   1,
   1,   1,   1,   1,   1,   1,   1,   1,   5,   3,
   5,   6,   2,   4,   3,   4,   3,   3,   2,   2,
   2,   3,   1,   1,   1,   1,   1,   1,   1,   1,
   1,   4,   4,   5,   4,   5,   4,   3,   1,   2,
   2,   2,   2,   3,   4,   3,   4,   0,   1,   1,
   2,   2,   3,   3,   1,   1,   6,   6,   3,   1,
   3,   3,   1,   3,   1,   1,   2,   6,   4,   1,
   2,   1,   1,   1,   1,   1,   1,   1,   2,   1,
   1,   2,   2,   3,   1,   4,   3,   5,   3,   1,
   2,   3,   2,   1,   1,   1,   3,   2,   1,   1,
   2,   3,   1,   3,   1,   2,   1,   1,   1,   3,
   1,   1,   1,   3,   3,   3,   1,   1,   4,   2,
   2,   2,   2,   0,   3,   0,   3,   1,   3,   1,
   3,   3,   3,   3,   3,   2,   3,   1,   2,   3,
   1,   1,   1,   5,   3,   4,   2,   4,   3,   1,
   1,   3,   1,   1,   1,   3,   2,   1,   1,   1,
   0,   1,   2,   2,   1,   1,   3,   1,   3,   3,
   1,   1,   1,   2,   2,   1,   2,   1,   2,   3,
   1,   3,   1,   1,   1,   1,   1,   1,   1,   1,
   1,   1,   1,   1,   3,   1,   1,   1,   1,   1,
   3,   1,   1,   1,   1,   1,   3,   2,   4,   6,
   4,   3,   2,   1,   1,   1,   1,   1,   3,   3,
   1,   1,   1,   1,   3,   1,   3,   3,   3,   3,
   3,   4,   1,   4,   1,   3,   2,   1,   1,   1,
   3,   0,   1,   2,   2,   1,   2,   3,   1,   1,
   1,   3,   1,   1,   2,   1,   2,   1,   1,   1,
   1,   1,   1,   1,   3,   3,   4,   1,   2,   3,
   2,   3,   2,   2,   1,   3,   2,   2,   2,   3,
   3,   1,   1,   1,   3,   3,   5,   2,   3,   1,
   4,   3,   4,   0,   3,   2,   1,   2,   3,   1,
   5,   1,   2,   2,   0,   1,   3,   0,   2,   0,
   1,   1,   1,   1,   4,   1,   3,   1,   4,   2,
   0,   2,   4,   1,   2,   1,   1,   1,   1,   1,
   1,   1,   1,   1,   1,   1,   2,   1,   2,   0,
   2,   1,   2,   2,   1,   2,   4,   3,   1,   3,
   4,   1,   6,   5 };
short yychk[]={

-1000,  -2,  -3,  -3,  -4,  -5,  -7,  -8,  -9, -10,
 -11, -12, -13, -14, -15, -16, -19, -21, -27, -28,
 -45, -52, -54, -24, -29, -46, -53, -55, -30, -47,
 -49,  -4,  -6, -66,-101, 323, 343, 343, 343, 343,
 343, 343, 343, -17, 297, -26, -57, -51, 282,-155,
-156, -58, -59, 309,-157,-158, 318, 315, 281, 300,
 276, 265, -25, -88, -17, -17, -25, 276, 265, 265,
 -25, 297, 286, -25, -25, -31, -32, -33, -34, 318,
 -37, -40,-123, 323, 314, -48, 340, -50, 340, 343,
 335, 337, -18, -97, -84, -98, -99, -73, -70, -75,
 -26, -61, -62,-100, -77, -66, 299, 323,-111,-110,
-112,-113,-114,-115,-116, -81,-117, -74, -71, 297,
 315, 298,-165,-166,-167, -78, -34,-121, -37,-128,
 310, -80, -72, -76,-129, 311, 282, 323, 266, 286,
 343, 297, 311, 300, 281, 337, 337, 340, -50, -48,
 323, -60,-191,-192, 323, 323, 321, 323,  -1, 323,
 321, -22,-204,-205,-206, 344,-207,-208, 292,-247,
-209,-210,-211,-212,-213,-248,-249,-250,-251,-252,
-253,-233,-234,-254,-214,-221,-227,-231,-238,-255,
 306, 283,-168, 301, 270,-235,-257,-216,-222,-228,
-236, 323, 279,-154, 257, 308,-218, 267,-237, -60,
-191,-192, 284, 259, 265, -89, -90, -91, 280, -95,
 -67,-103,-104, -85, -26, -68,-105, 297, 311, -86,
 -69,-106, -87, -18, 265,  -1, -22, -22, 323, -33,
 343, 286, -26, 340,-124,-125, 340, 335, 337, 323,
-160,-162, 323, 306,-159,-161, 323, -17, 278,-101,
 323, 276, 343, -17, 305, 337, 335, 337, -17, -17,
 323, -60, 323, 286,-122,-138,-139, 292,-140,-142,
-141, 267, 323, 340, 341, 337, 323, 286, -31, 286,
-130, 323, 320, 314, 323, 286, 323, 266, 266, 323,
 323, 323, -60, -56, 323, 306, 336, 336, -23,-204,
-197,-198, 278, 343, 323, 276,-215,-217,-220,-219,
 274, 275, 276,-223,-224, 316, 276, 274, 294,-239,
-240,-241,-244,-242,-245, 265,-243, 317, 280, 269,
-256, 316, -36,-175,-176, -94,-179,-180,-182, 328,
 329, 291, 258,-184,-185, 320,-168,-186,-187, 340,
 -93, 324, 325, 292, 321,-154, 290,-188,-169, -60,
 334, -60, -94, 337, -22,-223,-229,-230, 316, 273,
 335, -60, 338, 336, 340,-168,-168, 313, -36, -48,
 336, 336, -36, 323, -22, -90, -93, 264, 340, -92,
 -60, 343, 286, 265, 265, 266, 266, 276, 265, -25,
 -25, -25, 276, -22, -23, -23, 286, 343, 299, 302,
 271, 260, 340, 263, 286, -38,-132, -43, -35, -60,
 341, 343,-126, 323, -41, -42, 285, -40, 341, 343,
 335, 337, -35, 341, 343, 335, 337, 305, 335,  -1,
 -36, -60,-107, -39, -43, 268,-109,-135, 263, -98,
 323, -18, -18, 286, 305, 340,-127, 260, 302, 290,
 303, 340, 287, 276,-139,-140, 343, 343,-143,-144,
-145, 316, 323, 335, 337, -38,-131,-133, -43,-118,
 -94,-154, -60,-130, 286, -79, -82, -83, 277, 297,
 -79, 323, 290, 286, 323, 323, 341, 336, -35,-189,
-190, 320, 323, 321,-189, 276,-199,-200, 316,-199,
 345, 284, 276, -22, 313, -36, 267, -22,-225, 295,
-226,-148, -43, -94,-118, 308, -22,-229,  -1, -22,
 -22, 288, -25, -36, 323, -36,-177, 262, 294, 319,
 322,-178,-181, 285, 291, 328, 329, 330,-183, 326,
 327, 289, 304,-179, 332,-175,-170, -36,-172, -94,
 295,-173,-174,-136, 323,-118, -35, 338, -43, 340,
-169, 341, 337, -36, 285,-168,-258, 294, 274,-231,
 312,-233, -36, -22,-193, 323,-190, 261,-194,-195,
-136,-118, -36,-196, -94, 323, 343, -22, 286, 261,
 261, -23, 343, -94, -94, 315, -96, 309, -22, -22,
 323, 323,  -1, -22,  -1, -23, 276, 276, 331, 331,
 -35, 331, 331, -36, 341, 337, 302,-126, 335, 337,
 -43, 296,-162,-163,-164, 296, 285, -43,-162,-161,
-164, 285,-161, -60, 278, -44,-108, 334, 305,-119,
-134,-137, 302, 340, -39,-108,-109, -43, -44, 340,
 335, 276, 276, 290, -60, -60, 299, -35,-120,-118,
 -94, -43, 303, 343, 276,-144, 342,-146, 295,-147,
-148, 286, -39,-141, 341, 341, 337, 302,-134, 339,
 338,-135, 276, -82, -48, 323, 323, 276, -20, -60,
 286, 286, 323,  -1, -22,-201, 295,-202,-203, -60,
 284, -22, 342, 333,-134, 276, 276, -23, 265,-246,
 285,-176, 313, 274, -94,-133, -43, -60,-179, 285,
-182,-184, 341, 337, 342, 333,-134,-137, 338, -36,
 341,-171, -36,-170,-168, -22, 276, 270, 343, 343,
 343, 342, 276, 340, 341, 337,-134, 342, 276, 343,
-102, -67, -73, -70, -75, -85,-104,-103, -62, -61,
 -77, -81, 297, -26, 311, -23, -23, 286, 286, -23,
 343, 276,  -1,  -1, 341, 293,-132, 331, -43,-126,
 -44, -43, -43, 296, -43, -44, -36,-168,-118,-149,
-150, -60, -43,-118, -36,-151,-191,-192,-152, 323,
 295,-153,-108,-108,-131,  -1,  -1, -20, 341, 337,
-119,-119, 267,-122, 333, -44, 293, 293,-133, -94,
 302,-193,  -1, 343, 286,  -1, 340, 342, 333,-148,
 308, 288, 276,-133, 307,-171, -36,-174, -94,-169,
 340, 341, 276, 308, -94,-232, -22,-232,  -1, -36,
-195, -36,  -1, 343, 323, 276, 276, 309, 309, 276,
  -1, -39, -44, -43, -44, 341, 337,-134, 336, 336,
 342, 333, 341, -60, 343,-148, -39, -39, -63, -64,
 -65, -36, 323, 321,-203, -36, 308, 343, 341,  -1,
  -1,  -1,-150, -36, 323, 293, 341, 337, 341, 337,
 342, 342, 341, -39, 321, -64, -36, -60, 341 };
short yydef[]={

   3,  -2,  -2,  -2,   1,   0,   5,   0,   0,   0,
   0,  10,   0,   0,   0, 124,   0,   0, 124, 124,
 124,   0,   0, 124,   0,   0, 124, 124,  28, 275,
 273,   2,   4,   0, 137,   0,   6,   7,   8,   9,
  11,  12,  13, 108,   0,  21,   0,   0,  27, 266,
 267,  67,  68,   0, 273, 275,   0,   0,   0,   0,
 459, 457,   0, 115, 122, 108,   0, 459, 457, 457,
  19,   0,  49,  56,  59,  26,  29,   0,   0,   0,
   0,  41, 188,   0,   0,  50,   0,   0,   0, 124,
   0,   0,   0,   0, 124, 126, 127, 128, 129, 130,
 131, 132, 133, 134, 135, 136, 110,   0, 173, 172,
 174, 175, 176, 177, 178, 179, 180, 124, 124,   0,
   0,   0, 290, 291, 292,  98, 199,   0,   0,   0,
   0, 102,  28,  99,   0,   0,  93,   0,   0,  23,
  66,   0,   0,   0,   0,   0,   0,   0,   0, 269,
  69,  71, 371, 372, 367, 270, 271, 272,  17, 460,
 461,  -2, 403, 405,   0,   0, 407, 408, 475, 476,
 409, 410, 411, 412, 413, 477, 478, 479, 480, 481,
 482, 483, 484, 485,   0,   0,   0, 449, 470, 489,
 491,   0, 498, 494,   0, 446, 457, 417,   0, 443,
 451, 367, 487, 373,   0, 439,   0,   0, 275, 375,
 371, 372,   0,   0, 457, 116, 117,   0,   0,   0,
 143, 144, 145, 146, 131,   0,   0,   0,   0,   0,
 124, 124, 124,   0, 457,  54,  -2,  -2,   0,   0,
  30,   0,  37,   0, 189,   0,   0,  44,   0, 190,
   0, 279,   0,   0,   0, 277,   0,  87, 139, 140,
   0, 459, 125, 109,   0,   0,   0,   0, 108, 108,
   0,  73,  75, 197,   0, 229, 230,   0,   0,   0,
 234,   0,   0,   0, 200,   0,   0,   0,   0,   0,
 201, 204, 205,   0,  97,  16,   0,   0,   0,  52,
  53,  70,  72,   0,  62,   0,   0,   0,   0, 404,
 392,   0, 395, 406,   0,   0,   0, 418, 457,   0,
 424,   0,   0, 427, 457,   0,   0, 457, 443, 459,
 462, 463, 457, 457,   0, 465, 124,   0,   0, 467,
 486,   0, 492, 314, 315, 317, 327,   0, 330, 332,
 333, 334, 335, 343, 345, 346, 347, 348, 349,   0,
 351, 352, 353, 354, 355, 373,   0,   0,   0, 493,
   0, 495, 445,   0, 457, 426, 437,   0,   0, 457,
 458, 488,   0,   0,   0, 447,   0, 457,   0, 452,
   0,   0, 420, 453,  -2, 118,   0,   0,   0,   0,
 370, 141,  90, 457, 457,   0,   0, 459, 457,  89,
 162, 113, 459,  -2,   0,   0,  25,  31,  32,   0,
   0,   0,   0, 208,   0,   0, 209,   0, 224, 223,
 191,   0, 192,   0,  42,   0,  45,  43, 276,   0,
   0,   0,  51, 274,   0,   0,   0,   0,   0,  14,
 294,  74, 164, 310, 219,   0, 310, 221,   0, 166,
   0,   0,   0,  96,   0,   0,   0,   0,   0,   0,
 187, 203, 198,   0, 228,   0, 231, 232,   0, 239,
   0,   0,   0,   0,   0,   0,   0, 212,   0, 214,
 215, 373,  -2, 202,   0,   0, 104, 275,   0,   0,
   0, 101,   0,  20,   0,   0,  61,   0, 268, 368,
 363, 364, 365, 366, 369, 459, 394, 457,   0, 393,
 414, 415,   0,  -2, 457, 422, 425,  -2,   0, 431,
 432, 433,   0, 248, 249, 435, 457, 438, 456, 457,
  -2, 469,   0, 471,   0, 490,   0, 320, 321, 322,
   0,   0,   0, 325,   0, 336, 337, 338,   0, 339,
 340, 341, 342, 328,   0, 314, 296,   0,   0,  -2,
 302, 303, 304,   0,  -2, 309, 225, 362, 357,   0,
   0, 313,   0, 497,   0, 448, 457,   0, 501,   0,
   0,   0,   0, 457,  -2, 382, 376, 379,   0, 384,
   0, 387, 388, 389, 317, 367, 499,  -2, 430, 377,
 378,   0, 120,   0,  -2, 119, 123, 159,  -2,  -2,
   0,   0, 111,  -2,   0,   0, 459, 459,  33,  34,
  35,   0,  38,  39,   0,   0,   0, 193,   0,   0,
 310,   0, 280, 281, 287,   0,   0, 310, 282, 278,
 283,   0, 284, 138, 139, 165, 311,   0,   0, 220,
 226, 227,   0,   0, 168, 169,   0, 219, 170,   0,
   0, 459, 459,   0, 295,   0, 196,  -2,   0, 181,
   0, 182, 186, 233,   0, 240,   0, 242, 243, 244,
 245, 238, 310, 236,   0,   0,   0,   0, 216,   0,
 362, 218, 459, 105,   0, 107,   0, 459,  15,  79,
  57,  60,  63,  18,  -2,   0, 398, 399, 400, 402,
 416,  -2, 429,   0, 247,   0,   0,   0, 466,   0,
 473, 316, 323, 324, 318, 319,   0,  -2, 329, 326,
 331, 344, 350,   0,   0,   0, 306, 356,   0,   0,
 361, 298, 299, 300, 496, 457,   0,   0,  -2, 441,
  -2, 444, 459,   0, 381,   0, 386,   0, 459, 121,
   0, 147, 148, 149, 150, 151, 152, 153, 154, 155,
 156, 157,   0,   0,   0,   0,   0, 114, 163,   0,
  24, 459,  55,  58,  36,   0, 210, 211, 310, 195,
  46,  47, 288,   0, 310, 285, 312, 293, 250,   0,
 252,  -2,   0, 256, 257, 258, 371, 372,   0,  -2,
 260, 261, 167, 171,   0,  94,  91,  95,  76,   0,
 185, 183,   0, 241,   0, 235,   0,   0, 213, 264,
 265,  -2, 103, 106,  92, 100,   0, 397,   0, 434,
 436, 468, 464, 472, 474, 297, 301, 305, 308, 358,
   0, 360,   0, 503,   0, 440,  -2, 442, 450,   0,
 385, 390,  22, 142,   0, 459, 459, 158, 160, 459,
  48,  40, 194, 289, 286, 251,   0, 255,   0,   0,
   0,   0,   0,   0, 237, 246, 206, 207,   0,  81,
  83,  84, 367, 355, 401,   0, 502, 500, 383,  88,
 161, 112, 253, 259, 263,   0,  77,   0,  80,   0,
   0,   0, 359, 217,   0,  82,  85,  86,  78 };
	/* @(#)veyaccpar	1.9	86/09/11 */
/*
 *	ERROR RECOVERY MODULE FOR YACC
 *
 *	Delft University of Technology
 */

/*
 *	The program consists of several "packages",
 *	each describing a datastructure.
 *
 *	The old YACC recovery is given as default
 */
#ifdef REPAIR

typedef	short	yyline_t;
yyline_t	rr_lino;

/*
 *	interface to the outside world
 */

#ifdef RRTRACE
/* intermediate "tracing" results will be written on:
 */
#define	TROUTFILE	"/tmp/troutfile"
#endif
static	int rr_errors = 0;
extern	short termfun ();	/* termination function, defined
				 * on the interval 0 .. maxq
				 */
extern	short rr_insert ();	/* defined over the set of terminals */
extern	short rr_skip    ();	/* defined over the set of terminals */


extern	short rr_bonus ();		/* constant function		     */


extern		syntax_error ();
extern	YYSTYPE	creat_val ();
extern		del_symbol ();
extern	char	*rr_token();
extern	yyline_t yylino ();

/*
 *	forward declarations:
 */
static	short	rrnext_tok ();
static	short	get_pf ();
static	short	push ();
static	short	get_wsymbol ();
static	long	Insert_cost ();
static	long	Delete_cost ();
static	long	Continuation();
static	short	pf_elems ();
static	short	win_elems ();
static		rr_repair ();
#ifdef RRTRACE
static	FILE	*rr_trcinit ();
#endif RRTRACE
static		rrtr_close ();


#define	ERRSIZE		1024
static	char	error_diag [ERRSIZE];
static	char	*err_ptr;

/*
 *	definitions:
 */
#define	min(a, b)	(a < b ? a : b)
#define	max(a, b)	(a < b ? b : a)
#define	INFINITE	32000
#define	ACCBONUS	00000
#define	MAXPOST		50
#define	MAXWIND		8
#define	MAXDOM		150
#endif REPAIR

/*
 *	We start just with the standard parser of YACC
 *	Take good care, the "semantic value stack" is
 *	made global here.
 */
# define YYFLAG -1000
# define YYERROR goto yyerrlab
# define YYACCEPT return(0)
# define YYABORT return(1)

/*	parser for yacc output	*/

int yydebug = 0; /* 1 for debugging */
YYSTYPE yyv[YYMAXDEPTH]; /* where the values are stored */
short   yys[YYMAXDEPTH];	/* parse stack */
short	*yyps;
YYSTYPE	*yypvt;
int yychar = -1; /* current input token number */
int yynerrs = 0;  /* number of errors */
short yyerrflag = 0;  /* error recovery flag */

yyparse() {

	short yyj, yym;
	register short yystate, yyn;
	register YYSTYPE *yypv;
	register short *yyxi;
#ifdef REPAIR
	init_input ();
#endif

	yystate = 0;
	yychar = -1;
	yynerrs = 0;
	yyerrflag = 0;
	yyps= &yys[-1];
	yypv= &yyv[-1];

 yystack:    /* put a state and value onto the stack */

	if (yydebug)
	   printf( "state %d, char 0%o\n", yystate, yychar);
	if (++yyps > &yys [YYMAXDEPTH])
	   yyerror ("Yacc stack overflow");
	*yyps = yystate;
	++yypv;
	*yypv = yyval;

 yynewstate:

	yyn = yypact[yystate];

	if( yyn<= YYFLAG ) goto yydefault; /* simple state */

	if (yychar < 0)
#ifdef REPAIR
	   if ((yychar = rrnext_tok ()) < 0)
#else
	   if ((yychar = yylex ()) < 0)
#endif
	      yychar = 0;
	if( (yyn += yychar)<0 || yyn >= YYLAST ) goto yydefault;

	if( yychk[ yyn=yyact[ yyn ] ] == yychar ){ /* valid shift */
		yychar = -1;
		yyval = yylval;
		yystate = yyn;
		if( yyerrflag > 0 ) --yyerrflag;
		goto yystack;
		}
 yydefault:
	/* default state action */

	if( (yyn=yydef[yystate]) == -2 ) {
	        if (yychar < 0)
#ifdef REPAIR
	           if ((yychar = rrnext_tok ()) < 0)
#else
		   if ((yychar = yylex ()) < 0)
#endif REPAIR
	              yychar = 0;
		/* look through exception table */

		for( yyxi=yyexca; (*yyxi!= (-1)) || (yyxi[1]!=yystate) ; yyxi += 2 ) ; /* VOID */

		while( *(yyxi+=2) >= 0 ){
			if( *yyxi == yychar ) break;
			}
#ifdef REPAIR
		if ((yyn = yyxi [1]) < 0)
				return rr_errors;
#else
		if ((yyn = yyxi [1]) < 0)
				YYACCEPT;
#endif REPAIR
		}

	if( yyn == 0 ) /* error */
#ifndef REPAIR
	{	/* let YACC clear the mess */
		/* error ... attempt to resume parsing */

		switch( yyerrflag ){

		case 0:   /* brand new error */

			yyerror( "syntax error" );
		yyerrlab:
			++yynerrs;

		case 1:
		case 2: /* incompletely recovered error ... try again */

			yyerrflag = 3;

			/* find a state where "error" is a legal shift action */

			while ( yyps >= yys ) {
			   yyn = yypact[*yyps] + YYERRCODE;
			   if( yyn>= 0 && yyn < YYLAST && yychk[yyact[yyn]] == YYERRCODE ){
			      yystate = yyact[yyn];  /* simulate a shift of "error" */
			      goto yystack;
			      }
			   yyn = yypact[*yyps];

			   /* the current yyps has no shift onn "error", pop stack */

			   if( yydebug ) printf( "error recovery pops state %d, uncovers %d\n", *yyps, yyps[-1] );
			   --yyps;
			   --yypv;
			   }

			/* there is no state on the stack with an error shift ... abort */

	yyabort:
			return(1);


		case 3:  /* no shift yet; clobber input char */

			if( yydebug ) printf( "error recovery discards char %d\n", yychar );

			if( yychar == 0 ) goto yyabort; /* don't discard EOF, quit */
			yychar = -1;
			goto yynewstate;   /* try again in the same state */

			}

		}
#else
	/* now the new one: */
	/* we know the context of the parse, it's all global */
	{
#ifdef RRTRACE
	   FILE *rrfp;
#endif RRTRACE
	   rr_errors ++;
#ifdef RRTRACE
	   rrfp = rr_trcinit ();
	   fprintf (rrfp, "Syntax error (%d, %d)\n\n", yystate, yychar);
#endif RRTRACE

#ifdef RRTRACE
	   rr_repair (rrfp);	/* he does them all */
	   rrtr_close (rrfp);
#else
	   rr_repair ();
#endif RRTRACE
	   yychar = -1;		/* start fresh*/
	   goto yynewstate;	/* only the input has been changed */
	}
#endif REPAIR

	/* reduction by production yyn */

	if (yydebug)
	   printf ("reduce %d\n", yyn);
	yyps -= yyr2[yyn];
	yypvt = yypv;
	yypv -= yyr2[yyn];
	yyval = yypv[1];
	yym=yyn;
		/* consult goto table to find next state */
	yyn = yyr1[yyn];
	yyj = yypgo[yyn] + *yyps + 1;
	if (yyj >= YYLAST ||
	    yychk [yystate = yyact [yyj]] != -yyn)
	    yystate = yyact [yypgo [yyn]];

#ifdef REPAIR
	if (rr_errors == 0)
	   YYreduce (yym);
#else
	YYreduce (yym);
#endif REPAIR
	goto yystack;  /* stack new state and value */

	}
/*
 *	The remaining code is almost all for repair
 */
#ifdef REPAIR




/*
 *	During repair we need from time to time some kind of
 *	a parse stack to parse a piece. The stack is 
 *	a structure:
 */
struct rrparstack {
	short C_top;
	short C_data [YYMAXDEPTH];
};

typedef	struct rrparstack	rrps;
static init_stk (ps)
register rrps	*ps;
{
	ps -> C_top = 0;
}

static	short push (ps, val)
register rrps *ps;
register short  val;
{
	ps -> C_top ++;
	ps -> C_data [ps -> C_top] = val;
}
static ps_init (ps)
register rrps *ps;
{
	register short *ls;
	register short i;

	init_stk (ps);
	for (ls = &yys [0]; ls != yyps; ls ++)
	    push (ps, *ls);
	/* and another one:
	 */
	push (ps, *ls);
}

static cp_stack (x, y)
register rrps *x, *y;
{
	register int i;

	for (i = 1; i <= x -> C_top; i++)
	    y -> C_data [i] = x -> C_data [i];

	y -> C_top = x -> C_top;
}


static rr_pop (ps, amount)
register rrps *ps;
register short amount;
{
	ps -> C_top -= amount;
}

static short top_of (ps)
register rrps *ps;
{
	return ps -> C_data [ps -> C_top];
}
/*
 *	end of stack module, treat rrps from now as a limited private
 *	type
 */


/*
 *	after the repair the transformed input is stored in a
 *	lookahead structure
 */
struct rr_inp {
	short inp;
	short rp;
	struct {
		short inpdata;
		YYSTYPE inplexv;
		yyline_t inplino;
	} inpsequence [MAXPOST + MAXWIND];
};

typedef struct rr_inp restinput;
restinput lookah;

static init_input ()
{
	lookah. inp = 0;
	lookah. rp  = 0;
}

static add_input (sym, lexval, lino)
short sym;
YYSTYPE	lexval;
yyline_t lino;
{
	lookah. inpsequence [lookah. inp]. inpdata = sym;
	lookah. inpsequence [lookah. inp]. inplexv = lexval;
	lookah. inpsequence [lookah. inp]. inplino = lino;
	lookah. inp ++;
}

static short emp_las ()
{
	return lookah. rp >= lookah. inp;
}

static next_las (a_sym, a_lex, a_lino)
short *a_sym;
YYSTYPE *a_lex;
yyline_t *a_lino;
{
	*a_sym = lookah. inpsequence [lookah. rp]. inpdata;
	*a_lex = lookah. inpsequence [lookah. rp]. inplexv;
	*a_lino = lookah. inpsequence [lookah. rp]. inplino;
	lookah. rp ++;
}

static short rrnext_tok ()
{
	short x;

	if (emp_las ()) {
	   x = yylex ();
	   rr_lino = (yyline_t) yylino ();
	}
	else {
		next_las (&x, &yylval, &rr_lino);
	}
	return x;
}

/*
 *	Window management:
 *
 *	On encountering an error a window is read in with
 *	symbols from the right context
 *
 *	All functions and datastructures operating on
 *	the implementation of the window are given here
 */
struct win_l {
	int win_size;		/* actual window size */
	struct {
		short win_symbol;	/* actual symbol */
		YYSTYPE win_lexval;	/* "value"       */
		yyline_t win_lino;
	} symbols [MAXWIND];
};

typedef struct win_l	rrwindow;

init_window (window)
rrwindow *window;
{
	window-> win_size = 0;
}

static short win_elems (window)
rrwindow *window;
{
	return window -> win_size;
}

add_window (window, x, y, lino)
rrwindow *window;
short x;
YYSTYPE y;
yyline_t lino;
{
	if (window -> win_size >= MAXWIND)
	   yyerror ("Window overflow, should not happen");

	window -> symbols [window -> win_size]. win_symbol = x;
	window -> symbols [window -> win_size]. win_lexval = y;
	window -> symbols [window -> win_size]. win_lino = lino;
	window -> win_size ++;
}

static short
win_ful (window)
rrwindow *window;
{
	return window -> win_size >= MAXWIND;
}

static short get_wsymbol (window, i)
rrwindow *window;
short i;
{
	return window -> symbols [i - 1]. win_symbol;
}

YYSTYPE
get_wlexval (window, i)
rrwindow *window;
short i;
{
	return window -> symbols [i - 1]. win_lexval;
}

fill_window (window)
rrwindow *window;
{
	register short i;

	init_window (window);
	add_window (window, yychar, yylval, rr_lino);
	while (!win_ful (window) && yychar != 0)
	{ yychar = rrnext_tok ();
	  add_window (window, yychar, yylval, rr_lino);
	}
}

/*
 *	the postfix.
 *	An yylval must be added explicitly for each token that will
 *	be used in the repair.  This way creat_val () is not called
 *	for tokens that won't be used after all.
 */
struct postfix {
	short n_pf;
	struct {
		short	p_lex;			/* the yylex */
		YYSTYPE	p_lval;			/* and yylval */
	} rc_list [MAXPOST];
};

typedef struct postfix rrpf;

init_pf (pf)
register rrpf *pf;
{
	pf -> n_pf = 0;
}

add_pf (pf, x)
register rrpf *pf;
short x;
{
	if (pf -> n_pf >= MAXPOST)
	   yyerror ("Postfix overflow");

	pf -> rc_list [pf -> n_pf ++]. p_lex = x;
}

static short get_pf (pf, i)
register rrpf *pf;
short i;
{
	return pf -> rc_list [i - 1]. p_lex;
}

static short pf_elems (pf)
register rrpf *pf;
{
	return pf -> n_pf;
}

static set_pf_lval (pf, i, lval)
register rrpf *pf;
short i;
YYSTYPE lval;
{
	pf -> rc_list [i - 1]. p_lval = lval;
}

static YYSTYPE pf_lval (pf, i)
register rrpf *pf;
short i;
{
	return pf -> rc_list [i - 1]. p_lval;
}

/*
 *	The next routine does exactly one parse step
 *	i.e. a step
 *
 *	[q0 ... qn, s ...] |- ...
 *
 *	The transition that is made is given as result
 *	value, one of:
 */
#define	RRSHIFT		1
#define	RRREDUCE	2
#define	RRACCEPT	3
#define	RRERROR		4

static short parse_step (pstack, symb)
register rrps *pstack;
short symb;
{
	short rrn, rrstate;
	short rrm, rrj, *rrxi;

	rrstate = top_of (pstack);
#ifdef PARSETRACE
	printf ("doing a parse step d (%d, %o)\n", rrstate, symb);
#endif PARSETRACE
	rrn = yypact [rrstate];

	if (rrn < YYFLAG)
	   goto rrdefault;

	if ((rrn += symb) < 0 || rrn >= YYLAST)
	   goto rrdefault;

	if (yychk [rrn = yyact [rrn]] == symb)
	   { push (pstack, rrn);
	     return RRSHIFT;
	   }

rrdefault:
	if ((rrn = yydef [rrstate]) == -2)
	{
	   if (symb < 0) symb = 0;
	   for (rrxi = yyexca;
	        (*rrxi != (-1) || (rrxi [1] != rrstate));
	        rrxi += 2 );	/* VOID */

	   while ( *(rrxi += 2) >= 0)
	         if (*rrxi == symb)
	            break;

	   if ( (rrn = rrxi [1]) < 0) return RRACCEPT;
	}

	if (rrn == 0)
	   return RRERROR;

	/* reduction */
	rr_pop (pstack, yyr2 [rrn]);


	rrm = rrn;
	rrn = yyr1 [rrn];
	rrj = yypgo [rrn] + top_of (pstack) + 1;

	if (rrj >= YYLAST ||
	    yychk [rrstate = yyact [rrj]] != -rrn)
	   rrstate = yyact [yypgo [rrn]];

	push (pstack, rrstate);
	return RRREDUCE;
}

/*
 *	The actual repair is a transformation over
 *	a window and a "context". The latter being
 *	a private structure
 */
struct rrct {
	rrwindow	s_win;
	rrpf	s_pf;
	rrps	s_ps;
};

typedef struct rrct	rrcontext;

static
#ifdef RRTRACE
rr_repair (rrfp)
FILE *rrfp;
#else
rr_repair ()
#endif RRTRACE
{
	rrcontext context;
	register rrcontext *x = &context;
	short i;
	long t1, t2, t3;
	long tt;
	short s;
	short pfi;
	short win;
	int old_min = INFINITE;

	ps_init (&x -> s_ps);
	init_pf (&x -> s_pf);
	fill_window (&x -> s_win);

#ifdef RRTRACE
	fprintf (rrfp, "pf_index\twinindex\tstate\tsymbol\tdelcos\tinsco\tcon\n\n");
#endif RRTRACE
	/* for all insertions and all deletions find minimum cost */
	do {
	   for (i = 1; i <= win_elems (&x -> s_win); i++)
	   {
	      s = get_wsymbol (&x -> s_win, (short)i);
	      if (is_valid (&x -> s_ps, s))
		 { t1 = Delete_cost (&x -> s_win, i);
		   t2 = Insert_cost (&x -> s_pf);
		   t3 = Continuation (&x -> s_ps, &x -> s_win, i);
		   tt = t1 + t2 - t3;
#ifdef RRTRACE
		fprintf (rrfp, "%d\t\t%d\t\t%d\t%d\t%d\t%d\t%d\n",
				pf_elems (&x -> s_pf),
				i,
				top_of (&x -> s_ps),
				s,
				t1,
				t2,
				t3);
#endif RRTRACE
		   if (tt < old_min)
	              { old_min = tt;
		        pfi = pf_elems (&x -> s_pf);
		        win = i;
	              }
	         }
	   }
	} while (do_t_shift (x) != RRACCEPT);

/*
 *	Now start with the repair
 */
	if (old_min == INFINITE)
		yyerror ("did not find feasible repair; goodbye");

	init_input ();
	for (i = 1; i <= pfi; i ++) {
		set_pf_lval (&x -> s_pf, i, creat_val (get_pf (&x -> s_pf, i)));
		add_input (get_pf (&x -> s_pf, i), pf_lval (&x -> s_pf, i), -1);
	}
	for (i = pfi + 1; i < win; i ++)
	    {
	       del_symbol (get_wlexval (&x -> s_win, i));
	    }

	for (i = win; i <= win_elems (&x -> s_win); i ++)
	   {
	      add_input (get_wsymbol (&x -> s_win, (short)i),
	                 get_wlexval (&x -> s_win, i));
#ifdef RRTRACE
	      fprintf (rrfp, "window %o\n",
				get_wsymbol (&x -> s_win, (short)i));
#endif RRTRACE
	   }
	set_error_diag (x, win, pfi);
	syntax_error (top_of (&x -> s_ps), (int) rr_lino, error_diag);

#ifdef RRTRACE
	fprintf (rrfp, "repair %s\n", error_diag);
#endif RRTRACE
}

do_t_shift (x)
rrcontext *x;
{
	short t;
	short sym;

	do {
		sym = termfun (top_of (&x -> s_ps));
	        t = parse_step (&x -> s_ps, sym);
	} while (t == RRREDUCE);
	add_pf (&x -> s_pf, sym);
	return t;
}

int
is_valid (x, y)
rrps *x;
short y;
{
	rrps local_stack;
	short t;

	cp_stack (x, &local_stack);

	do {
	      t = parse_step (&local_stack, y);
	} while (t == RRREDUCE);

	return t != RRERROR;
}

static long
Delete_cost (window, i)
rrwindow *window;
short i;
{
	short j;

	long sum = 0;
	for (j = 1; j <= i; j ++)
	    sum += rr_skip (get_wsymbol (window, j), j);

	return sum;
}

static long
Insert_cost (pf)
rrpf *pf;
{
	short i;
	long sum = 0;

	for (i = 1; i <= pf_elems (pf); i++)
	    sum += rr_insert (get_pf (pf, i), i);

	return sum;
}

static long
Continuation (x, y, i)
rrps *x;
rrwindow *y;
short i;
{
	rrps localstack;
	short pos = 1;
	short sym;
	int t;
	int sum = 0;

	cp_stack (x, &localstack);
	while (1)
	{
	    sym = get_wsymbol (y, i);
	    t = parse_step (&localstack, sym);
	    while (t == RRREDUCE)
	          t = parse_step (&localstack, sym);

	    if (t == RRERROR)
	       return sum;
	    sum += rr_bonus (sym, pos);
	    i ++; pos ++;
	}
}

static err_reset ()
{
	err_ptr = error_diag;
	err_ptr[0] = '\0';
}

static err_concat (s)
register char *s;
{
	while (*err_ptr++ = *s++)
		;
	err_ptr--;
}

set_error_diag (x, win, pfi)
register rrcontext *x;
register short win;
register short pfi;
{
	register short i;

	err_reset ();
	if (win == 1) {
		err_concat ("inserted `");
		for (i = 1; i <= pfi; i++) {
			err_concat (rr_token (get_pf (&x -> s_pf, i),
				pf_lval (&x -> s_pf, i)));
			if (i != pfi) {
				err_concat (" ");
			}
		}
	}
	else if (pfi == 0) {
		err_concat ("deleted `");
		for (i = 1; i < win; i++) {
			err_concat (rr_token (
				get_wsymbol (&x -> s_win, i),
					get_wlexval (&x -> s_win, i)));
			if (i != win - 1) {
				err_concat (" ");
			}
		}
	}
	else {
		err_concat ("replaced `");
		for (i = 1; i < win; i++) {
			err_concat (rr_token (
				get_wsymbol (&x -> s_win, i),
					get_wlexval (&x -> s_win, i)));
			if (i != win - 1) {
				err_concat (" ");
			}
		}
		err_concat ("' with `");
		for (i = 1; i <= pfi; i++) {
			err_concat (rr_token (get_pf (&x -> s_pf, i),
				pf_lval (&x -> s_pf, i)));
			if (i != pfi) {
				err_concat (" ");
			}
		}
	}
	err_concat ("'");
}

#ifdef RRTRACE
rr_trce (rrpf)
FILE *rrpf;
{
}

static
FILE *rr_trcinit ()
{
	FILE *ff;
	long tvec [4];

	ff = fopen (TROUTFILE, "a");
	if (ff == NULL)
	   yyerror ("Cannot open tracefile ");

	fprintf (ff, "\f Error repair attempt :");
	time (tvec);
	fprintf (ff, "  TIME %s\n\n", ctime (tvec));
/*
 *	give the user the opportunity to write the source file
 */
	rr_usermess (ff);
	fprintf (ff, "\f");
	return ff;
}

static rrtr_close (ff)
FILE *ff;
{
	fprintf ("\f end of Repair attempt\n");
	fclose (ff);
}
#endif RRTRACE

/*
 *	that's all folks
 */

#endif REPAIR
/*
 *	The user is interested in doing actions on
 *	reductions:
 *	YACC will include a large case statement
 *	somewhere here
 */
YYreduce (x)
short x;
{
	switch (x) {
	
case 3:
# line 384 "1A00.attrib"
{{ IInit ();
		  s_add (":#sf:%s", m_prog);
		}
} break;
case 4:
# line 389 "1A00.attrib"
{{ /* package standard !!!!		*/
	          generate_code (mainlun, NULL, _ap [0]. _t2, SPEC, errors);
		
	_ap += 1;
	}
} break;
case 5:
# line 393 "1A00.attrib"
{{ generate_code (mainlun, _ap [1]. _t2, _ap [2]. _t2, _ap [0]. _t3, errors);
	        
	_ap += 3;
	}
} break;
case 6:
# line 398 "1A00.attrib"
{ int _L3L_;
{ _L3L_ = SPEC;
		  s_d_add (":#kd:PS:%s:%d", g_tag (_ap [1]. _t2), mainlun);
		
	_ap += -1;
_ap [0]. _t3 =_L3L_;
	}
} break;
case 7:
# line 402 "1A00.attrib"
{ int _L3L_;
{ _L3L_ = XBODY;
                  if (is_generic (g_specif (_ap [1]. _t2))) {
		     _L3L_ =  GEN | _L3L_;
                     s_d_add (":#kd:GPB:%s:%d", g_tag (_ap [1]. _t2), mainlun);
		  }
                  else
		     s_d_add (":#kd:PB:%s:%d", g_tag (_ap [1]. _t2), mainlun);
		
	_ap += -1;
_ap [0]. _t3 =_L3L_;
	}
} break;
case 8:
# line 411 "1A00.attrib"
{ int _L3L_;
{ _L3L_ = SPEC;
		  s_d_add (":#kd:SS:%s:%d", g_tag (_ap [1]. _t2), mainlun);
		
	_ap += -1;
_ap [0]. _t3 =_L3L_;
	}
} break;
case 9:
# line 415 "1A00.attrib"
{ int _L3L_;
{ _L3L_ = XBODY;
		  s_d_add (":#kd:SB:%s:%d", g_tag (_ap [1]. _t2), mainlun);
		
	_ap += -1;
_ap [0]. _t3 =_L3L_;
	}
} break;
case 10:
# line 419 "1A00.attrib"
{ int _L3L_;
{ _L3L_ = GEN | SPEC;
		  s_d_add (":#kd:GPS:%s:%d", g_tag (_ap [1]. _t2), mainlun);
		
	_ap += -1;
_ap [0]. _t3 =_L3L_;
	}
} break;
case 11:
# line 423 "1A00.attrib"
{ int _L3L_;
{ _L3L_ = XBODY;
		  s_d_add (":#kd:SUS:%s:%d", procname (_ap [1]. _t2), mainlun);
		
	_ap += -1;
_ap [0]. _t3 =_L3L_;
	}
} break;
case 12:
# line 427 "1A00.attrib"
{ int _L3L_;
{ _L3L_ = XBODY;
		  s_d_add (":#kd:SUP:%s:%d", procname (_ap [1]. _t2), mainlun);
		
	_ap += -1;
_ap [0]. _t3 =_L3L_;
	}
} break;
case 13:
# line 431 "1A00.attrib"
{ int _L3L_;
{ _L3L_ = XBODY;
		  s_d_add (":#kd:SUS:%s:%d", procname (_ap [1]. _t2), mainlun);
		
	_ap += -1;
_ap [0]. _t3 =_L3L_;
	}
} break;
case 14:
# line 437 "1A00.attrib"
{{ DELSCOPE (_ap [2]. _t2, _ap [0]. _t2);
		  CHECK_OPTIDENT (g_tag (_ap [2]. _t2), yypvt[-0].p_char, "%s in unbalance %s");
		  DECL_CHECK (FALSE, _ap [2]. _t2, "erroneous declaration in %s");
		  del_optid (yypvt[-0].p_char);
		
	_ap += 1;
	}
} break;
case 15:
# line 443 "1A00.attrib"
{ ac _L1L_;
 ac _L2L_;
{ ac t = instantiate (yypvt[-3].p_char, _ap [0]. _t2);
		  _L2L_ = _ap [2]. _t2;
		  _L1L_ = t;
		
	_ap += 1;
_ap [1]. _t2 =_L1L_;
_ap [0]. _t2 =_L2L_;
	}
} break;
case 16:
# line 450 "1A00.attrib"
{ ac _L1L_;
 ac _L2L_;
 ac _L3L_;
{ _L1L_ = mk_package (yypvt[-1].p_char);
		  _L2L_ = _ap [1]. _t2;
		  OBJDECL (_L1L_, "package id %s not unique");
		  _L3L_ = NEWSCOPE (_L1L_);
		
	_ap += -1;
_ap [2]. _t2 =_L1L_;
_ap [1]. _t2 =_L2L_;
_ap [0]. _t2 =_L3L_;
	}
} break;
case 17:
# line 458 "1A00.attrib"
{{ DELSCOPE (_ap [2]. _t2, _ap [0]. _t2);
		  CHECK_OPTIDENT (g_tag (_ap [2]. _t2), yypvt[-0].p_char, "%s in unbalance");
		  del_optid (yypvt[-0].p_char);
		
	_ap += 1;
	}
} break;
case 18:
# line 464 "1A00.attrib"
{{ DELSCOPE (_ap [5]. _t2, _ap [3]. _t2);
		  CHECK_OPTIDENT (g_tag (_ap [5]. _t2), yypvt[-0].p_char, "unbalance in %s");
		  s_PB_stats (_ap [5]. _t2, _ap [2]. _t2);
		  s_PB_exh   (_ap [5]. _t2, _ap [0]. _t2);
		  del_optid  (yypvt[-0].p_char);
		
	_ap += 4;
	}
} break;
case 19:
# line 473 "1A00.attrib"
{{ DECL_CHECK (TRUE, _ap [2]. _t2, 
		              "declaration in %s or its specification incomplete");
		
	}
} break;
case 20:
# line 479 "1A00.attrib"
{ ac _L1L_;
 ac _L2L_;
 ac _L3L_;
{ ac t, y;
		  struct lib_unit *r;
		  r = read_tree (yypvt[-1].p_char, SPEC);
		  if (r == (struct lib_unit *)NULL) {
		     error ("Cannot locate package %s", yypvt[-1].p_char);
		     exit (111);
		  }
		  withprocess (r);
		  OBJDECL (r -> unit, "Cannot happen");
		  t = mk_with (r -> unit, g_tag (r -> unit));
		  if (_ap [0]. _t2 == NULL)
		     _ap [1]. _t2 = t;
		  else
		     s_next (_ap [0]. _t2, t);

		  say_start ("package body", yypvt[-1].p_char);
		  if (is_instantiated (packspec (r -> unit))) {
		     error ("Package %s instantiated before elaboration of body\n",
			                            yypvt[-1].p_char);
		  }
		  _L1L_ = mk_pbody (yypvt[-1].p_char, packspec (r -> unit));
		  introduce (_L1L_);
		  _L3L_ = NEWSCOPE (_L1L_);
		  _L2L_ = _ap [1]. _t2;
		
	_ap += -1;
_ap [2]. _t2 =_L1L_;
_ap [1]. _t2 =_L2L_;
_ap [0]. _t2 =_L3L_;
	}
} break;
case 21:
# line 507 "1A00.attrib"
{ ac _L1L_;
 ac _L2L_;
{ _L1L_ = _ap [0]. _t2;
		  _L2L_ = _ap [2]. _t2;
		  say_start ("sub program specification %s\n", g_tag (_ap [0]. _t2));
		  chk_6_7_4 (_ap [0]. _t2);
		
	_ap += 1;
_ap [1]. _t2 =_L1L_;
_ap [0]. _t2 =_L2L_;
	}
} break;
case 22:
# line 516 "1A00.attrib"
{{ DECL_CHECK (TRUE, _ap [5]. _t2, "incomplete decls (%s)");
		  CHECK_OPTIDENT (g_tag (_ap [5]. _t2), yypvt[-0].p_char, "unbalance in %s");
		  s_SBB_stats (_ap [5]. _t2, _ap [2]. _t2);
		  s_SBB_exh   (_ap [5]. _t2, _ap [0]. _t2);
		  DELSCOPE    (_ap [5]. _t2, _ap [3]. _t2);
		  del_optid   (yypvt[-0].p_char);
		
	_ap += 4;
	}
} break;
case 23:
# line 526 "1A00.attrib"
{ ac _L1L_;
 ac _L2L_;
 ac _L3L_;
{ struct lib_unit *t;
		  int status = TRUE;

		  chk_6_7_4 (_ap [0]. _t2);
		  say_start ("subprogram body", g_tag (_ap [0]. _t2));
		  t = read_tree (g_tag (_ap [0]. _t2), SPEC);
		  if (t == NULL) {
		     SUBDECL (_ap [0]. _t2);
		     s_d_add (":#kd:SS:%s:%d", g_tag (_ap [0]. _t2), mainlun);
		     generate_code (mainlun, _ap [2]. _t2, _ap [0]. _t2, SPEC, errors);

		     mainlun = (int)get_cun (&status);
		     if (!status) {
		        fail ((short)mainlun, &status);
		        exit (111);
		     }
		     new_lun (mainlun); in_antag ();
		   /* The body only has to refer to its spec in the with list */
		     _L2L_ = mk_with (_ap [0]. _t2, g_tag (_ap [0]. _t2));
		     _L1L_ = mk_sbody (mk_tag (g_tag (_ap [0]. _t2), IDL), _ap [0]. _t2);
		     introduce (_L1L_);
		     _L3L_ = NEWSCOPE (_L1L_);
		  }
		  else
		  {  if ((g_d (t -> unit) != XSUB) ||
		        (!eq_subs (t -> unit, _ap [0]. _t2, TRUE, TRUE)) ) {
		         error ("Non-sub or non-matching sub (%s) in lib\n",
	                                         g_tag (_ap [0]. _t2)    );
		         exit (22);
		     }
		     withprocess (t);
		     _L2L_ = mk_with (t -> unit, g_tag (_ap [0]. _t2));
		     s_next (_L2L_, _ap [2]. _t2);
		     SUBDECL (t -> unit);
		     _L1L_ = mk_sbody (mk_tag (g_tag (_ap [0]. _t2), IDL), t -> unit);
		     introduce (_L1L_);
		     _L3L_ = NEWSCOPE (_L1L_);
		  }
		
_ap [2]. _t2 =_L1L_;
_ap [1]. _t2 =_L2L_;
_ap [0]. _t2 =_L3L_;
	}
} break;
case 24:
# line 568 "1A00.attrib"
{{ DELSCOPE (_ap [2]. _t2, _ap [0]. _t2);
		  DELSCOPE (_ap [4]. _t2, _ap [1]. _t2);
		  OBJDECL (_ap [4]. _t2, "generic package not unique %s");
		  CHECK_OPTIDENT (g_tag (_ap [2]. _t2), yypvt[-1].p_char, "%s in unbalance");
		  DECL_CHECK (FALSE, _ap [2]. _t2, "erroneous declaration in %s");
		  del_optid (yypvt[-1].p_char);
		
	_ap += 3;
	}
} break;
case 25:
# line 578 "1A00.attrib"
{ ac _L5L_;
{ _ap [1]. _t2 = mk_package (yypvt[-1].p_char);
		  s_tag (_ap [3]. _t2, mk_tag (yypvt[-1].p_char, IDL));
		  set_generic (_ap [1]. _t2);
		  say_start ("generic package", yypvt[-1].p_char);
		  s_genunit (_ap [3]. _t2, _ap [1]. _t2);
		  add_def (_ap [1]. _t2);
		  _L5L_ = NEWSCOPE (_ap [1]. _t2);
		
	_ap += -1;
_ap [0]. _t2 =_L5L_;
	}
} break;
case 27:
# line 592 "1A00.attrib"
{ ac _L1L_;
 ac _L2L_;
 ac _L3L_;
 ac _L4L_;
{ _L1L_ = mk_generic ();
		  _L2L_ = _ap [1]. _t2;
		  _L3L_ = NULL;	/* the tree	*/
		  say_start ("generic compilation unit", " ");
		  _L4L_ = NEWSCOPE (_L1L_);
		
	_ap += -2;
_ap [3]. _t2 =_L1L_;
_ap [2]. _t2 =_L2L_;
_ap [1]. _t2 =_L3L_;
_ap [0]. _t2 =_L4L_;
	}
} break;
case 32:
# line 606 "1A00.attrib"
{{ ac t = mk_genpartype (_ap [1]. _t4, GENPRIVTYPE);
		  OBJDECL (t, "%s declared more than once");
		  set_genpar (t);
		
	_ap += 2;
	}
} break;
case 33:
# line 611 "1A00.attrib"
{{ ac t = mk_genpartype (_ap [1]. _t4, NEWINTTYPE);
		  if (_ap [0]. _t2 != NULL) {
		     error ("illegal discriminants in generic parameter %s\n",
							_ap [1]. _t4);
		  }
		  OBJDECL (t, "%s declared more than once");
		  set_genpar (t);
		
	_ap += 2;
	}
} break;
case 34:
# line 620 "1A00.attrib"
{{ ac t = mk_genpartype (_ap [1]. _t4, NEWFLOATTYPE);
		  if (_ap [0]. _t2 != NULL) {
		      error ("Illegal discriminants in generic parameter %s\n",
							_ap [1]. _t4);
		  }
		  OBJDECL (t, "%s declared more than once");
		  set_genpar (t);
		
	_ap += 2;
	}
} break;
case 35:
# line 629 "1A00.attrib"
{{ ac t;
		  t = mk_acctype (_ap [2]. _t4, _ap [0]. _t2);
		  PREDECL (t);
		  NO_DISCRS (_ap [1]. _t2, g_tag (t),
                       "illegal discriminants for %s (parameter in generic)");
		  set_genpar (t);
		
	_ap += 3;
	}
} break;
case 36:
# line 637 "1A00.attrib"
{{ ac t = mk_genpartype (_ap [1]. _t4, SCALARTYPE);
		  NO_DISCRS (_ap [0]. _t2, _ap [1]. _t4,
                          "illegal discriminants in generic param %s");
		  OBJDECL (t, "%s (generic parameter) declared more than once");
		  set_genpar (t);
		
	_ap += 2;
	}
} break;
case 37:
# line 644 "1A00.attrib"
{{ SUBDECL (_ap [0]. _t2);
		  set_genpar (_ap [0]. _t2);
		  chk_6_7_4 (_ap [0]. _t2);
		
	_ap += 1;
	}
} break;
case 38:
# line 649 "1A00.attrib"
{{ SUBDECL (_ap [0]. _t2);
		  set_genpar (_ap [0]. _t2);
		  set_sdefault (_ap [0]. _t2);
		  chk_6_7_4 (_ap [0]. _t2);
		
	_ap += 1;
	}
} break;
case 39:
# line 655 "1A00.attrib"
{{ ac f;
		  chk_6_7_4 (_ap [1]. _t2);
		  SUBDECL (_ap [1]. _t2);
		  set_genpar (_ap [1]. _t2);
		  _ap [0]. _t2 = bu_expr (_ap [0]. _t2);
		  if (_ap [0]. _t2 == NULL) {
		     error ("Error in subprogram default %s\n", g_tag (_ap [1]. _t2));
		  }
		  else
		  { f = FIND_RENAMEDSUBS (_ap [1]. _t2, g_primary (_ap [0]. _t2),
		               "Error in subprogram default %s");
		    s_sub_default (_ap [1]. _t2, f);
		  }
		
	_ap += 2;
	}
} break;
case 40:
# line 670 "1A00.attrib"
{{ ac t;
		  _ap [0]. _t2 = CONST_TYPE (_ap [0]. _t2, _ap [3]. _t4,
                               "Unvalid array element for parameter %s");
		  t = mk_array (_ap [3]. _t4, _ap [2]. _t2, _ap [0]. _t2);
		  PREDECL (t);
		  set_genpar (_ap [0]. _t2);
		
	_ap += 4;
	}
} break;
case 41:
# line 678 "1A00.attrib"
{{ LIST_INTRO (_ap [2]. _t2, "generic parameter %s not unique");
		
	_ap += 3;
	}
} break;
case 42:
# line 683 "1A00.attrib"
{ ac _L1L_;
 int _L2L_;
 ac _L3L_;
{ ac t = mk_object (yypvt[-2].p_char, _ap [0]. _t2);
		  _L2L_ = 1;
		  _L3L_ = _ap [0]. _t2;
		  _L1L_ = t;
		
	_ap += -2;
_ap [2]. _t2 =_L1L_;
_ap [1]. _t3 =_L2L_;
_ap [0]. _t2 =_L3L_;
	}
} break;
case 43:
# line 689 "1A00.attrib"
{{ ac t = mk_object (yypvt[-2].p_char, cp_tree (_ap [0]. _t2));
		  set_genpar (t);
		  _ap [1]. _t3 += 1;
		  s_next (t, _ap [2]. _t2);
		  _ap [2]. _t2 = t;
		
	}
} break;
case 46:
# line 701 "1A00.attrib"
{ ac _L1L_;
{ _ap [0]. _t2 = SOLVE_EXPR (_ap [0]. _t2, _ap [1]. _t2, "type error in generic default");
		  _L1L_ = mk_desc (_ap [1]. _t2, INMODE | 0400, _ap [0]. _t2);
		
	_ap += 1;
_ap [0]. _t2 =_L1L_;
	}
} break;
case 47:
# line 705 "1A00.attrib"
{ ac _L1L_;
{ _L1L_ = mk_desc (_ap [0]. _t2, INOUTMODE | 0400, NULL);
		
_ap [0]. _t2 =_L1L_;
	}
} break;
case 48:
# line 712 "1A00.attrib"
{{ DECL_CHECK (TRUE, _ap [5]. _t2, "incomplete declarations (%s)");
		  CHECK_OPTIDENT (g_tag (_ap [5]. _t2), yypvt[-0].p_char, "unbalance in %s");
		  s_SBB_stats (_ap [5]. _t2, _ap [2]. _t2);
		  s_SBB_exh   (_ap [5]. _t2, _ap [0]. _t2);
		  DELSCOPE    (_ap [5]. _t2, _ap [3]. _t2);
		  del_optid   (yypvt[-0].p_char);
		
	_ap += 4;
	}
} break;
case 49:
# line 722 "1A00.attrib"
{ ac _L3L_;
{ _ap [2]. _t2 = mk_sbody (mk_tag (g_tag (_ap [0]. _t2), IDL), _ap [0]. _t2);
		  _L3L_ = NEWSCOPE (_ap [2]. _t2);
		
_ap [0]. _t2 =_L3L_;
	}
} break;
case 50:
# line 728 "1A00.attrib"
{ ac _L1L_;
 ac _L2L_;
 ac _L3L_;
{ DELSCOPE (_ap [2]. _t2, _ap [1]. _t2);
		  s_rettype (_ap [2]. _t2, notype);
		  _L3L_ = g_stub_spec ((ac)get_sstub (env, _ap [2]. _t2));
		  _L2L_ = _ap [3]. _t2;
		  _L1L_ = _ap [2]. _t2;
		
	_ap += 1;
_ap [2]. _t2 =_L1L_;
_ap [1]. _t2 =_L2L_;
_ap [0]. _t2 =_L3L_;
	}
} break;
case 51:
# line 736 "1A00.attrib"
{ ac _L1L_;
 ac _L2L_;
 ac _L3L_;
{ DELSCOPE (_ap [3]. _t2, _ap [2]. _t2);
		  s_rettype (_ap [3]. _t2, _ap [0]. _t2);
		  _L3L_ = g_stub_spec ((ac)get_sstub (env, _ap [3]. _t2));
		  _L2L_ = _ap [4]. _t2;
		  _L1L_ = _ap [3]. _t2;
		
	_ap += 2;
_ap [2]. _t2 =_L1L_;
_ap [1]. _t2 =_L2L_;
_ap [0]. _t2 =_L3L_;
	}
} break;
case 52:
# line 745 "1A00.attrib"
{ ac _L1L_;
 ac _L2L_;
 ac _L3L_;
 int _L4L_;
{ if (_ap [1]. _t2 == NULL)
		     _L1L_ = _ap [0]. _t2;
		  else
		  {  s_next (_ap [1]. _t2, _ap [0]. _t2);
		     _L1L_ = _ap [2]. _t2;
		  }
		  p_proc (_ap [0]. _t2, yypvt[-0].p_char);
		  _L2L_ = mk_sub (yypvt[-0].p_char, FALSE);
		  _L3L_ = NEWSCOPE (_L2L_);
		  _L4L_ = 0;
		
	_ap += -1;
_ap [3]. _t2 =_L1L_;
_ap [2]. _t2 =_L2L_;
_ap [1]. _t2 =_L3L_;
_ap [0]. _t3 =_L4L_;
	}
} break;
case 53:
# line 759 "1A00.attrib"
{ ac _L1L_;
 ac _L2L_;
 ac _L3L_;
 int _L4L_;
{ if (_ap [2]. _t2 == NULL)
		     _L1L_ = _ap [0]. _t2;
		  else
		  {  s_next (_ap [1]. _t2, _ap [0]. _t2);
		     _L1L_ = _ap [2]. _t2;
		  }
		  p_proc (_ap [0]. _t2, yypvt[-0].p_char);
		  _L2L_ = mk_sub (yypvt[-0].p_char, FALSE);
		  _L3L_ = NEWSCOPE (_L2L_);
		  _L4L_ = 0;
		
	_ap += -1;
_ap [3]. _t2 =_L1L_;
_ap [2]. _t2 =_L2L_;
_ap [1]. _t2 =_L3L_;
_ap [0]. _t3 =_L4L_;
	}
} break;
case 54:
# line 773 "1A00.attrib"
{{ DELSCOPE (_ap [2]. _t2, _ap [0]. _t2);
		  CHECK_OPTIDENT (g_tag (_ap [2]. _t2), yypvt[-0].p_char, "%s in unbalance");
		  del_optid (yypvt[-0].p_char);
		
	_ap += 1;
	}
} break;
case 55:
# line 779 "1A00.attrib"
{{ DELSCOPE (_ap [5]. _t2, _ap [3]. _t2);
		  CHECK_OPTIDENT (g_tag (_ap [5]. _t2), yypvt[-0].p_char, "unbalance %s");
		  s_PB_stats (_ap [5]. _t2, _ap [2]. _t2);
		  s_PB_exh   (_ap [5]. _t2, _ap [0]. _t2);
		  del_optid  (yypvt[-0].p_char);
		
	_ap += 4;
	}
} break;
case 56:
# line 788 "1A00.attrib"
{{ DECL_CHECK (TRUE, _ap [2]. _t2, "declarations in %s");
		
	}
} break;
case 57:
# line 793 "1A00.attrib"
{ ac _L1L_;
 ac _L2L_;
 ac _L3L_;
{ ac t;
		  if (_ap [1]. _t2  == NULL)
		     _L2L_ = _ap [0]. _t2;
		  else
		  { s_next (_ap [1]. _t2, _ap [0]. _t2);
		    _L2L_ = _ap [2]. _t2;
		  }
		  s_d_add (":#kd:PB:%s:%d", yypvt[-1].p_char, mainlun);
		  p_proc (_ap [0]. _t2, yypvt[-1].p_char);	/* establish environment	*/
		  t = get_pbstub (env, yypvt[-1].p_char);
		  if (t == NULL) {
		     error ("cannot find stub %s", yypvt[-1].p_char);
		     exit (111);
		  }

		  _L1L_ = mk_pbody (yypvt[-1].p_char, packspec (g_stub_spec (t)));
		  if (is_generic (g_specif (_L1L_))) {
		     error ("Separate generic subbodies not supported\n");
		  }

		  _L3L_ = NEWSCOPE (_L1L_);
		
_ap [2]. _t2 =_L1L_;
_ap [1]. _t2 =_L2L_;
_ap [0]. _t2 =_L3L_;
	}
} break;
case 58:
# line 819 "1A00.attrib"
{{ DELSCOPE (_ap [5]. _t2, _ap [3]. _t2);
		  CHECK_OPTIDENT (g_tag (_ap [5]. _t2), yypvt[-0].p_char, "unbalance in %s");
		  s_task_stats (_ap [5]. _t2, _ap [2]. _t2);
		  s_task_exh   (_ap [5]. _t2, _ap [0]. _t2);
		  del_optid    (yypvt[-0].p_char);
		
	_ap += 4;
	}
} break;
case 59:
# line 828 "1A00.attrib"
{{ DECL_CHECK (TRUE, _ap [2]. _t2, "declarations in %s");
		
	}
} break;
case 60:
# line 833 "1A00.attrib"
{ ac _L1L_;
 ac _L2L_;
 ac _L3L_;
{ ac t;
		  if (_ap [1]. _t2 == NULL)
		     _L2L_ = _ap [0]. _t2;
		  else
		  {  s_next (_ap [1]. _t2, _ap [0]. _t2);
		     _L2L_ = _ap [2]. _t2;
		  }
		  s_d_add (":#kd:PB:%s:d", yypvt[-1].p_char, mainlun);
		  p_proc (_ap [0]. _t2, yypvt[-1].p_char);
		  t = get_tbstub (env, yypvt[-1].p_char);
		  if (t == NULL) {
		     error ("Cannot find stub %s", yypvt[-1].p_char);
		     exit (111);
		  }

		  _L1L_ = mk_tbody (yypvt[-1].p_char, g_stub_spec (t));
		  _L3L_ = NEWSCOPE (_L1L_);
		
_ap [2]. _t2 =_L1L_;
_ap [1]. _t2 =_L2L_;
_ap [0]. _t2 =_L3L_;
	}
} break;
case 61:
# line 854 "1A00.attrib"
{ ac _L1L_;
{ s_add (":#su:%s", _ap [1]. _t4);
		  prev = NULL;
		  env = ((struct lib_unit *)_ap [0]. _t2) -> unit;
		  _L1L_ = mk_separate (_ap [1]. _t4);
		  s_septree (_L1L_, _ap [0]. _t2);
		
	_ap += 1;
_ap [0]. _t2 =_L1L_;
	}
} break;
case 62:
# line 863 "1A00.attrib"
{	_ap -= 2;
{ struct lib_unit *xx;
		  struct lib_unit *t = read_tree (yypvt[-0].p_char, XBODY);
		  if (t == (struct lib_unit *)NULL) {
		     error ("Fatal: cannot find %s in library", yypvt[-0].p_char);
		     exit (121);
		  }
		  xx = read_tree (yypvt[-0].p_char, SPEC);
		  if (xx == (struct lib_unit *)NULL) {
		     error ("Fatal: cannot happen:2");
		     exit (121);
		  }
		  withprocess (xx);	/* the specification	*/
		  _ap [1]. _t4 = tmpvec (yypvt[-0].p_char);
		  withprocess (t);
		  _ap [0]. _t2 = (ac)t;
		}
} break;
case 63:
# line 880 "1A00.attrib"
{{ struct lib_unit *t;
		  _ap [1]. _t4 = add_tmpvec (add_tmpvec (_ap [1]. _t4, "."), yypvt[-0].p_char);
		  t = read_tree (_ap [1]. _t4, XBODY);
		  if (t == (struct lib_unit *)NULL)
		     sys_error ("Help");	
		  withprocess (t);
		  _ap [0]. _t2 = (ac)t;	/* the deepest one	*/
		
	}
} break;
case 64:
# line 890 "1A00.attrib"
{{ special_cun (STD_LUN);
		  mainlun = STD_LUN;
		  new_lun (mainlun);
		  in_antag ();
		  i_open_scopes ();
		  new_start ();
		}
} break;
case 65:
# line 899 "1A00.attrib"
{	_ap -= 2;
{ int status = TRUE;
		  mainlun = (int)get_cun (&status);
		  if (!status) {
		     fail ((short) mainlun, &status);
		     if (!status)
		        fprintf (stderr, "cun %d can't be removed, get help\n", mainlun);
		     exit (111);
		  }
		  rd_standard ();
		  new_lun (mainlun); in_antag ();
		  i_open_scopes ();
		  new_start ();
		  _ap [1]. _t2 = _ap [0]. _t2 = NULL;
		}
} break;
case 66:
# line 914 "1A00.attrib"
{{ if (_ap [3]. _t2 == NULL) {
		     _ap [3]. _t2 = _ap [1]. _t2;
		     _ap [2]. _t2 = _ap [0]. _t2;
		  } else
		  {  s_next (_ap [2]. _t2, _ap [1]. _t2);
		     _ap [2]. _t2 = _ap [0]. _t2;
		  }
		
	_ap += 2;
	}
} break;
case 69:
# line 929 "1A00.attrib"
{	_ap -= 2;
{ struct lib_unit *t = read_tree (yypvt[-0].p_char, SPEC);
		  if (t == (struct lib_unit *)NULL) {
		     error ("Cannot find specification %s", yypvt[-0].p_char);
		     exit (111);
		  }
		  _ap [1]. _t2 = mk_with (t -> unit, yypvt[-0].p_char);
		  OBJDECL (g_withunit (_ap [1]. _t2), "Cannot happen");
		  OBJDECL (t -> unit, "WAT IS DAT NU???");
		  _ap [0]. _t2 = _ap [1]. _t2;
		}
} break;
case 70:
# line 940 "1A00.attrib"
{{ struct lib_unit *t = read_tree (yypvt[-0].p_char, SPEC);
		  if (t == (struct lib_unit *)NULL) {
		     error ("Cannot find specification %s", yypvt[-0].p_char);
		     exit (111);
		  }
		  s_next (_ap [0]. _t2, mk_with (t -> unit, yypvt[-0].p_char));
		  _ap [0]. _t2 = g_next (_ap [0]. _t2);
		  OBJDECL (g_withunit (_ap [0]. _t2), "Cannot happen");
		  OBJDECL (t -> unit, "Cannot happen:21");
		
	}
} break;
case 71:
# line 953 "1A00.attrib"
{ ac _L1L_;
 ac _L2L_;
{ _L1L_ = mk_use (td_n_name (bu_name (_ap [0]. _t2)));
		  _L2L_ = _L1L_;
		
	_ap += -1;
_ap [1]. _t2 =_L1L_;
_ap [0]. _t2 =_L2L_;
	}
} break;
case 72:
# line 957 "1A00.attrib"
{{ ac r = mk_use (td_n_name (bu_name (_ap [0]. _t2)));
		  s_next (_ap [1]. _t2, r);
		  _ap [1]. _t2 = r;
		
	_ap += 1;
	}
} break;
case 73:
# line 963 "1A00.attrib"
{{ introduce (mk_use (td_n_name (bu_name (_ap [0]. _t2))));
		
	_ap += 1;
	}
} break;
case 74:
# line 966 "1A00.attrib"
{{ introduce (mk_use (td_n_name (bu_name (_ap [0]. _t2))));
		
	_ap += 1;
	}
} break;
case 75:
# line 968 "1A00.attrib"
{{
		   do_pragma_0 (yypvt[-0].p_char, NULL);
		}
} break;
case 76:
# line 972 "1A00.attrib"
{{ do_pragma_1 (yypvt[-3].p_char, _ap [0]. _t2);
		
	_ap += 1;
	}
} break;
case 77:
# line 975 "1A00.attrib"
{{ do_pragma_2 (yypvt[-5].p_char, _ap [1]. _t2, _ap [0]. _t2);
		
	_ap += 2;
	}
} break;
case 78:
# line 979 "1A00.attrib"
{{ do_pragma_3 (yypvt[-7].p_char, _ap [1]. _t2, _ap [0]. _t2, yypvt[-1].p_char);
		
	_ap += 2;
	}
} break;
case 79:
# line 984 "1A00.attrib"
{{ _ap [0]. _t2 = mk_call (_ap [0]. _t2, NULL);
		
	}
} break;
case 80:
# line 987 "1A00.attrib"
{{ _ap [3]. _t2 = mk_call (_ap [3]. _t2, _ap [2]. _t2);
		
	_ap += 3;
	}
} break;
case 81:
# line 992 "1A00.attrib"
{ ac _L2L_;
 int _L3L_;
{ _L2L_ = _ap [1]. _t2;
		  _L3L_ = _ap [0]. _t3;
		
	_ap += -1;
_ap [1]. _t2 =_L2L_;
_ap [0]. _t3 =_L3L_;
	}
} break;
case 82:
# line 996 "1A00.attrib"
{{ _ap [2]. _t3 = acceptable (_ap [2]. _t3, _ap [0]. _t3, "parameter order in generic illegal");
		  s_next (_ap [3]. _t2, _ap [1]. _t2);
		  _ap [3]. _t2 = _ap [1]. _t2;
		
	_ap += 2;
	}
} break;
case 83:
# line 1003 "1A00.attrib"
{ int _L2L_;
{ _L2L_ = XCALL;
		
	_ap += -1;
_ap [0]. _t3 =_L2L_;
	}
} break;
case 84:
# line 1006 "1A00.attrib"
{ int _L2L_;
{ _L2L_ = XINDEXING;
		
	_ap += -1;
_ap [0]. _t3 =_L2L_;
	}
} break;
case 85:
# line 1011 "1A00.attrib"
{{ _ap [0]. _t2 = mk_namass (yypvt[-2].p_char, _ap [0]. _t2);
		
	}
} break;
case 86:
# line 1014 "1A00.attrib"
{{ _ap [0]. _t2 = mk_namass (chk_char (yypvt[-2].p_char,
                      "Illegal operator (%s) as left hand in generic par"), _ap [0]. _t2);
		
	}
} break;
case 88:
# line 1022 "1A00.attrib"
{{
		  CHECK_OPTIDENT (g_tag (g_specif (_ap [4]. _t2)), yypvt[-0].p_char,
					       "unbalance in proc body %s");
		  s_SBB_stats (_ap [4]. _t2, _ap [2]. _t2);
		  s_SBB_exh (_ap [4]. _t2, _ap [0]. _t2);
		  DELSCOPE (_ap [4]. _t2, _ap [3]. _t2);
		  del_optid (yypvt[-0].p_char);
		
	_ap += 4;
	}
} break;
case 89:
# line 1033 "1A00.attrib"
{{ DECL_CHECK (FALSE, _ap [1]. _t2,
	                      "declaration in %s incomplete, bodies missing");
		
	}
} break;
case 90:
# line 1039 "1A00.attrib"
{ ac _L1L_;
 ac _L2L_;
{ ac r;
		  r = FIND_SUBSPEC (_ap [0]. _t2, env,
		           "procedure (function) declaration: probably incorrect specification for %s");
		  _L1L_ = mk_sbody (mk_tag (g_tag (r), IDL), r);
		  introduce (_L1L_);
		  _L2L_ = NEWSCOPE (_L1L_);
		
	_ap += -1;
_ap [1]. _t2 =_L1L_;
_ap [0]. _t2 =_L2L_;
	}
} break;
case 91:
# line 1049 "1A00.attrib"
{{ DELSCOPE (_ap [1]. _t2, _ap [0]. _t2);
		  DELSCOPE (_ap [3]. _t2, _ap [2]. _t2);
		  CHECK_OPTIDENT (g_tag (_ap [3]. _t2), yypvt[-0].p_char,
                                "generic package: unbalance in %s");
		  OBJDECL (_ap [3]. _t2, "Generic package %s not unique");
		  DECL_CHECK (FALSE, _ap [3]. _t2, 
                          "generic package: incomplete list of declarations %s");
		  del_optid (yypvt[-0].p_char);
		
	_ap += 3;
	}
} break;
case 92:
# line 1061 "1A00.attrib"
{ ac _L3L_;
 ac _L4L_;
{ _L3L_ = mk_package (yypvt[-1].p_char);
		  s_tag (_ap [1]. _t2, mk_tag (yypvt[-1].p_char, IDL));
		  set_generic (_L3L_);
		  s_genunit (_ap [1]. _t2, _L3L_);
		  add_def (_L3L_);
		  _L4L_ = NEWSCOPE (_L3L_);
		
	_ap += -2;
_ap [1]. _t2 =_L3L_;
_ap [0]. _t2 =_L4L_;
	}
} break;
case 93:
# line 1071 "1A00.attrib"
{	_ap -= 2;
{ _ap [1]. _t2 = mk_generic ();
		  _ap [0]. _t2 = NEWSCOPE (_ap [1]. _t2);
		}
} break;
case 94:
# line 1076 "1A00.attrib"
{{ DELSCOPE (_ap [1]. _t2, _ap [0]. _t2);
		  CHECK_OPTIDENT (g_tag (_ap [1]. _t2), yypvt[-0].p_char, 
                             "Package %s: unbalance in opening tag");
		  DECL_CHECK (FALSE, _ap [1]. _t2, 
                            "Package %s: erroneous declarations");
		  del_optid (yypvt[-0].p_char);
		
	_ap += 1;
	}
} break;
case 95:
# line 1086 "1A00.attrib"
{ ac _L1L_;
{ ac t = instantiate (yypvt[-3].p_char, _ap [0]. _t2);
		
_ap [0]. _t2 =_L1L_;
	}
} break;
case 96:
# line 1092 "1A00.attrib"
{	_ap -= 2;
{ _ap [1]. _t2 = mk_package (yypvt[-1].p_char);
		  OBJDECL (_ap [1]. _t2, "Package %s: identifier not unique");
		  _ap [0]. _t2 = NEWSCOPE (_ap [1]. _t2);
		}
} break;
case 97:
# line 1099 "1A00.attrib"
{	_ap -= 3;
{ _ap [2]. _t2 = mk_task (mk_tag (gen_tag (), IDL));
		  INTRODUCE (_ap [2]. _t2);
		  _ap [1]. _t2 = NEWSCOPE (_ap [2]. _t2);
		  _ap [0]. _t4 = yypvt[-0].p_char;
		}
} break;
case 98:
# line 1107 "1A00.attrib"
{{ ac t, r;
		  DELSCOPE (_ap [2]. _t2, _ap [1]. _t2);
		  off_intro (_ap [2]. _t2);
		  t = mk_object (_ap [0]. _t4, mk_desc (_ap [2]. _t2, KVAR, NULL));
		  OBJDECL (t, "%s (task) declared more than once");
		  _ap [2]. _t2 = t;
		
	_ap += 2;
	}
} break;
case 100:
# line 1117 "1A00.attrib"
 {
_ap += 1; } break;
case 101:
# line 1120 "1A00.attrib"
{	_ap -= 2;
{ ac t;
		  t = mk_task (yypvt[-0].p_char);
		  PREDECL (t);
		  _ap [0]. _t2 = NEWSCOPE (t);
		  _ap [1]. _t2 = t;
		}
} break;
case 103:
# line 1128 "1A00.attrib"
 {
_ap += 1; } break;
case 104:
# line 1132 "1A00.attrib"
{ int _L1L_;
{ _L1L_ = 1;
		  s_entry_nr (_ap [0]. _t2, 1);
		
_ap [0]. _t3 =_L1L_;
	}
} break;
case 105:
# line 1136 "1A00.attrib"
{{ _ap [1]. _t3 = _ap [1]. _t3 + 1;
		  s_entry_nr (_ap [0]. _t2, _ap [1]. _t3);
		
	_ap += 1;
	}
} break;
case 106:
# line 1142 "1A00.attrib"
{{ s_rettype (_ap [2]. _t2, notype);
		  DELSCOPE (_ap [2]. _t2, _ap [1]. _t2);
		
	_ap += 2;
	}
} break;
case 107:
# line 1147 "1A00.attrib"
{	_ap -= 3;
{ _ap [2]. _t2 = mk_entry (yypvt[-0].p_char);
		  SUBDECL (_ap [2]. _t2);
		  _ap [1]. _t2 = NEWSCOPE (_ap [2]. _t2);
		  _ap [0]. _t3 = 0;
		}
} break;
case 108:
# line 1154 "1A00.attrib"
{{ ac t = mk_prpart ();
		  introduce (t);
		  DELSCOPE (t, NEWSCOPE (t));
		}
} break;
case 109:
# line 1159 "1A00.attrib"
{{ DELSCOPE (_ap [1]. _t2, _ap [0]. _t2);
		
	_ap += 2;
	}
} break;
case 110:
# line 1163 "1A00.attrib"
{	_ap -= 2;
{ _ap [1]. _t2 = mk_prpart ();
		  introduce (_ap [1]. _t2);
		  _ap [0]. _t2 = NEWSCOPE (_ap [1]. _t2);
		}
} break;
case 111:
# line 1169 "1A00.attrib"
{{ DELSCOPE (_ap [1]. _t2, _ap [0]. _t2);
		  CHECK_OPTIDENT (g_tag (_ap [1]. _t2), yypvt[-0].p_char, "%s in unbalance");
		  del_optid (yypvt[-0].p_char);
		
	_ap += 2;
	}
} break;
case 112:
# line 1175 "1A00.attrib"
{{
		  DELSCOPE (_ap [4]. _t2, _ap [3]. _t2);
		  CHECK_OPTIDENT (g_tag (_ap [4]. _t2), yypvt[-0].p_char, 
                         "Package body: %s in unbalance");
		  s_PB_stats (_ap [4]. _t2, _ap [2]. _t2);
		  s_PB_exh (_ap [4]. _t2, _ap [0]. _t2);
		  del_optid (yypvt[-0].p_char);
		
	_ap += 5;
	}
} break;
case 113:
# line 1186 "1A00.attrib"
{{ DECL_CHECK (FALSE, _ap [1]. _t2, 
                         "Package body: %s declaration");
		
	}
} break;
case 114:
# line 1192 "1A00.attrib"
{	_ap -= 2;
{ _ap [1]. _t2 = mk_pbody (yypvt[-1].p_char,
                          packspec (FIND_PACKSPEC (yypvt[-1].p_char, 
                                    "Package body %s: Cannot find spec")));
		  if (is_instantiated (g_specif (_ap [1]. _t2))) {
		     error ("Specification instantiated before body elab %s\n",
			                                      yypvt[-1].p_char);
		  }
		  introduce (_ap [1]. _t2);
		  _ap [0]. _t2 = NEWSCOPE (_ap [1]. _t2);
		}
} break;
case 119:
# line 1209 "1A00.attrib"
 {
_ap += -1; } break;
case 120:
# line 1212 "1A00.attrib"
{{ error ("Ada-- does currently not support this kind of repr ");
		
	_ap += 3;
	}
} break;
case 121:
# line 1215 "1A00.attrib"
{{ ac t = mk_foruse (chk_varname (td_n_name (bu_name (_ap [2]. _t4))),
			                         STATIC_EXPR (_ap [0]. _t2, std_univ,
	                                                     "illegal expr"));
		
	_ap += 3;
	}
} break;
case 126:
# line 1227 "1A00.attrib"
{{ off_intro (_ap [1]. _t2);
		
	_ap += 2;
	}
} break;
case 127:
# line 1230 "1A00.attrib"
{{ POSTDECL (_ap [0]. _t2);
		
	_ap += 1;
	}
} break;
case 128:
# line 1232 "1A00.attrib"
 {
_ap += 1; } break;
case 129:
# line 1233 "1A00.attrib"
 {
_ap += 1; } break;
case 130:
# line 1234 "1A00.attrib"
 {
_ap += 1; } break;
case 131:
# line 1236 "1A00.attrib"
{{ chk_6_7_4 (_ap [0]. _t2);
		  SUBDECL (_ap [0]. _t2);
		
	_ap += 1;
	}
} break;
case 135:
# line 1242 "1A00.attrib"
 {
_ap += 1; } break;
case 136:
# line 1243 "1A00.attrib"
 {
_ap += 1; } break;
case 138:
# line 1247 "1A00.attrib"
{ ac _L1L_;
{ _L1L_ = mk_exception (yypvt[-4].p_char);
		  OBJDECL (_L1L_, "Exception declaration: renaming %s not unique");
		  s_rnam (_L1L_, get_exc (td_n_name (bu_name (_ap [0]. _t2))));
		
_ap [0]. _t2 =_L1L_;
	}
} break;
case 139:
# line 1253 "1A00.attrib"
{	_ap -= 1;
{ _ap [0]. _t2 = mk_exception (yypvt[-2].p_char);
		  OBJDECL (_ap [0]. _t2, "Exception declaration: %s not unique");
		}
} break;
case 140:
# line 1257 "1A00.attrib"
{{ ac t = mk_exception (yypvt[-2].p_char);
		  OBJDECL (t, "Exception declaration: %s not unique");
		  _ap [0]. _t2 = t;
		
	}
} break;
case 143:
# line 1265 "1A00.attrib"
 {
_ap += 1; } break;
case 144:
# line 1266 "1A00.attrib"
 {
_ap += 1; } break;
case 145:
# line 1267 "1A00.attrib"
 {
_ap += 1; } break;
case 147:
# line 1270 "1A00.attrib"
 {
_ap += 1; } break;
case 148:
# line 1271 "1A00.attrib"
 {
_ap += 1; } break;
case 149:
# line 1272 "1A00.attrib"
 {
_ap += 1; } break;
case 150:
# line 1273 "1A00.attrib"
 {
_ap += 1; } break;
case 152:
# line 1275 "1A00.attrib"
 {
_ap += 1; } break;
case 153:
# line 1276 "1A00.attrib"
 {
_ap += 1; } break;
case 156:
# line 1279 "1A00.attrib"
 {
_ap += 1; } break;
case 157:
# line 1281 "1A00.attrib"
{{ DELSCOPE (_ap [1]. _t2, _ap [0]. _t2);
                  POSTDECL (_ap [1]. _t2);
		
	_ap += 2;
	}
} break;
case 158:
# line 1286 "1A00.attrib"
{	_ap -= 1;
{ ac r;
		  if (!sep_pb (env))
		     error ("Package body stub not allowed here (%s)", yypvt[-2].p_char);
                  else
		  {  r = FIND_PACKSPEC (yypvt[-2].p_char, "Body stub %s: no spec, fatal");
		     if (r == NULL)
		        exit (04);
		     s_add (":#st:%s", yypvt[-2].p_char);
		     _ap [0]. _t2 = mk_stub (yypvt[-2].p_char, r);
		     introduce (_ap [0]. _t2);
		     s_pack_body (r, _ap [0]. _t2);
		  }
		}
} break;
case 159:
# line 1300 "1A00.attrib"
{{ ac t, r;
		  if (!sep_sub (env))
		     error (
                       "Procedure body stub (%s) not allowed here", g_tag (_ap [0]. _t2));
		  else
		  {  t = FIND_SUBSPEC (_ap [0]. _t2, env, "decl: subspec %s");
		     s_add (":#st:%s", g_tag (t));
		     r = mk_stub (mk_tag (g_tag (t), IDL), t);
		     s_body_imp (t, r);
		     INTRODUCE (r);
		     _ap [0]. _t2 = r;
		  }
		
	}
} break;
case 160:
# line 1314 "1A00.attrib"
{	_ap -= 1;
{ ac r;
		  if (!sep_tb (env))
		     error ("Task body stub (%s) not allowed here", yypvt[-2].p_char);
		  else
		  {  r = FIND_TASKSPEC (yypvt[-2].p_char,
                           "Task body stub %s: no specification Fatal");
		     if (r == NULL)
		        exit (05);
		     s_add (":#st:%s", yypvt[-2].p_char);
		     _ap [0]. _t2 = mk_stub (yypvt[-2].p_char, r);
		     introduce (_ap [0]. _t2);
		     s_taskbody (r, _ap [0]. _t2);
		  }
		}
} break;
case 161:
# line 1331 "1A00.attrib"
{{ DELSCOPE (_ap [4]. _t2, _ap [3]. _t2);
		  CHECK_OPTIDENT (g_tag (_ap [4]. _t2), yypvt[-0].p_char, "Task body %s in unbalance");
		  del_optid (yypvt[-0].p_char);
		  s_task_stats (_ap [4]. _t2, _ap [2]. _t2);
		  s_task_exh   (_ap [4]. _t2, _ap [0]. _t2);
		
	_ap += 4;
	}
} break;
case 162:
# line 1339 "1A00.attrib"
{{ DECL_CHECK (FALSE, _ap [1]. _t2,
		              "Task body declarations in %s incomplete");
		
	}
} break;
case 163:
# line 1344 "1A00.attrib"
{	_ap -= 2;
{ ac t = FIND_TASKSPEC (yypvt[-1].p_char,
                         "Cannot find specification for task body %s (Fatal)");
		  if (t == NULL) {
		     exit (104);
		  }
		  _ap [1]. _t2 = mk_tbody (yypvt[-1].p_char, t);
		  introduce (_ap [1]. _t2);
		  _ap [0]. _t2 = NEWSCOPE (_ap [1]. _t2);
		  s_pack_body (t, _ap [1]. _t2);
		}
} break;
case 164:
# line 1362 "1A00.attrib"
{ ac _L1L_;
 ac _L2L_;
{ _L1L_ = mk_object (yypvt[-2].p_char, _ap [0]. _t2);
		  OBJDECL (_L1L_, "%s declared twice");
		  _L2L_ = _ap [0]. _t2;
		
	_ap += -1;
_ap [1]. _t2 =_L1L_;
_ap [0]. _t2 =_L2L_;
	}
} break;
case 165:
# line 1367 "1A00.attrib"
{ ac _L2L_;
{ ac t;
		  _ap [1]. _t2 = CONST_TYPE (_ap [1]. _t2, yypvt[-3].p_char, "unconstrained type for object %s");
		  _ap [0]. _t2 = SOLVE_EXPR (_ap [0]. _t2, _ap [1]. _t2, "illegal type init expr");
		  if (_ap [0]. _t2 != NULL && !has_eq_and_ass (_ap [1]. _t2))
	             error ("Initialization for %s not allowed", yypvt[-3].p_char);
		  _L2L_ = mk_desc (_ap [1]. _t2, KVAR, _ap [0]. _t2);
		  t = mk_object (yypvt[-3].p_char, _L2L_);
		  OBJDECL (t, "%s declared twice");
		  _ap [1]. _t2 = t;
		
_ap [0]. _t2 =_L2L_;
	}
} break;
case 166:
# line 1378 "1A00.attrib"
{{ _ap [1]. _t2 = mk_object (yypvt[-2].p_char, cp_tree (_ap [0]. _t2));
		  OBJDECL (_ap [1]. _t2, "%s declared twice");
		
	}
} break;
case 167:
# line 1383 "1A00.attrib"
{{ _ap [0]. _t2 = SOLVE_EXPR (_ap [0]. _t2, _ap [1]. _t2, "illegal type init expr");
	          if (_ap [0]. _t2 != NULL && !has_eq_and_ass (_ap [1]. _t2))
		     error ("Initialization not allowed");
		  _ap [1]. _t2 = mk_desc (_ap [1]. _t2, KCONST, _ap [0]. _t2);
		
	_ap += 1;
	}
} break;
case 168:
# line 1389 "1A00.attrib"
{{ if (!is_local_private (_ap [0]. _t2))
		     error ("Initialization requires expression");
		  if (!has_eq_and_ass (_ap [0]. _t2))
		     error ("Initialization not allowed");
		  _ap [0]. _t2 = mk_desc (_ap [0]. _t2, KCONST, NULL);
		
	}
} break;
case 169:
# line 1396 "1A00.attrib"
{{ _ap [0]. _t2 = SOLVE_EXPR (_ap [0]. _t2, types_of (_ap [0]. _t2), "error in number");
		  _ap [0]. _t2 = mk_desc (type_of (_ap [0]. _t2), KNUMB, _ap [0]. _t2);
		
	}
} break;
case 170:
# line 1400 "1A00.attrib"
{{ _ap [0]. _t2 = SOLVE_EXPR (_ap [0]. _t2, _ap [1]. _t2, "illegal type init expr");
		  _ap [2]. _t2 = mk_desc (_ap [1]. _t2, KVAR, _ap [0]. _t2);
		
	_ap += 2;
	}
} break;
case 171:
# line 1404 "1A00.attrib"
{{ _ap [0]. _t2 = SOLVE_EXPR (_ap [0]. _t2, _ap [1]. _t2, "error in array constant");
		  _ap [2]. _t2 = mk_desc (_ap [1]. _t2, KCONST, _ap [0]. _t2);
		
	_ap += 2;
	}
} break;
case 179:
# line 1416 "1A00.attrib"
{{ DELSCOPE (_ap [1]. _t2, _ap [0]. _t2);
		
	_ap += 1;
	}
} break;
case 181:
# line 1422 "1A00.attrib"
{ ac _L1L_;
{ ac t, r, s;
		  NO_DISCRS (_ap [1]. _t2, _ap [2]. _t4, "New type: illegal discriminants in %s");
		  t = TD_FILTER (bu_filter (mk_filter (NULL, _ap [0]. _t2)),
		     "Cannot determine range types in new type %s", _ap [2]. _t4);
		  if (t != NULL) {
		     if (!is_static (t))
		        error ("Range in new integer type non-static %s", _ap [2]. _t4);
		     r = smallest_int (g_constraint (t));
		     s = mk_newtype (r, mk_tag (gen_tag (), IDL), NEWINTTYPE);
		     OBJDECL (s, "Cannot happen %s");
		     coerce_filter (t, s);
		     t = mk_subtype (_ap [2]. _t4, t);
		     PREDECL (t);
		     set_sttype (t);
		  }
		  _L1L_ = t;
		
	_ap += 2;
_ap [0]. _t2 =_L1L_;
	}
} break;
case 182:
# line 1440 "1A00.attrib"
{ ac _L1L_;
{ ac t = mk_newtype (_ap [0]. _t2, _ap [2]. _t4);
		  if (is_sttype (_ap [0]. _t2))
		     set_sttype (t);
		  PREDECL (t);
		  NO_DISCRS (_ap [1]. _t2, _ap [2]. _t4, "illegal discriminants in %s");
		  inherit (t, _ap [0]. _t2);
		  _L1L_ = t;
		
	_ap += 2;
_ap [0]. _t2 =_L1L_;
	}
} break;
case 183:
# line 1450 "1A00.attrib"
{ ac _L1L_;
{ ac t, r;
		  t = mk_newtype (_ap [1]. _t2, mk_tag (gen_tag (), IDL));
		  if (is_sttype (_ap [1]. _t2))
		     set_sttype (t);
		  NO_DISCRS (_ap [2]. _t2, _ap [3]. _t4,
                                  "No discriminants in type possible %s");
		  INTRODUCE (t);
		  inherit (t, _ap [1]. _t2);
		  r = mk_subtype (_ap [3]. _t4, mk_filter (t, _ap [0]. _t2));
		  if (SOLVE_FILTER (g_parenttype (r), t, _ap [3]. _t4,
                               "Error in derived type constraint %s") == NULL)
		     r = mk_subtype (_ap [3]. _t4, t);
		  else
		     PREDECL (r);
		  _L1L_ = r;
		
	_ap += 3;
_ap [0]. _t2 =_L1L_;
	}
} break;
case 184:
# line 1469 "1A00.attrib"
{ ac _L1L_;
{ ac t;
		  t = mk_acctype (_ap [2]. _t4, _ap [0]. _t2);
		  PREDECL (t);
		  NO_DISCRS (_ap [1]. _t2, g_tag (t), "illegal discriminants %s");
		  _L1L_ = t;
		
	_ap += 2;
_ap [0]. _t2 =_L1L_;
	}
} break;
case 185:
# line 1477 "1A00.attrib"
{ ac _L1L_;
{ ac t, r;
		  t = mk_acctype (mk_tag (gen_tag (), IDL), _ap [1]. _t2);
		  NO_DISCRS (_ap [2]. _t2, _ap [3]. _t4, "illegal discriminants in %s");
		  INTRODUCE (t);
		  r = mk_subtype (_ap [3]. _t4, mk_filter (t, _ap [0]. _t2));
	          if (SOLVE_FILTER (g_parenttype (r), t, _ap [3]. _t4,
					"error in access decl %s") == NULL) {
		     r = mk_subtype (_ap [3]. _t4, any_type);
		  }
		  else
		     PREDECL (r);
		  _L1L_ = r;
		
	_ap += 3;
_ap [0]. _t2 =_L1L_;
	}
} break;
case 186:
# line 1500 "1A00.attrib"
{{ if (g_dis (_ap [3]. _t2) != NULL) {
		     ac dt = type_of (g_comp (g_dis (_ap [3]. _t2)));
		     CHECK_VARIANT (_ap [3]. _t2, dt, "illegal ranges %s", _ap [3]. _t2);
		  }
		  DELSCOPE (_ap [3]. _t2, _ap [4]. _t2);
		
	_ap += 4;
	}
} break;
case 187:
# line 1509 "1A00.attrib"
{ ac _L1L_;
 ac _L2L_;
 ac _L3L_;
 ac _L4L_;
 bool _L5L_;
{ _L2L_ = mk_recnode (_ap [1]. _t4);
		  s_flags (_L2L_, g_flags (_L2L_) | HAS_ASSIGN);	/* default	*/
		  PREDECL (_L2L_);
		  _L1L_ = NEWSCOPE (_L2L_);
		  LIST_INTRO (_ap [0]. _t2, "(%s) double appearing");
		  off_intro (_ap [0]. _t2);
		  _L3L_ = _L2L_;	/* current variant	*/
		  _L4L_ = (ac) NULL;	/* dummy	*/
		
	_ap += -3;
_ap [4]. _t2 =_L1L_;
_ap [3]. _t2 =_L2L_;
_ap [2]. _t2 =_L3L_;
_ap [1]. _t2 =_L4L_;
_ap [0]. _t0 =_L5L_;
	}
} break;
case 188:
# line 1520 "1A00.attrib"
{ ac _L2L_;
{ _L2L_ = NULL; /* discriminants */
		
	_ap += -1;
_ap [0]. _t2 =_L2L_;
	}
} break;
case 190:
# line 1525 "1A00.attrib"
{	_ap -= 1;
{ _ap [0]. _t4 = yypvt[-0].p_char;	/* keep the tag */
		}
} break;
case 191:
# line 1528 "1A00.attrib"
 {
_ap += 1; } break;
case 192:
# line 1531 "1A00.attrib"
 {
_ap += 1; } break;
case 193:
# line 1533 "1A00.attrib"
{{ s_next (_ap [3]. _t2, _ap [2]. _t2);
		  _ap [3]. _t2 = _ap [1]. _t2;
		
	_ap += 3;
	}
} break;
case 194:
# line 1539 "1A00.attrib"
{ ac _L1L_;
 ac _L2L_;
 ac _L3L_;
{ _ap [1]. _t2 = IS_SCALAR (_ap [1]. _t2, yypvt[-3].p_char, "discr type non scalar %s");
		  _ap [0]. _t2 = SOLVE_EXPR (_ap [0]. _t2, _ap [1]. _t2, "illegal expression for discrim");
		  _L3L_ = mk_desc (_ap [1]. _t2, KDISCR, _ap [0]. _t2);
		  _L1L_ = mk_object (yypvt[-3].p_char, _L3L_);
		  _L2L_ = _L1L_;
		
	_ap += -1;
_ap [2]. _t2 =_L1L_;
_ap [1]. _t2 =_L2L_;
_ap [0]. _t2 =_L3L_;
	}
} break;
case 195:
# line 1546 "1A00.attrib"
{{ ac t = mk_object (t, cp_tree (_ap [0]. _t2));
		  s_next (t, _ap [2]. _t2);
		  _ap [2]. _t2 = t;
		
	}
} break;
case 196:
# line 1553 "1A00.attrib"
{ ac _L1L_;
{ ac t;
		  _L1L_ = mk_privtype (_ap [2]. _t4, _ap [1]. _t2, _ap [0]. _t3);
		  PREDECL (_L1L_);
		  t = NEWSCOPE (_L1L_);
		  LIST_CHECK (_ap [1]. _t2);
		  DELSCOPE (_L1L_, t);
		
	_ap += 2;
_ap [0]. _t2 =_L1L_;
	}
} break;
case 197:
# line 1562 "1A00.attrib"
{	_ap -= 1;
{ _ap [0]. _t3 = FALSE;
		}
} break;
case 198:
# line 1565 "1A00.attrib"
{	_ap -= 1;
{ _ap [0]. _t3 = TRUE;
		}
} break;
case 199:
# line 1570 "1A00.attrib"
{ ac _L1L_;
{ ac t;
		  _L1L_ = mk_incomplete (_ap [1]. _t4, _ap [0]. _t2);
		  PREDECL (_L1L_);
		  t = NEWSCOPE (_L1L_);
		  LIST_CHECK (_ap [0]. _t2);
		  DELSCOPE (_L1L_, t);
		
	_ap += 1;
_ap [0]. _t2 =_L1L_;
	}
} break;
case 200:
# line 1579 "1A00.attrib"
{{ s_nenums (_ap [2]. _t2, _ap [0]. _t3);
		  set_sttype (_ap [2]. _t2);
		
	_ap += 2;
	}
} break;
case 201:
# line 1585 "1A00.attrib"
{ int _L3L_;
{ s_fenumlit (_ap [1]. _t2, _ap [0]. _t2);
		  s_enuml_ord (_ap [0]. _t2, 0);
		  s_enclunit (_ap [0]. _t2, _ap [1]. _t2);
		  if (enum_check (_ap [0]. _t2))
		     error ("enumeration literal %s not unique", g_tag (_ap [0]. _t2));
		  add_def (_ap [0]. _t2);
		  _L3L_ = 1;
		
	_ap += -1;
_ap [0]. _t3 =_L3L_;
	}
} break;
case 202:
# line 1594 "1A00.attrib"
{{ s_enclunit (_ap [0]. _t2, _ap [3]. _t2);
		  s_enuml_ord (_ap [0]. _t2, _ap [1]. _t3);
		  s_next (_ap [2]. _t2, _ap [0]. _t2);
		  if (enum_check (_ap [0]. _t2))
		     error ("enumeration literal %s not unique", g_tag (_ap [0]. _t2));
		  add_def (_ap [0]. _t2);
		  _ap [1]. _t3 = _ap [1]. _t3 + 1;
		  _ap [2]. _t2 = _ap [0]. _t2;
		
	_ap += 1;
	}
} break;
case 203:
# line 1605 "1A00.attrib"
{ ac _L1L_;
{ ac t;
		  t = mk_enum (_ap [1]. _t4);
		  PREDECL (t);
		  NO_DISCRS (_ap [0]. _t2, _ap [1]. _t4, "illegal discriminant in spec %s");
		  _L1L_ = t;
		
	_ap += 1;
_ap [0]. _t2 =_L1L_;
	}
} break;
case 204:
# line 1613 "1A00.attrib"
{	_ap -= 1;
{ _ap [0]. _t2 = mk_enlit (yypvt[-0].p_char, NULL);
		}
} break;
case 205:
# line 1616 "1A00.attrib"
{	_ap -= 1;
{ _ap [0]. _t2 = mk_charlit (yypvt[-0].f_int, NULL);
		}
} break;
case 206:
# line 1621 "1A00.attrib"
{ ac _L1L_;
{ _ap [0]. _t2 = CONST_TYPE (_ap [0]. _t2, _ap [3]. _t4,
                       "Array element of type %s insufficiently constrained");
		  _L1L_ = mk_array (_ap [3]. _t4, _ap [2]. _t2, _ap [0]. _t2);
		  PREDECL (_L1L_);
		  if (has_eq_and_ass (_ap [0]. _t2))
		     s_flags (_L1L_, g_flags (_L1L_) | HAS_ASSIGN);
		
	_ap += 3;
_ap [0]. _t2 =_L1L_;
	}
} break;
case 207:
# line 1630 "1A00.attrib"
{ ac _L1L_;
{ ac uncons, subt;
		  _ap [0]. _t2 = CONST_TYPE (_ap [0]. _t2, _ap [3]. _t4,
                       "Array element of type  %s unconstrained");
		  uncons = conv_array (NULL, _ap [0]. _t2);
		  INTRODUCE (uncons);
		  _L1L_ = bu_filter (mk_filter (uncons, _ap [2]. _t2));
		  set_indices (uncons, _ap [2]. _t2);
		  if (has_eq_and_ass ( _ap [0]. _t2))
		     s_flags (uncons, g_flags (uncons) | HAS_ASSIGN);
		  subt = TD_FILTER (_L1L_, "Error in implied array type %s", _ap [3]. _t4);
		  _L1L_ = mk_subtype (_ap [3]. _t4, subt);
		  PREDECL (_L1L_);
		
	_ap += 3;
_ap [0]. _t2 =_L1L_;
	}
} break;
case 208:
# line 1645 "1A00.attrib"
{{ NO_DISCRS (_ap [0]. _t2, _ap [1]. _t4, "illegal discriminants in array type %s");
		
	_ap += 1;
	}
} break;
case 209:
# line 1650 "1A00.attrib"
{ ac _L2L_;
{ _L2L_ = _ap [0]. _t2;
		
	_ap += -1;
_ap [0]. _t2 =_L2L_;
	}
} break;
case 210:
# line 1653 "1A00.attrib"
{{ s_next (_ap [1]. _t2, _ap [0]. _t2);
		  _ap [1]. _t2 = _ap [0]. _t2;
		
	_ap += 1;
	}
} break;
case 211:
# line 1658 "1A00.attrib"
{{ _ap [0]. _t2 = mk_index (IS_SCALAR (_ap [0]. _t2, NULL,
                                             "index type non-scalar"));
		
	}
} break;
case 212:
# line 1664 "1A00.attrib"
{ ac _L2L_;
{ _L2L_ = _ap [0]. _t2;
		
	_ap += -1;
_ap [0]. _t2 =_L2L_;
	}
} break;
case 213:
# line 1667 "1A00.attrib"
{{ s_next (_ap [1]. _t2, _ap [0]. _t2);
		  _ap [1]. _t2 = _ap [0]. _t2;
		
	_ap += 1;
	}
} break;
case 215:
# line 1673 "1A00.attrib"
{{ _ap [0]. _t2 = get_name_from_expr (_ap [0]. _t2);
		  _ap [0]. _t2 = IS_SCALAR (_ap [0]. _t2, g_tag (base_type (_ap [0]. _t2)),
			"Cannot handle non-scalar type %s in discrete range");
	          _ap [0]. _t2 = mk_range (_ap [0]. _t2, NULL, NULL);
		
	}
} break;
case 216:
# line 1679 "1A00.attrib"
{ ac _L1L_;
{ s_rangetype (_ap [0]. _t2, _ap [1]. _t2);
		  _ap [1]. _t2 = IS_SCALAR (_ap [1]. _t2, g_tag (_ap [1]. _t2),
			"Cannot handle non-scalar type %s in discrete range");
		  _L1L_ = _ap [0]. _t2;
		
	_ap += 1;
_ap [0]. _t2 =_L1L_;
	}
} break;
case 217:
# line 1687 "1A00.attrib"
{ ac _L1L_;
 ac _L2L_;
{ ac uncons, subt;
		  ac t;
		  _ap [0]. _t2 = CONST_TYPE (_ap [0]. _t2, NULL,
		             "Array element type insufficiently constrained");
		  uncons = conv_array (NULL, _ap [0]. _t2);
		  if (has_eq_and_ass (_ap [0]. _t2))
		     s_flags (uncons, g_flags (uncons) | HAS_ASSIGN);
		  INTRODUCE (uncons);
		  t = bu_filter (mk_filter (uncons, _ap [2]. _t2));
		  set_indices (uncons, _ap [2]. _t2);
		  subt = TD_FILTER (t, "Error in implied array", NULL);
		  t = mk_subtype (mk_tag (gen_tag (), IDL), subt);
		  INTRODUCE (t);
		  _L1L_ = uncons;
		  _L2L_ = t;
		
	_ap += 1;
_ap [1]. _t2 =_L1L_;
_ap [0]. _t2 =_L2L_;
	}
} break;
case 218:
# line 1705 "1A00.attrib"
{ ac _L1L_;
{ if (_ap [0]. _t2 == notype) {
		     error ("Subtype %s declared as integer", yypvt[-2].p_char);
		     _ap [0]. _t2 = std_integer;
		  }
		  _L1L_ = mk_subtype (yypvt[-2].p_char, _ap [0]. _t2);
		  if (is_sttype (_ap [0]. _t2))
		     set_sttype (_L1L_);
		  PREDECL (_L1L_);
		
_ap [0]. _t2 =_L1L_;
	}
} break;
case 220:
# line 1719 "1A00.attrib"
{{ _ap [1]. _t2 = SOLVE_FILTER (mk_filter (_ap [1]. _t2, _ap [0]. _t2), _ap [1]. _t2, NULL,
					    "type error in subtype constraint");
		
	_ap += 1;
	}
} break;
case 221:
# line 1725 "1A00.attrib"
{{ ac p, q;
		  if (g_d (_ap [0]. _t2) == XFILTER) {
		     p = mk_subtype (mk_tag (gen_tag (), IDL), _ap [0]. _t2);
		     if (is_sttype (_ap [0]. _t2))
		        set_sttype (p);
		     INTRODUCE (p);
		     _ap [0]. _t2 = p;
		  }
		
	}
} break;
case 223:
# line 1738 "1A00.attrib"
{{ _ap [0]. _t2 = type_name (td_n_name (bu_name (_ap [0]. _t2)));
		
	}
} break;
case 224:
# line 1742 "1A00.attrib"
{{ if (_ap [0]. _t2 == NULL)
		     _ap [0]. _t2 = any_type;
		  else
		     _ap [0]. _t2 = c_typename (_ap [0]. _t2);
		
	}
} break;
case 225:
# line 1749 "1A00.attrib"
{{ if (_ap [0]. _t2 == NULL)
		     _ap [0]. _t2 = any_type;
		  else
		     _ap [0]. _t2 = c_typename (_ap [0]. _t2);
		
	}
} break;
case 226:
# line 1757 "1A00.attrib"
{{ if (!is_scalar (_ap [1]. _t2)) {
		     error ("Cannot take range constraint on non scalar");
		  }
		
	}
} break;
case 234:
# line 1778 "1A00.attrib"
{{ LIST_INTRO (_ap [1]. _t2, "error in record component %s");
		  off_intro (_ap [1]. _t2);
		  if (!has_eq_and_ass (_ap [1]. _t2))
		     no_eq_and_ass_in (_ap [5]. _t2);
		
	_ap += 2;
	}
} break;
case 235:
# line 1786 "1A00.attrib"
{ ac _L1L_;
 ac _L2L_;
{ ac t = NULL;
		  _ap [0]. _t2 = SOLVE_EXPR (_ap [0]. _t2, _ap [1]. _t2, "error in default expression");
		  if (_ap [0]. _t2 != NULL)
		     t = mk_thunk (_ap [0]. _t2);
		  _ap [1]. _t2 = CONST_TYPE (_ap [1]. _t2, "type in %s not constrained", yypvt[-3].p_char);
		  _L2L_ = mk_desc (_ap [1]. _t2, KCOMP, t);
		  _L1L_ = mk_object (yypvt[-3].p_char, _L2L_);
		
_ap [1]. _t2 =_L1L_;
_ap [0]. _t2 =_L2L_;
	}
} break;
case 236:
# line 1795 "1A00.attrib"
{{ ac t = mk_object (yypvt[-2].p_char, cp_tree (_ap [0]. _t2));
		  s_next (t, _ap [1]. _t2);
		  _ap [1]. _t2 = t;
		
	}
} break;
case 237:
# line 1810 "1A00.attrib"
 {
_ap += 4; } break;
case 238:
# line 1814 "1A00.attrib"
{	_ap -= 4;
{ ac xx;
		  if ((xx = res_param (_ap [6]. _t2, yypvt[-1].p_char)) == NULL)
		     error ("%s case selector, no discriminant", yypvt[-1].p_char);
		  s_dis (_ap [6]. _t2, mk_rsel (xx));
		  _ap [3]. _t2 = _ap [6]. _t2;	/* just a copy */
		  _ap [0]. _t0 = FALSE;	/* local others flag	*/
		}
} break;
case 239:
# line 1824 "1A00.attrib"
{{ s_fvariant (_ap [3]. _t2, _ap [2]. _t2);
		}
} break;
case 241:
# line 1830 "1A00.attrib"
{{  if (g_dis (_ap [2]. _t2) != NULL) {
		      ac dt = type_of (g_comp (g_dis (_ap [2]. _t2)));
		      CHECK_VARIANT (_ap [2]. _t2, dt,
		                           "illegal ranges in variant %s", 
                                           encl_rectype (_ap [3]. _t2) );
		  }
		  restore_env (_ap [2]. _t2, _ap [1]. _t2);
		}
} break;
case 242:
# line 1841 "1A00.attrib"
{{ _ap [4]. _t2 = mk_varnode ();
		  INTRODUCE (_ap [4]. _t2);
		  if (_ap [2]. _t0)
		     warning ("too much alternatives %s", g_tag (_ap [5]. _t2));
		  _ap [2]. _t0 = _ap [0]. _t0;
		  s_varchoice (_ap [4]. _t2, _ap [1]. _t2);
		  _ap [3]. _t2 = NEWSCOPE (_ap [4]. _t2);
		
	_ap += 2;
	}
} break;
case 243:
# line 1851 "1A00.attrib"
{	_ap -= 2;
{ _ap [1]. _t2 = mk_range (NULL, NULL, NULL);
		  _ap [0]. _t0 = TRUE;
		}
} break;
case 244:
# line 1855 "1A00.attrib"
{ bool _L2L_;
{ _L2L_ = FALSE;
		
_ap [0]. _t0 =_L2L_;
	}
} break;
case 245:
# line 1859 "1A00.attrib"
{ ac _L2L_;
{ _L2L_ = _ap [0]. _t2;
		
	_ap += -1;
_ap [0]. _t2 =_L2L_;
	}
} break;
case 246:
# line 1862 "1A00.attrib"
{{ s_next (_ap [1]. _t2, _ap [0]. _t2);
		  _ap [1]. _t2 = _ap [0]. _t2;
		
	_ap += 1;
	}
} break;
case 247:
# line 1867 "1A00.attrib"
{ ac _L1L_;
{ s_rangetype (_ap [0]. _t2, _ap [1]. _t2);
		  bu_expr (_ap [0]. _t2);
		  _L1L_ = _ap [0]. _t2;
		
	_ap += 1;
_ap [0]. _t2 =_L1L_;
	}
} break;
case 248:
# line 1872 "1A00.attrib"
{{ _ap [0]. _t2 = bu_expr (mk_range (NULL, _ap [0]. _t2, NULL));
		
	}
} break;
case 249:
# line 1875 "1A00.attrib"
{{ _ap [0]. _t2 = bu_expr (_ap [0]. _t2);
		
	}
} break;
case 251:
# line 1882 "1A00.attrib"
 {
_ap += 1; } break;
case 252:
# line 1885 "1A00.attrib"
{ ac _L2L_;
{ _L2L_ = _ap [0]. _t2;
		
	_ap += -1;
_ap [0]. _t2 =_L2L_;
	}
} break;
case 253:
# line 1888 "1A00.attrib"
{{ s_next (_ap [1]. _t2, _ap [0]. _t2);
		  _ap [1]. _t2 = _ap [0]. _t2;
		
	_ap += 1;
	}
} break;
case 254:
# line 1893 "1A00.attrib"
{{ _ap [0]. _t2 = mk_component (NULL, _ap [0]. _t2);
		
	}
} break;
case 255:
# line 1896 "1A00.attrib"
{ ac _L1L_;
{ s_rangetype (_ap [0]. _t2, _ap [1]. _t2);
		  _L1L_ = mk_component (NULL, _ap [0]. _t2);
		
	_ap += 1;
_ap [0]. _t2 =_L1L_;
	}
} break;
case 256:
# line 1900 "1A00.attrib"
{{ _ap [0]. _t2 = mk_component (NULL, _ap [0]. _t2);
		
	}
} break;
case 257:
# line 1903 "1A00.attrib"
{ ac _L1L_;
{ _L1L_ = mk_component (NULL, _ap [0]. _t2);
		
_ap [0]. _t2 =_L1L_;
	}
} break;
case 258:
# line 1905 "1A00.attrib"
 {
_ap += 1; } break;
case 259:
# line 1909 "1A00.attrib"
{ ac _L2L_;
{ _ap [2]. _t2 = mk_component (_ap [2]. _t2, _ap [0]. _t2);
		
	_ap += 1;
_ap [0]. _t2 =_L2L_;
	}
} break;
case 260:
# line 1914 "1A00.attrib"
{	_ap -= 2;
{ _ap [0]. _t3 = COMP_OTHERS;
		  _ap [1]. _t2 = mk_range (NULL, NULL, NULL);
		}
} break;
case 261:
# line 1918 "1A00.attrib"
{ int _L2L_;
{ _L2L_ = COMP_ASSOC;
		
_ap [0]. _t3 =_L2L_;
	}
} break;
case 262:
# line 1923 "1A00.attrib"
{	_ap -= 2;
{ _ap [1]. _t2 = mk_range (NULL,
		          mk_expr (NULL, mk_applied (mk_unresrec (yypvt[-0].p_char))), NULL);
		  _ap [0]. _t2 = _ap [1]. _t2;
		}
} break;
case 263:
# line 1928 "1A00.attrib"
{{ ac t = mk_range (NULL,
		            mk_expr (NULL, mk_applied (mk_unresrec (yypvt[-0].p_char))), NULL);
		  s_next (_ap [0]. _t2, t);
		  _ap [0]. _t2 = t;
		
	}
} break;
case 264:
# line 1935 "1A00.attrib"
{{ _ap [1]. _t2 = mk_range (NULL, _ap [1]. _t2, _ap [0]. _t2);
		
	_ap += 1;
	}
} break;
case 265:
# line 1938 "1A00.attrib"
{{ ac t = mk_attr (A_RANGE, NULL);
		  s_next (t, _ap [0]. _t2);
		  _ap [0]. _t2 = mk_range (NULL, mk_expr (NULL, t), NULL);
		
	}
} break;
case 268:
# line 1948 "1A00.attrib"
{{  s_rettype (_ap [3]. _t2, _ap [0]. _t2);
		   DELSCOPE (_ap [3]. _t2, _ap [2]. _t2);
		
	_ap += 3;
	}
} break;
case 269:
# line 1953 "1A00.attrib"
{{ s_rettype (_ap [2]. _t2, notype);
		  DELSCOPE (_ap [2]. _t2, _ap [1]. _t2);
		
	_ap += 2;
	}
} break;
case 270:
# line 1958 "1A00.attrib"
{	_ap -= 3;
{ _ap [2]. _t2 = mk_sub (yypvt[-0].p_char, FALSE);
		  _ap [1]. _t2  = NEWSCOPE (_ap [2]. _t2);
		  _ap [0]. _t3 = 0;
		}
} break;
case 271:
# line 1963 "1A00.attrib"
{	_ap -= 3;
{ _ap [2]. _t2 = mk_sub (string_to_tag (yypvt[-0].p_char), TRUE);
		  _ap [1]. _t2 = NEWSCOPE (_ap [2]. _t2);
		  _ap [0]. _t3= 0;
		}
} break;
case 272:
# line 1969 "1A00.attrib"
{	_ap -= 3;
{ _ap [2]. _t2 = mk_sub (yypvt[-0].p_char, FALSE);
		  _ap [1]. _t2  = NEWSCOPE (_ap [2]. _t2);
		  _ap [0]. _t3 = 0;
		}
} break;
case 274:
# line 1976 "1A00.attrib"
{{ if (is_std_fn (_ap [2]. _t2)) {
		     ch_funpars (_ap [2]. _t2, _ap [0]. _t3);
		  }
		  off_intro (g_fformal (_ap [2]. _t2));
		}
} break;
case 276:
# line 1984 "1A00.attrib"
{{ off_intro (g_fformal (_ap [2]. _t2));
		}
} break;
case 277:
# line 1989 "1A00.attrib"
{{ _ap [3]. _t3 = _ap [1]. _t3;
		  LIST_INTRO (_ap [2]. _t2, "parameter %s not unique");
		
	_ap += 3;
	}
} break;
case 278:
# line 1993 "1A00.attrib"
{{ _ap [3]. _t3 = _ap [3]. _t3 + _ap [1]. _t3;
		  LIST_INTRO (_ap [2]. _t2, "parameter %s not unique");
		
	_ap += 3;
	}
} break;
case 279:
# line 1999 "1A00.attrib"
{{ _ap [3]. _t3 = _ap [1]. _t3;
		  LIST_INTRO (_ap [2]. _t2, "parameter %s not unique");
		
	_ap += 3;
	}
} break;
case 280:
# line 2003 "1A00.attrib"
{{ _ap [3]. _t3 = _ap [3]. _t3 + _ap [1]. _t3;
		  LIST_INTRO (_ap [2]. _t2, "parameter %s not unique");
		
	_ap += 3;
	}
} break;
case 281:
# line 2008 "1A00.attrib"
{ ac _L1L_;
 int _L2L_;
 ac _L3L_;
{ _L1L_ = mk_object (yypvt[-2].p_char, _ap [0]. _t2);
		  _L2L_ = 1;
		  _L3L_ = _ap [0]. _t2;
		
	_ap += -2;
_ap [2]. _t2 =_L1L_;
_ap [1]. _t3 =_L2L_;
_ap [0]. _t2 =_L3L_;
	}
} break;
case 282:
# line 2013 "1A00.attrib"
{{ ac t = mk_object (yypvt[-2].p_char, cp_tree (_ap [0]. _t2));
		  s_next (t, _ap [2]. _t2);
		  _ap [1]. _t3 += 1;
		  _ap [2]. _t2 = t;
		
	}
} break;
case 283:
# line 2020 "1A00.attrib"
{ ac _L1L_;
 int _L2L_;
 ac _L3L_;
{ ac t = mk_object (yypvt[-2].p_char, _ap [0]. _t2);
		  _L2L_ = 1;
		  _L3L_ = _ap [0]. _t2;
		  _L1L_ = t;
		
	_ap += -2;
_ap [2]. _t2 =_L1L_;
_ap [1]. _t3 =_L2L_;
_ap [0]. _t2 =_L3L_;
	}
} break;
case 284:
# line 2026 "1A00.attrib"
{{ ac t = mk_object (yypvt[-2].p_char, cp_tree (_ap [0]. _t2));
		  _ap [1]. _t3 += 1;
		  s_next (t, _ap [2]. _t2);
		  _ap [2]. _t2 = t;
		
	}
} break;
case 285:
# line 2033 "1A00.attrib"
{ ac _L1L_;
{ _ap [0]. _t2 = SOLVE_EXPR (_ap [0]. _t2, _ap [1]. _t2, "type error in default");
		  _L1L_ = mk_desc (_ap [1]. _t2, INMODE, _ap [0]. _t2);
		
	_ap += 1;
_ap [0]. _t2 =_L1L_;
	}
} break;
case 286:
# line 2037 "1A00.attrib"
{ ac _L1L_;
{ _ap [0]. _t2 = SOLVE_EXPR (_ap [0]. _t2, _ap [1]. _t2, "type error in default");
		  _L1L_ = mk_desc (_ap [1]. _t2, INMODE, _ap [0]. _t2);
		
	_ap += 1;
_ap [0]. _t2 =_L1L_;
	}
} break;
case 288:
# line 2043 "1A00.attrib"
{ ac _L1L_;
{ _L1L_ = mk_desc (_ap [0]. _t2, OUTMODE, NULL);
		
_ap [0]. _t2 =_L1L_;
	}
} break;
case 289:
# line 2046 "1A00.attrib"
{ ac _L1L_;
{ _L1L_ = mk_desc (_ap [0]. _t2, INOUTMODE, NULL);
		
_ap [0]. _t2 =_L1L_;
	}
} break;
case 293:
# line 2054 "1A00.attrib"
{{ ac t;
		  _ap [1]. _t2 = CONST_TYPE (_ap [1]. _t2, "Unconstrained type %s", yypvt[-4].p_char);
		  t = mk_renobj (yypvt[-4].p_char, _ap [1]. _t2);
		  s_name (t, c_object (td_name (bu_name (_ap [0]. _t2), _ap [1]. _t2)));
		  OBJDECL (t, "%s (renaming declaration) not unique");
		
	_ap += 2;
	}
} break;
case 294:
# line 2062 "1A00.attrib"
{{ ac t = mk_rensub (_ap [1]. _t2);
		  ac t2 = FIND_RENAMEDSUBS (t, g_primary (bu_expr (_ap [0]. _t2)),
		                 "Error in renamed sub %s\n");
		  if (t2 != NULL)
		  {  chk_6_7_5 (t, t2);
		     s_subname (t, t2);
		     INTRODUCE (t);
		  }
		
	_ap += 2;
	}
} break;
case 295:
# line 2073 "1A00.attrib"
{{ ac t;
		  t = pack_name (td_n_name (bu_name (_ap [0]. _t2)));
		  if (t != NULL) {
		     t = mk_renpack (yypvt[-2].p_char, t);
		     OBJDECL (t, "%s declared twice");
		     off_intro (t);
		  }
		
	_ap += 1;
	}
} break;
case 296:
# line 2084 "1A00.attrib"
{ ac _L2L_;
 int _L3L_;
{ _L2L_ = _ap [1]. _t2;
		  _ap [1]. _t2 = mk_aggnode (_ap [1]. _t2, any_aggregate);
		  _L3L_ = _ap [0]. _t3;
		
	_ap += -1;
_ap [1]. _t2 =_L2L_;
_ap [0]. _t3 =_L3L_;
	}
} break;
case 297:
# line 2089 "1A00.attrib"
{ ac _L1L_;
 ac _L2L_;
 int _L3L_;
{ ac t = mk_component (NULL, _ap [2]. _t2);
		  s_next (t, _ap [1]. _t2);
		  _L1L_ = mk_aggnode (t, any_aggregate);
		  _L2L_ = _ap [1]. _t2;
		  _L3L_ = _ap [0]. _t3;
		
_ap [2]. _t2 =_L1L_;
_ap [1]. _t2 =_L2L_;
_ap [0]. _t3 =_L3L_;
	}
} break;
case 298:
# line 2097 "1A00.attrib"
{{ component_ordering (_ap [2]. _t3, _ap [0]. _t3, "illegal ordering in aggregate comp's\n");
		  s_next (_ap [3]. _t2, _ap [1]. _t2);
		  _ap [3]. _t2 = _ap [1]. _t2;
		  _ap [2]. _t3 = _ap [0]. _t3;
		
	_ap += 2;
	}
} break;
case 299:
# line 2105 "1A00.attrib"
{ int _L2L_;
{ _ap [0]. _t2 = mk_component (NULL, _ap [0]. _t2);
		  _L2L_ = COMP_EXPR;
		
	_ap += -1;
_ap [0]. _t3 =_L2L_;
	}
} break;
case 301:
# line 2112 "1A00.attrib"
{ ac _L1L_;
 int _L2L_;
{ _L1L_ = mk_component (_ap [2]. _t2, _ap [0]. _t2);
		  _L2L_ = _ap [1]. _t3 ? COMP_OTHERS : COMP_ASSOC;
		
	_ap += 1;
_ap [1]. _t2 =_L1L_;
_ap [0]. _t3 =_L2L_;
	}
} break;
case 302:
# line 2118 "1A00.attrib"
{	_ap -= 2;
{ _ap [1]. _t2 = mk_range (NULL, NULL, NULL);
		  _ap [0]. _t3 = TRUE;
		}
} break;
case 303:
# line 2122 "1A00.attrib"
{ int _L2L_;
{ _L2L_ = FALSE;
		
_ap [0]. _t3 =_L2L_;
	}
} break;
case 304:
# line 2127 "1A00.attrib"
{ ac _L2L_;
{ _L2L_ = _ap [0]. _t2;
		
	_ap += -1;
_ap [0]. _t2 =_L2L_;
	}
} break;
case 305:
# line 2130 "1A00.attrib"
{{ s_next (_ap [1]. _t2, _ap [0]. _t2);
		  _ap [1]. _t2 = _ap [0]. _t2;
		
	_ap += 1;
	}
} break;
case 306:
# line 2135 "1A00.attrib"
{ ac _L1L_;
{ s_rangetype (_ap [0]. _t2, _ap [1]. _t2);
		  _L1L_ = _ap [0]. _t2;
		
	_ap += 1;
_ap [0]. _t2 =_L1L_;
	}
} break;
case 307:
# line 2139 "1A00.attrib"
{	_ap -= 1;
{ ac p;
		  _ap [0]. _t2 = mk_range (NULL, mk_expr (NULL,
				        mk_applied (mk_unresrec (yypvt[-0].p_char))), NULL);
		}
} break;
case 308:
# line 2144 "1A00.attrib"
{{ _ap [0]. _t2 = mk_range (NULL, _ap [0]. _t2, NULL);
		
	}
} break;
case 310:
# line 2149 "1A00.attrib"
{	_ap -= 1;
{ _ap [0]. _t2 = NULL;
		}
} break;
case 312:
# line 2155 "1A00.attrib"
{{ _ap [0]. _t2 = bu_expr (_ap [0]. _t2);
		
	}
} break;
case 313:
# line 2159 "1A00.attrib"
 {
_ap += 2; } break;
case 314:
# line 2161 "1A00.attrib"
 {
_ap += 1; } break;
case 315:
# line 2165 "1A00.attrib"
{ int _L2L_;
{ _L2L_ = NULL;
		
	_ap += -1;
_ap [0]. _t3 =_L2L_;
	}
} break;
case 316:
# line 2168 "1A00.attrib"
{{ if (_ap [3]. _t3 == NULL || _ap [3]. _t3 == _ap [1]. _t3) {
		     _ap [3]. _t3 = _ap [1]. _t3;
		     if (is_and_then (_ap [3]. _t3))
		        _ap [4]. _t2 = mk_andthen (_ap [4]. _t2, _ap [0]. _t2, _ap [3]. _t3);
		     else
		        _ap [4]. _t2 = call_std_function (_ap [2]. _t4, _ap [4]. _t2, _ap [0]. _t2);
		  }
		  else
		     error ("illegal operator sequence");
		
	_ap += 3;
	}
} break;
case 318:
# line 2181 "1A00.attrib"
{{ ac t;
		  if (is_NOT_EQ (yypvt[-1].p_char)) {
		     t = call_std_function (mk_tag ("=", 2), _ap [1]. _t2, _ap [0]. _t2);
		     _ap [1]. _t2 = call_std_function (mk_tag ("NOT", 4), t, NULL);
		  }
		  else
		     _ap [1]. _t2 = call_std_function (yypvt[-1].p_char, _ap [1]. _t2, _ap [0]. _t2);
		
	_ap += 1;
	}
} break;
case 319:
# line 2190 "1A00.attrib"
{ ac _L1L_;
{ ac t;
		  if (_ap [2]. _t2 != NULL && _ap [0]. _t2 != NULL) {
		     _L1L_ = mk_expr (NULL, mk_in (_ap [2]. _t2,  mk_filter (NULL, _ap [0]. _t2), _ap [1]. _t0));
		  }
		  else
		     _L1L_ = NULL;
		
	_ap += 2;
_ap [0]. _t2 =_L1L_;
	}
} break;
case 320:
# line 2199 "1A00.attrib"
{	_ap -= 2;
{ _ap [0]. _t3 = T_AND;
		  _ap [1]. _t4 = mk_tag ("AND", 4);
		}
} break;
case 321:
# line 2203 "1A00.attrib"
{	_ap -= 2;
{ _ap [0]. _t3 = T_OR;
		  _ap [1]. _t4 = mk_tag ("OR", 3);
		}
} break;
case 322:
# line 2207 "1A00.attrib"
{	_ap -= 2;
{ _ap [0]. _t3 = T_XOR;
		  _ap [1]. _t4 = mk_tag ("XOR", 4);
		}
} break;
case 323:
# line 2211 "1A00.attrib"
{	_ap -= 2;
{ _ap [0]. _t3 = S_AND_THEN;
		  _ap [1]. _t4 = NULL;
		}
} break;
case 324:
# line 2215 "1A00.attrib"
{	_ap -= 2;
{ _ap [0]. _t3 = S_OR_ELSE;
		  _ap [1]. _t4 = NULL;
		}
} break;
case 325:
# line 2220 "1A00.attrib"
{	_ap -= 1;
{ _ap [0]. _t0 = FALSE;
		}
} break;
case 326:
# line 2223 "1A00.attrib"
{	_ap -= 1;
{ _ap [0]. _t0 = TRUE;
		}
} break;
case 328:
# line 2228 "1A00.attrib"
{ ac _L1L_;
{ _L1L_ = call_std_function (_ap [1]. _t4, _ap [0]. _t2, NULL);
		
	_ap += 1;
_ap [0]. _t2 =_L1L_;
	}
} break;
case 329:
# line 2231 "1A00.attrib"
{{ _ap [2]. _t2 = call_std_function (_ap [1]. _t4, _ap [2]. _t2, _ap [0]. _t2);
		
	_ap += 2;
	}
} break;
case 331:
# line 2236 "1A00.attrib"
{{ _ap [2]. _t2 = call_std_function (_ap [1]. _t4, _ap [2]. _t2, _ap [0]. _t2);
		
	_ap += 2;
	}
} break;
case 332:
# line 2240 "1A00.attrib"
{	_ap -= 1;
{ _ap [0]. _t4 = yypvt[-0].p_char;
		}
} break;
case 333:
# line 2243 "1A00.attrib"
{	_ap -= 1;
{ _ap [0]. _t4 = yypvt[-0].p_char;
		}
} break;
case 334:
# line 2246 "1A00.attrib"
{	_ap -= 1;
{ _ap [0]. _t4 = mk_tag ("NOT", 4);
		}
} break;
case 335:
# line 2249 "1A00.attrib"
{	_ap -= 1;
{ _ap [0]. _t4 = mk_tag ("ABS", 4);
		}
} break;
case 336:
# line 2253 "1A00.attrib"
{	_ap -= 1;
{ _ap [0]. _t4 = yypvt[-0].p_char;
		}
} break;
case 337:
# line 2256 "1A00.attrib"
{	_ap -= 1;
{ _ap [0]. _t4 = yypvt[-0].p_char;
		}
} break;
case 338:
# line 2259 "1A00.attrib"
{	_ap -= 1;
{ _ap [0]. _t4 = yypvt[-0].p_char;
		}
} break;
case 339:
# line 2263 "1A00.attrib"
{	_ap -= 1;
{ _ap [0]. _t4 = yypvt[-0].p_char;
		}
} break;
case 340:
# line 2266 "1A00.attrib"
{	_ap -= 1;
{ _ap [0]. _t4 = yypvt[-0].p_char;
		}
} break;
case 341:
# line 2269 "1A00.attrib"
{	_ap -= 1;
{ _ap [0]. _t4 = mk_tag ("MOD", 4);
		}
} break;
case 342:
# line 2272 "1A00.attrib"
{	_ap -= 1;
{ _ap [0]. _t4 = mk_tag ("REM", 4);
		}
} break;
case 344:
# line 2277 "1A00.attrib"
{{ _ap [1]. _t2 = call_std_function (yypvt[-1].p_char, _ap [1]. _t2, _ap [0]. _t2);
		
	_ap += 1;
	}
} break;
case 345:
# line 2281 "1A00.attrib"
{{ _ap [0]. _t2 = mk_expr (NULL, _ap [0]. _t2);
		
	}
} break;
case 346:
# line 2284 "1A00.attrib"
{	_ap -= 1;
{ _ap [0]. _t2 = mk_expr (NULL, mk_applied (mk_unchar (yypvt[-0].f_int)));
		}
} break;
case 347:
# line 2287 "1A00.attrib"
{{ _ap [0]. _t2 = mk_expr (NULL, _ap [0]. _t2);
		
	}
} break;
case 348:
# line 2290 "1A00.attrib"
{{ _ap [0]. _t2 = mk_expr (any_access_type, _ap [0]. _t2);
		
	}
} break;
case 350:
# line 2294 "1A00.attrib"
{{ _ap [1]. _t2 = mk_expr (NULL, mk_parexpr (_ap [1]. _t2));
		
	_ap += 1;
	}
} break;
case 351:
# line 2297 "1A00.attrib"
{{ _ap [0]. _t2 = mk_expr (NULL, _ap [0]. _t2);
		
	}
} break;
case 352:
# line 2301 "1A00.attrib"
{	_ap -= 1;
{ _ap [0]. _t2 = mk_literal (yypvt[-0].p_char, std_univ);
		}
} break;
case 353:
# line 2304 "1A00.attrib"
{	_ap -= 1;
{ _ap [0]. _t2 = mk_literal (yypvt[-0].p_char, std_real);
		}
} break;
case 354:
# line 2307 "1A00.attrib"
{	_ap -= 1;
{ _ap [0]. _t2 = mk_literal (alloc_lit (S_NULLLIT, "", 1), any_access_type);
		}
} break;
case 355:
# line 2310 "1A00.attrib"
{	_ap -= 1;
{ _ap [0]. _t2 = mk_literal (yypvt[-0].p_char, any_string_type);
		}
} break;
case 356:
# line 2314 "1A00.attrib"
{ ac _L1L_;
{ _L1L_ = mk_alloc (mk_filter (_ap [1]. _t2, _ap [0]. _t2), any_access_type);
		
	_ap += 1;
_ap [0]. _t2 =_L1L_;
	}
} break;
case 357:
# line 2317 "1A00.attrib"
{ ac _L1L_;
{ _L1L_ = mk_alloc (_ap [0]. _t2, any_access_type);
		
_ap [0]. _t2 =_L1L_;
	}
} break;
case 358:
# line 2325 "1A00.attrib"
{ ac _L1L_;
{ s_aggtype (_ap [2]. _t2, _ap [3]. _t2);
		  _L1L_ = mk_alloc (mk_expr (NULL, _ap [2]. _t2), any_access_type);
		
	_ap += 3;
_ap [0]. _t2 =_L1L_;
	}
} break;
case 359:
# line 2329 "1A00.attrib"
{ ac _L1L_;
{ s_exptype (_ap [0]. _t2, _ap [1]. _t2);
		  _L1L_ = mk_alloc (_ap [0]. _t2, any_access_type);
		
	_ap += 1;
_ap [0]. _t2 =_L1L_;
	}
} break;
case 360:
# line 2334 "1A00.attrib"
{ ac _L1L_;
{ s_exptype (_ap [0]. _t2, _ap [1]. _t2);
		  _L1L_ = _ap [0]. _t2;
		
	_ap += 1;
_ap [0]. _t2 =_L1L_;
	}
} break;
case 361:
# line 2338 "1A00.attrib"
{ ac _L1L_;
{ s_aggtype (_ap [2]. _t2, _ap [3]. _t2);
		  _L1L_ = mk_expr (NULL, _ap [2]. _t2);
		
	_ap += 3;
_ap [0]. _t2 =_L1L_;
	}
} break;
case 362:
# line 2344 "1A00.attrib"
{{ _ap [0]. _t2 = c_typename (type_name (td_n_name (bu_name (_ap [0]. _t2))));
		
	}
} break;
case 363:
# line 2349 "1A00.attrib"
{ int _L2L_;
{ _L2L_ = ID_OPSYM;
		
	_ap += -1;
_ap [0]. _t3 =_L2L_;
	}
} break;
case 364:
# line 2352 "1A00.attrib"
{	_ap -= 2;
{ _ap [0]. _t3 = CH_LIT;
		  _ap [1]. _t4 = mk_chartag (yypvt[-0].f_int);
		}
} break;
case 365:
# line 2357 "1A00.attrib"
{	_ap -= 1;
{ _ap [0]. _t4 = yypvt[-0].p_char;
		}
} break;
case 366:
# line 2360 "1A00.attrib"
{	_ap -= 1;
{ _ap [0]. _t4 = string_to_tag (yypvt[-0].p_char);
	          if (!std_oper (_ap [0]. _t4))
		     warning ("illegal standard operator %s", _ap [0]. _t4);
		}
} break;
case 367:
# line 2366 "1A00.attrib"
{	_ap -= 1;
{ _ap [0]. _t2 = mk_applied (mk_unresrec (yypvt[-0].p_char));
		}
} break;
case 368:
# line 2371 "1A00.attrib"
{{ _ap [2]. _t2 = mk_select (_ap [2]. _t2, _ap [1]. _t4, _ap [0]. _t3);
		
	_ap += 2;
	}
} break;
case 369:
# line 2374 "1A00.attrib"
{{ _ap [2]. _t2 = mk_select (_ap [2]. _t2, _ap [1]. _t4, _ap [0]. _t3);
		
	_ap += 2;
	}
} break;
case 370:
# line 2378 "1A00.attrib"
{{ _ap [0]. _t2 = simple_name (td_n_name (bu_name (_ap [0]. _t2)));
		
	}
} break;
case 374:
# line 2387 "1A00.attrib"
{{ if (g_attr_value (_ap [0]. _t2) == A_BASE) {
		     error ("illegal use of base atribute, ignored");
		  }
		  else
		  { s_next (_ap [0]. _t2, _ap [1]. _t2);
		    _ap [1]. _t2 = _ap [0]. _t2;
		  }
		
	_ap += 1;
	}
} break;
case 376:
# line 2398 "1A00.attrib"
{{ _ap [1]. _t2 = mk_select (_ap [1]. _t2, _ap [0]. _t4, ID_OPSYM);
		
	_ap += 1;
	}
} break;
case 377:
# line 2401 "1A00.attrib"
{{ _ap [0]. _t2 = mk_all (_ap [0]. _t2);
		
	}
} break;
case 378:
# line 2404 "1A00.attrib"
{{ _ap [0]. _t2 = mk_all (_ap [0]. _t2);
		
	}
} break;
case 379:
# line 2407 "1A00.attrib"
{{ _ap [0]. _t2 = mk_all (_ap [0]. _t2);
		
	}
} break;
case 380:
# line 2410 "1A00.attrib"
{{ if (g_attr_value (_ap [0]. _t2) != A_BASE) {
		     error ("illegal attributing, only base attrib here");
		     s_attr_value (_ap [0]. _t2, A_BASE);
		  }
		  s_next (_ap [0]. _t2, _ap [1]. _t2);
		  _ap [1]. _t2 = _ap [0]. _t2;
		
	_ap += 1;
	}
} break;
case 381:
# line 2418 "1A00.attrib"
{{ if (_ap [1]. _t3 == XCALL)
		     _ap [3]. _t2 = mk_call (_ap [3]. _t2, _ap [2]. _t2);
		  else if (_ap [1]. _t3 == XSLICE)
		     _ap [3]. _t2 = mk_slice (_ap [3]. _t2, _ap [2]. _t2);
		  else
		     _ap [3]. _t2 = mk_arrselect (_ap [3]. _t2, _ap [2]. _t2);	/* name botch with index	*/
		
	_ap += 3;
	}
} break;
case 382:
# line 2427 "1A00.attrib"
{	_ap -= 1;
{ int t = srch_attr (yypvt[-0].p_char);
		  if (t >= 0)
		     _ap [0]. _t2 = mk_attr (t, NULL);
		  else
		     { error ("illegal attribute %s\n", yypvt[-0].p_char);
		       _ap [0]. _t2 = mk_attr (A_BASE, NULL);
		     }
		}
} break;
case 383:
# line 2436 "1A00.attrib"
{ ac _L1L_;
{ int t = srch_attr (yypvt[-3].p_char);
		  if (t >= 0)
		     _L1L_ = mk_attr (t, _ap [0]. _t2);
		  else
		     { error ("illegal attribute %s\n", yypvt[-3].p_char);
		       _L1L_ = mk_attr (A_BASE, NULL);
		     }
		
_ap [0]. _t2 =_L1L_;
	}
} break;
case 384:
# line 2447 "1A00.attrib"
{ ac _L1L_;
 ac _L3L_;
{ _L1L_ = _ap [1]. _t2;
		  _L3L_ = _ap [1]. _t2;
		
	_ap += -1;
_ap [2]. _t2 =_L1L_;
_ap [0]. _t2 =_L3L_;
	}
} break;
case 385:
# line 2451 "1A00.attrib"
{{ _ap [3]. _t3 = acceptable (_ap [3]. _t3, _ap [0]. _t3, "error in parameter/index list");
		  s_next (_ap [2]. _t2, _ap [1]. _t2);
		  _ap [2]. _t2 = _ap [1]. _t2;
		
	_ap += 2;
	}
} break;
case 386:
# line 2458 "1A00.attrib"
{ ac _L1L_;
 int _L2L_;
{ _L2L_ = XSLICE;
		  _L1L_ = _ap [0]. _t2;
		  s_rangetype (_L1L_, _ap [1]. _t2);
		
_ap [1]. _t2 =_L1L_;
_ap [0]. _t3 =_L2L_;
	}
} break;
case 387:
# line 2463 "1A00.attrib"
{ int _L2L_;
{ _L2L_ = XSLICE;
		
	_ap += -1;
_ap [0]. _t3 =_L2L_;
	}
} break;
case 388:
# line 2466 "1A00.attrib"
{ int _L2L_;
{ _L2L_ = XINDEXING;
		
	_ap += -1;
_ap [0]. _t3 =_L2L_;
	}
} break;
case 389:
# line 2469 "1A00.attrib"
{ int _L2L_;
{ _L2L_ = XCALL;
		
	_ap += -1;
_ap [0]. _t3 =_L2L_;
	}
} break;
case 390:
# line 2474 "1A00.attrib"
{{ _ap [0]. _t2 = mk_namass (yypvt[-2].p_char, _ap [0]. _t2);
		
	}
} break;
case 391:
# line 2478 "1A00.attrib"
{	_ap -= 1;
{ _ap [0]. _t2 = NULL;
		}
} break;
case 392:
# line 2481 "1A00.attrib"
{{ ac xx = nalloc (XEXHANDLER);
		  s_EXH_items (xx, _ap [2]. _t2);
		  _ap [2]. _t2 = xx;
		
	_ap += 2;
	}
} break;
case 393:
# line 2488 "1A00.attrib"
{{ _ap [2]. _t2 = _ap [0]. _t2;
		  _ap [3]. _t2 = _ap [0]. _t2;
		
	_ap += 1;
	}
} break;
case 394:
# line 2492 "1A00.attrib"
{{ s_next (_ap [2]. _t2, _ap [0]. _t2);
		  _ap [2]. _t2 = _ap [0]. _t2;
		
	_ap += 1;
	}
} break;
case 395:
# line 2498 "1A00.attrib"
{	_ap -= 3;
{ _ap [0]. _t0 = FALSE;
		  _ap [2]. _t2 = NULL;
		  _ap [1]. _t2 = NULL;
		  intro_ex_h ();
		}
} break;
case 396:
# line 2506 "1A00.attrib"
{{ s_WI_stats (_ap [2]. _t2, _ap [1]. _t2);
		
	_ap += 2;
	}
} break;
case 397:
# line 2510 "1A00.attrib"
{ ac _L1L_;
{ if (_ap [2]. _t0)
		     warning ("alternative following OTHERS");
		  _ap [2]. _t0 = _ap [0]. _t0;
		  _L1L_ = mk_whenitem (_ap [1]. _t2);
		
	_ap += 1;
_ap [0]. _t2 =_L1L_;
	}
} break;
case 398:
# line 2518 "1A00.attrib"
{	_ap -= 2;
{ _ap [1]. _t2 = mk_range (NULL, NULL, NULL);
		  _ap [0]. _t0 = TRUE;
		}
} break;
case 399:
# line 2522 "1A00.attrib"
{ bool _L2L_;
{ _L2L_ = FALSE;
		
_ap [0]. _t0 =_L2L_;
	}
} break;
case 400:
# line 2527 "1A00.attrib"
{ ac _L2L_;
{ chk_exceptions (_ap [3]. _t2, NULL, _ap [0]. _t2);
		  _L2L_ = _ap [0]. _t2;
		
	_ap += -1;
_ap [0]. _t2 =_L2L_;
	}
} break;
case 401:
# line 2531 "1A00.attrib"
{{ chk_exceptions (_ap [5]. _t2, _ap [2]. _t2, _ap [0]. _t2);
		  s_next (_ap [1]. _t2, _ap [0]. _t2);
		  _ap [1]. _t2 = _ap [0]. _t2;
		
	_ap += 1;
	}
} break;
case 402:
# line 2537 "1A00.attrib"
{{ _ap [0]. _t2 = get_exc (td_n_name (bu_name (_ap [0]. _t2)));
		  if (_ap [0]. _t2 != NULL) {
	             _ap [0]. _t2 = mk_range (NULL, mk_expr (NULL, mk_applied (_ap [0]. _t2)), NULL);
		  }
		  else
		     _ap [0]. _t2 = mk_range (NULL, NULL, NULL);	/* Other */
		
	}
} break;
case 403:
# line 2547 "1A00.attrib"
{ ac _L2L_;
{ _L2L_ = _ap [0]. _t2;
		
	_ap += -1;
_ap [0]. _t2 =_L2L_;
	}
} break;
case 404:
# line 2550 "1A00.attrib"
{{
		   if (_ap [1]. _t2 == NULL) {
		     _ap [2]. _t2 = _ap [0]. _t2;
		     _ap [1]. _t2 = _ap [0]. _t2;
		  }
		  else
		  if (_ap [0]. _t2 != NULL) {
		     s_next (_ap [1]. _t2, _ap [0]. _t2);
		     _ap [1]. _t2 = _ap [0]. _t2;
		  }
		
	_ap += 1;
	}
} break;
case 405:
# line 2563 "1A00.attrib"
{	_ap -= 1;
{ _ap [0]. _t2 = NULL;
		}
} break;
case 415:
# line 2578 "1A00.attrib"
 {
_ap += 1; } break;
case 416:
# line 2580 "1A00.attrib"
{{ s_next (_ap [1]. _t2, _ap [0]. _t2);
		
	_ap += 2;
	}
} break;
case 417:
# line 2584 "1A00.attrib"
{ ac _L2L_;
{ _L2L_ = g_IF_items (_ap [0]. _t2);
		
	_ap += -1;
_ap [0]. _t2 =_L2L_;
	}
} break;
case 418:
# line 2587 "1A00.attrib"
{{ s_next (_ap [1]. _t2, _ap [0]. _t2);
		  _ap [1]. _t2 = _ap [0]. _t2;
		
	_ap += 1;
	}
} break;
case 419:
# line 2592 "1A00.attrib"
{{ s_IF_stats (g_IF_items (_ap [2]. _t2), _ap [1]. _t2);
		
	_ap += 2;
	}
} break;
case 420:
# line 2596 "1A00.attrib"
{{ _ap [0]. _t2 = SOLVE_EXPR (bu_expr (_ap [0]. _t2), std_boolean,
		                             "illegal if expression");
		  _ap [0]. _t2 = mk_if (mk_ifitem (_ap [0]. _t2));
		
	}
} break;
case 421:
# line 2602 "1A00.attrib"
{{ s_IF_stats (_ap [2]. _t2, _ap [1]. _t2);
		
	_ap += 2;
	}
} break;
case 422:
# line 2606 "1A00.attrib"
{{ _ap [0]. _t2 = SOLVE_EXPR (bu_expr (_ap [0]. _t2), std_boolean,
			                        "illegal if expression");
		  _ap [0]. _t2 = mk_ifitem (_ap [0]. _t2);
		
	}
} break;
case 423:
# line 2612 "1A00.attrib"
{{ s_IF_stats (_ap [2]. _t2, _ap [1]. _t2);
		
	_ap += 2;
	}
} break;
case 424:
# line 2616 "1A00.attrib"
{	_ap -= 1;
{ _ap [0]. _t2 = mk_ifitem (NULL);
		}
} break;
case 425:
# line 2620 "1A00.attrib"
{{ if (!verif_domain (stat_range (_ap [0]. _t2), _ap [1]. _t1, _ap [2]. _t3))
		        error ("domain error in case statement");
		  rem_list (_ap [1]. _t1);
		
	_ap += 4;
	}
} break;
case 426:
# line 2627 "1A00.attrib"
{{ s_CASE_items (_ap [5]. _t2, _ap [0]. _t2);
		  _ap [4]. _t2 = _ap [0]. _t2;
		
	_ap += 1;
	}
} break;
case 427:
# line 2631 "1A00.attrib"
{{ s_next (_ap [4]. _t2, _ap [0]. _t2);
		  _ap [4]. _t2 = _ap [0]. _t2;
		
	_ap += 1;
	}
} break;
case 428:
# line 2637 "1A00.attrib"
{{ s_WI_stats (_ap [2]. _t2, _ap [1]. _t2);
		
	_ap += 2;
	}
} break;
case 429:
# line 2642 "1A00.attrib"
{ ac _L1L_;
{ if (_ap [4]. _t0)
		     error ("alternative following OTHERS");
		  _ap [4]. _t0 = _ap [1]. _t0;
		  _L1L_ = mk_whenitem (_ap [0]. _t2);
		
	_ap += 1;
_ap [0]. _t2 =_L1L_;
	}
} break;
case 430:
# line 2650 "1A00.attrib"
{ ac _L1L_;
 ac _L2L_;
 int _L3L_;
 p_link _L4L_;
 ac _L5L_;
{ _ap [0]. _t2 = bu_expr (_ap [0]. _t2);
		  _ap [0]. _t2 = SOLVE_EXPR (_ap [0]. _t2, types_of (_ap [0]. _t2),
				"illegal type in choice");
		  if (_ap [0]. _t2 == NULL) {
		     _L5L_ = std_univ;
		  }
		  else
		  {  s_exptype (_ap [0]. _t2, IS_SCALAR (g_exptype (_ap [0]. _t2), NULL,
			               "non scalar type in choice"));
		     _L5L_ = g_exptype (_ap [0]. _t2);
		  }
		  _L1L_ = mk_case (_ap [0]. _t2);
		  _L3L_ = FALSE;
		  _L4L_ = new_list ();
		  _L2L_ = NULL;
		
	_ap += -4;
_ap [4]. _t2 =_L1L_;
_ap [3]. _t2 =_L2L_;
_ap [2]. _t3 =_L3L_;
_ap [1]. _t1 =_L4L_;
_ap [0]. _t2 =_L5L_;
	}
} break;
case 431:
# line 2669 "1A00.attrib"
{	_ap -= 2;
{ _ap [0]. _t2 = mk_range (NULL, NULL, NULL);
		  _ap [1]. _t0 = TRUE;
		}
} break;
case 432:
# line 2673 "1A00.attrib"
{ bool _L1L_;
 ac _L2L_;
{ _L1L_ = FALSE;
		  _L2L_ = _ap [1]. _t2;
		
_ap [1]. _t0 =_L1L_;
_ap [0]. _t2 =_L2L_;
	}
} break;
case 433:
# line 2679 "1A00.attrib"
{ ac _L1L_;
 ac _L2L_;
{ if (!_ap [3]. _t0) {
		     _ap [0]. _t2 = static_range (_ap [1]. _t2, _ap [0]. _t2);
		     if (_ap [0]. _t2 != NULL)
		        l_insert (_ap [0]. _t2, _ap [2]. _t1);
		  }
		  _L1L_ = _ap [0]. _t2;
		  _L2L_ = _ap [0]. _t2;
		
	_ap += -1;
_ap [1]. _t2 =_L1L_;
_ap [0]. _t2 =_L2L_;
	}
} break;
case 434:
# line 2688 "1A00.attrib"
{{ if (!_ap [5]. _t0) {
		     _ap [0]. _t2 = static_range (_ap [3]. _t2, _ap [0]. _t2);
		     if (_ap [0]. _t2 != NULL)
		        l_insert (_ap [0]. _t2, _ap [4]. _t1);
		  }
		  if (_ap [1]. _t2 == NULL) {
		     _ap [2]. _t2 = _ap [1]. _t2 = _ap [0]. _t2;
		  }
		  else
		  if (_ap [0]. _t2 != NULL) {
		     s_next (_ap [1]. _t2, _ap [0]. _t2);
		     _ap [1]. _t2 = _ap [0]. _t2;
		  }
		
	_ap += 1;
	}
} break;
case 435:
# line 2705 "1A00.attrib"
{{ s_SEL_count (_ap [3]. _t2, _ap [0]. _t3);
		
	_ap += 3;
	}
} break;
case 436:
# line 2708 "1A00.attrib"
{{ ac t1 = mk_whenitem (NULL);
		  s_WI_stats (t1, mak_delay (NULL));
		  s_next (g_WI_stats (t1), _ap [1]. _t2);
		  if (_ap [4]. _t3 != 0) {
		     error ("illegal ELSE alternative in selective wait");
		  }
		  s_next (_ap [3]. _t2, t1);
		  _ap [3]. _t2 = t1;
		  s_SEL_count (_ap [5]. _t2, _ap [2]. _t3 + 1);
		
	_ap += 5;
	}
} break;
case 437:
# line 2722 "1A00.attrib"
{{ s_SELECT_items (_ap [4]. _t2, _ap [0]. _t2);
		  _ap [2]. _t2 = _ap [0]. _t2;
		  _ap [1]. _t3 = 1;
		
	_ap += 1;
	}
} break;
case 438:
# line 2727 "1A00.attrib"
{{ s_next (_ap [2]. _t2, _ap [0]. _t2);
		  _ap [2]. _t2 = _ap [0]. _t2;
		  _ap [1]. _t3 ++;
		
	_ap += 1;
	}
} break;
case 439:
# line 2733 "1A00.attrib"
{	_ap -= 4;
{ _ap [3]. _t2 = mk_tselect ();
		  _ap [2]. _t3 = 0;
		  _ap [0]. _t3 = 0;
		  _ap [1]. _t2   = NULL;
		}
} break;
case 440:
# line 2741 "1A00.attrib"
{ ac _L1L_;
{ _L1L_ = mk_whenitem (_ap [2]. _t2);
		  s_next (_ap [1]. _t2, _ap [0]. _t2);
		  s_WI_stats (_L1L_, _ap [1]. _t2);
		
	_ap += 2;
_ap [0]. _t2 =_L1L_;
	}
} break;
case 441:
# line 2746 "1A00.attrib"
{ ac _L1L_;
{ if (_ap [3]. _t3 != 0) {
		     error ("illegal alternative in selective wait");
		  }
		  _L1L_ = mk_whenitem (_ap [0]. _t2);
		  s_WI_stats (_L1L_, nalloc (XTERMINATE));
		  _ap [3]. _t3 = XTERMINATE;
		
_ap [0]. _t2 =_L1L_;
	}
} break;
case 442:
# line 2754 "1A00.attrib"
{ ac _L1L_;
{ if (_ap [5]. _t3 != 0) {
		     error ("illegal alternative in selective wait");
		  }
		  _L1L_ = mk_whenitem (_ap [2]. _t2);
		  s_next (_ap [1]. _t2, _ap [0]. _t2);
		  s_WI_stats (_L1L_, _ap [1]. _t2);
		  _ap [5]. _t3 = XDELAY;
		
	_ap += 2;
_ap [0]. _t2 =_L1L_;
	}
} break;
case 443:
# line 2764 "1A00.attrib"
{	_ap -= 1;
{ _ap [0]. _t2 = NULL;
		}
} break;
case 444:
# line 2767 "1A00.attrib"
{{ _ap [0]. _t2 = SOLVE_EXPR (bu_expr (_ap [0]. _t2), std_boolean,
					"illegal type guard");
		
	}
} break;
case 445:
# line 2773 "1A00.attrib"
{ ac _L1L_;
{ _ap [0]. _t2 = SOLVE_EXPR (bu_expr (_ap [0]. _t2), std_long,
				                 "illegal delay expression");
		  _L1L_ = mak_delay (_ap [0]. _t2);
		
_ap [0]. _t2 =_L1L_;
	}
} break;
case 446:
# line 2779 "1A00.attrib"
 {
_ap += 1; } break;
case 447:
# line 2783 "1A00.attrib"
{ ac _L1L_;
 ac _L2L_;
{ _L1L_ = mk_abort (chk_task (td_n_name (bu_name (_ap [0]. _t2))));
		  _L2L_ = _L1L_;
		
	_ap += -1;
_ap [1]. _t2 =_L1L_;
_ap [0]. _t2 =_L2L_;
	}
} break;
case 448:
# line 2787 "1A00.attrib"
{{ ac t = mk_abort (chk_task (td_n_name (bu_name (_ap [0]. _t2))));
		  s_next (_ap [1]. _t2, t);
		  _ap [1]. _t2 = t;
		
	_ap += 1;
	}
} break;
case 449:
# line 2794 "1A00.attrib"
{ ac _L1L_;
{ ac t, t1;
		  int line;
		  /* turn it into select accept ... else null; end select	*/
		  if (_ap [0]. _t2 != NULL)
		     line = g_lineno (_ap [0]. _t2);
		  else
		     line = -1;
		  t = mk_whenitem (NULL);
		  s_lineno (t, line);
		  s_WI_stats (t, mak_inf_delay (NULL));
		  t1 = mk_whenitem (NULL);
		  s_lineno (t1, line);
		  s_WI_stats (t1, _ap [0]. _t2);
		  s_next (t1, t);
		  _L1L_ = mk_tselect ();
		  s_lineno (_L1L_, line);
		  s_SELECT_items (_L1L_, t1);
		  s_SEL_count (_L1L_, 2);
		
_ap [0]. _t2 =_L1L_;
	}
} break;
case 450:
# line 2816 "1A00.attrib"
{{ s_accept_stats (_ap [3]. _t2, _ap [1]. _t2);
		  DELSCOPE (_ap [3]. _t2, _ap [2]. _t2);
		  CHECK_OPTIDENT (g_tag (g_specif (_ap [3]. _t2)), yypvt[-0].p_char,
	                                          "Mismatching ident %s\n");
		
	_ap += 3;
	}
} break;
case 451:
# line 2822 "1A00.attrib"
{{ DELSCOPE (_ap [1]. _t2, _ap [0]. _t2);
		
	_ap += 1;
	}
} break;
case 452:
# line 2827 "1A00.attrib"
{{ ac t;
		  DELSCOPE (_ap [2]. _t2, _ap [1]. _t2);
		  t = FIND_ENTRY (_ap [2]. _t2, env, "Cannot find entry for %s\n");
		  t = mk_accept (t);
		  _ap [1]. _t2 = NEWSCOPE (t);
		  _ap [2]. _t2 = t;
		
	_ap += 1;
	}
} break;
case 453:
# line 2837 "1A00.attrib"
{	_ap -= 3;
{ _ap [2]. _t2 = mk_entry (yypvt[-0].p_char);
		  _ap [1]. _t2 = NEWSCOPE (_ap [2]. _t2);
		  _ap [0]. _t3 = 0;
		  s_rettype (_ap [2]. _t2, notype);
		}
} break;
case 454:
# line 2844 "1A00.attrib"
{	_ap -= 1;
{ _ap [0]. _t2 = NULL;
		}
} break;
case 455:
# line 2846 "1A00.attrib"
 {
_ap += 1; } break;
case 456:
# line 2850 "1A00.attrib"
{ ac _L1L_;
{ CHECK_OPTIDENT (_ap [1]. _t4, yypvt[-0].p_char, "mismatching ident %s");
		  del_optid (yypvt[-0].p_char);
		  _L1L_ = _ap [0]. _t2;
		
	_ap += 1;
_ap [0]. _t2 =_L1L_;
	}
} break;
case 457:
# line 2857 "1A00.attrib"
{	_ap -= 1;
{ _ap [0]. _t4 = (char *)NULL;
		}
} break;
case 458:
# line 2860 "1A00.attrib"
{	_ap -= 1;
{ _ap [0]. _t4 = yypvt[-1].p_char;
		}
} break;
case 459:
# line 2864 "1A00.attrib"
{{ yyval.p_char = NULL;
		}
} break;
case 461:
# line 2868 "1A00.attrib"
{{ yyval.p_char = string_to_tag (yypvt[-0].p_char);
		}
} break;
case 462:
# line 2873 "1A00.attrib"
{{ DELSCOPE (_ap [1]. _t2, _ap [0]. _t2);
		
	_ap += 1;
	}
} break;
case 463:
# line 2876 "1A00.attrib"
{{ DELSCOPE (_ap [1]. _t2, _ap [0]. _t2);
		  DECL_CHECK (FALSE, _ap [1]. _t2, "decls in block %s");
		
	_ap += 1;
	}
} break;
case 464:
# line 2883 "1A00.attrib"
{{ s_BLK_stats (_ap [4]. _t2, _ap [2]. _t2);
		  s_BLK_exh (_ap [4]. _t2, _ap [0]. _t2);
		
	_ap += 3;
	}
} break;
case 465:
# line 2889 "1A00.attrib"
{	_ap -= 2;
{ _ap [1]. _t2 = mk_block (_ap [2]. _t4, env);
		  if (_ap [2]. _t4 != NULL)
		     decl_tagstat (_ap [1]. _t2);
		  _ap [0]. _t2 = NEWSCOPE (_ap [1]. _t2);
		}
} break;
case 467:
# line 2898 "1A00.attrib"
{	_ap -= 2;
{ _ap [1]. _t2 = mk_block (_ap [2]. _t4, env);
		  if (_ap [2]. _t4 != NULL)
		     decl_tagstat (_ap [1]. _t2);
		  _ap [0]. _t2 = NEWSCOPE (_ap [1]. _t2);
		}
} break;
case 468:
# line 2906 "1A00.attrib"
{{ if (g_d (_ap [3]. _t2) == XLOOPBLOCK)
		     s_LPB_stats (_ap [3]. _t2, _ap [1]. _t2);
		  else
		     s_FB_stats (_ap [3]. _t2, _ap [1]. _t2);
		
	_ap += 2;
	}
} break;
case 470:
# line 2917 "1A00.attrib"
{	_ap -= 2;
{ _ap [1]. _t2 = mk_loopblock (_ap [2]. _t4, env, NULL);
		  if (_ap [2]. _t4 != NULL)
		     decl_tagstat (_ap [1]. _t2);
		  _ap [0]. _t2 = NEWSCOPE (_ap [1]. _t2);
		}
} break;
case 471:
# line 2923 "1A00.attrib"
{ ac _L2L_;
{ _ap [0]. _t2 = SOLVE_EXPR (bu_expr (_ap [0]. _t2), std_boolean,
				                   "while loop expression error");
		  _ap [0]. _t2 = mk_loopblock (_ap [1]. _t4, env, _ap [0]. _t2);
		  if (_ap [1]. _t4 != NULL)
		     decl_tagstat (_ap [0]. _t2);
		  _L2L_ = NEWSCOPE (_ap [0]. _t2);
		
	_ap += -1;
_ap [0]. _t2 =_L2L_;
	}
} break;
case 472:
# line 2931 "1A00.attrib"
{ ac _L1L_;
 ac _L2L_;
{ ac t, q, r;
		   _L1L_ = mk_forblock (_ap [2]. _t4, env, _ap [1]. _t3);
		   if (_ap [2]. _t4 != NULL)
		      decl_tagstat (_L1L_);
		   _L2L_ = NEWSCOPE (_L1L_);
		   t = TD_FILTER (bu_filter (mk_filter (NULL, _ap [0]. _t2)),
		          "Error in forloop type %s\n", yypvt[-2].p_char);
		   r = mk_subtype (mk_tag (gen_tag (), IDL), t);
		   INTRODUCE (r);
		   r = mk_object (yypvt[-2].p_char, mk_desc (r, KCONST, NULL));
		   INTRODUCE (r);
		   off_intro (r);
		
_ap [1]. _t2 =_L1L_;
_ap [0]. _t2 =_L2L_;
	}
} break;
case 473:
# line 2946 "1A00.attrib"
{	_ap -= 1;
{ _ap [0]. _t3 = FORWARD;
		}
} break;
case 474:
# line 2949 "1A00.attrib"
{	_ap -= 1;
{ _ap [0]. _t3 = BACKWARDS;
		}
} break;
case 475:
# line 2953 "1A00.attrib"
{	_ap -= 1;
{ _ap [0]. _t2 = NULL;
		}
} break;
case 479:
# line 2959 "1A00.attrib"
 {
_ap += -1; } break;
case 486:
# line 2968 "1A00.attrib"
{{ s_exitcond (_ap [1]. _t2, _ap [0]. _t2);
		
	_ap += 1;
	}
} break;
case 487:
# line 2972 "1A00.attrib"
{	_ap -= 1;
{ _ap [0]. _t2 = mk_exit (encl_loop ());
		}
} break;
case 488:
# line 2975 "1A00.attrib"
{ ac _L1L_;
{ _L1L_ = mk_exit (get_loop (td_n_name (bu_name (_ap [0]. _t2))));
		
_ap [0]. _t2 =_L1L_;
	}
} break;
case 489:
# line 2979 "1A00.attrib"
{	_ap -= 1;
{ _ap [0]. _t2 = NULL;
		}
} break;
case 490:
# line 2982 "1A00.attrib"
{ ac _L1L_;
{ _L1L_ = SOLVE_EXPR (bu_expr (_ap [0]. _t2), std_boolean, "illegal exit expression");
		
_ap [0]. _t2 =_L1L_;
	}
} break;
case 491:
# line 2986 "1A00.attrib"
{	_ap -= 1;
{ _ap [0]. _t2 = mk_return ();
		}
} break;
case 492:
# line 2989 "1A00.attrib"
{ ac _L1L_;
{ ac t = mk_return ();
		  ac r = g_enclsub (t);
		  if (r != NULL) {
		     if (g_rettype (g_specif (r)) == notype) {
		        error ("Procedure %s with return expression\n",
					       g_tag (g_specif (r)) );
		        _ap [0]. _t2 = NULL;
		     }	
		     else
		     _ap [0]. _t2 = SOLVE_EXPR (bu_expr (_ap [0]. _t2), g_rettype (g_specif (r)),
			                 "type error in return expression");
		  }
		  else
		     _ap [0]. _t2 = NULL;

		  s_retexpr (t, _ap [0]. _t2);
		  _L1L_ = t;
		
_ap [0]. _t2 =_L1L_;
	}
} break;
case 493:
# line 3009 "1A00.attrib"
{{ error (" goto's not supported in DAC");
		
	_ap += 1;
	}
} break;
case 494:
# line 3013 "1A00.attrib"
{	_ap -= 1;
{ if (!is_in_ex_h (env))
		     error ("re-raise outside an exception handler");
		  _ap [0]. _t2 = mk_raise (NULL);
		}
} break;
case 495:
# line 3018 "1A00.attrib"
{{ _ap [0]. _t2 = mk_raise (get_exc (td_n_name (bu_name (_ap [0]. _t2))));
		
	}
} break;
case 496:
# line 3021 "1A00.attrib"
{{ _ap [1]. _t2 = mk_raise (get_exc (td_n_name (bu_name (_ap [1]. _t2))));
		  s_exc_task (_ap [1]. _t2, chk_task (td_n_name (bu_name (_ap [0]. _t2))));
		
	_ap += 1;
	}
} break;
case 497:
# line 3027 "1A00.attrib"
{{ _ap [1]. _t2 = td_assign (mk_assign (bu_name (_ap [1]. _t2), bu_expr (_ap [0]. _t2)));
		
	_ap += 1;
	}
} break;
case 498:
# line 3031 "1A00.attrib"
{{ _ap [0]. _t2 = td_proc (bu_name (_ap [0]. _t2));
		  if (_ap [0]. _t2 == NULL) {
		     error ("Error in procedure/entry call");
		  }
		  else
		  { if (_ap [0]. _t2 != NULL && g_d (_ap [0]. _t2) == XENTRYCALL) {
		       s_call_delay (_ap [0]. _t2, mak_inf_delay ());
		       s_call_stats (_ap [0]. _t2, NULL);
		    }

		    _ap [0]. _t2 = mk_subcall (_ap [0]. _t2);
		  }
		
	}
} break;
case 499:
# line 3046 "1A00.attrib"
{{ _ap [0]. _t2 = td_proc (bu_name (_ap [0]. _t2));
		  if (_ap [0]. _t2 != NULL) {
		     if (g_d (_ap [0]. _t2) != XENTRYCALL) {
		        error ("Entry call expected here");
		     }
		  }
		
	}
} break;
case 500:
# line 3055 "1A00.attrib"
{{ _ap [0]. _t2 = mak_delay (_ap [0]. _t2);
		
	}
} break;
case 501:
# line 3058 "1A00.attrib"
{	_ap -= 1;
{ _ap [0]. _t2 = mak_delay (NULL);
		}
} break;
case 502:
# line 3063 "1A00.attrib"
{ ac _L1L_;
{ if (_ap [5]. _t2 != NULL) {
		     s_call_delay (_ap [5]. _t2, _ap [2]. _t2);
		     s_call_stats (_ap [5]. _t2, _ap [1]. _t2);
			
		     s_call_next  (_ap [5]. _t2, _ap [4]. _t2);
		     _L1L_ = mk_subcall (_ap [5]. _t2);
		  }
		
	_ap += 5;
_ap [0]. _t2 =_L1L_;
	}
} break;
case 503:
# line 3072 "1A00.attrib"
{ ac _L1L_;
{ if (_ap [3]. _t2 != NULL) {
		     s_call_delay (_ap [3]. _t2, _ap [0]. _t2);
		     s_call_next  (_ap [3]. _t2, _ap [2]. _t2);
		     _L1L_ = mk_subcall (_ap [3]. _t2);
		  }
		  else
		     _L1L_ = NULL;
		
	_ap += 3;
_ap [0]. _t2 =_L1L_;
	}
} break;
	}
}
