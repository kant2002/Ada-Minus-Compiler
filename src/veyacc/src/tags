My1	y1.c	/^main(argc,argv) int argc; char *argv[]; {$/
add_type	y6.c	/^struct type_elem *add_type (t)$/
address_of	y6.c	/^char *address_of (tag)$/
adjust_stack	y6.c	/^adjust_stack ()$/
aoutput	y4.c	/^aoutput(){ \/* this version is for C *\/$/
apack	y3.c	/^apack(p, n ) int *p;{ \/* pack state i from temp1 i/
arout	y4.c	/^arout( s, v, n ) char *s; int *v, n; {$/
aryfil	y1.c	/^aryfil( v, n, c ) int *v,n,c; { \/* set elements 0 /
callopt	y4.c	/^callopt(){$/
cempty	y1.c	/^cempty(){ \/* mark nonterminals which derive the em/
chcopy	y1.c	/^char *chcopy( p, q )  char *p, *q; {$/
checkdefs	y6.c	/^checkdefs ()$/
chfind	y2.c	/^chfind( t, s ) register char *s; {$/
closure	y1.c	/^closure(i)$/
cp_tag	y6.c	/^cp_tag (x, y, cnt)$/
cpfir	y1.c	/^cpfir() {$/
cpres	y1.c	/^cpres()$/
cpyact	y2.c	/^cpyact(offset)$/
cpycode	y2.c	/^cpycode(){ \/* copies code between \\{ and \\} *\/$/
cpyunion	y2.c	/^cpyunion(){$/
cstash	y2.c	/^cstash( s ) register char *s;$/
defin	y2.c	/^defin( t, s ) register char  *s;$/
defout	y2.c	/^defout()$/
dest_par	y6.c	/^dest_par (def, parno, tag)$/
drtermfu	y3.c	/^drtermfu()$/
eq_tags	y6.c	/^static int eq_tags (x, y)$/
error	y1.c	/^error(s,a1) char *s; { \/* write out error comment /
fdtype	y2.c	/^fdtype( t ){ \/* determine the type of a symbol *\/$/
finact	y2.c	/^finact()$/
flset	y1.c	/^struct looksets *flset( p )   struct looksets *p; /
format_one_rule	y7.c	/^format_one_rule (rule)$/
get_i_type	y6.c	/^struct type_elem *get_i_type (def, parno)$/
get_o_type	y6.c	/^struct type_elem *get_o_type (def, parno)$/
get_termfu	y8.c	/^get_termfu (lastred)$/
gettok	y2.c	/^gettok()$/
gin	y4.c	/^gin(i){$/
go2gen	y3.c	/^go2gen(c){ \/* output the gotos for nonterminal c */
go2out	y3.c	/^go2out(){ \/* output the gotos for the nontermninal/
goto_case	y8.c	/^goto_case (nont, lastred)$/
grammar	y7.c	/^grammar()$/
gtnm	y4.c	/^gtnm(){$/
hideprod	y3.c	/^hideprod(){$/
in_pars	y6.c	/^int in_pars (def)$/
init_stack	y6.c	/^init_stack ()$/
is_non_term	y7.c	/^is_non_term (symbol)$/
is_similar	y6.c	/^is_similar (x, y)$/
lhs_of	y7.c	/^lhs_of (rule_index)$/
lhs_side	y2.c	/^struct att_def *lhs_side ()$/
lookup	y6.c	/^struct att_def *lookup (t)$/
make_any_rules	y7.c	/^make_any_rules ()$/
make_first_rules	y7.c	/^make_first_rules ()$/
new_def	y6.c	/^struct att_def *new_def (t)$/
new_tag	y6.c	/^char *new_tag (t)$/
nxti	y4.c	/^nxti(){ \/* finds the next i *\/$/
orden	y7.c	/^orden()$/
osummary	y4.c	/^osummary(){$/
others	y1.c	/^others(){ \/* put out other arrays, copy the parser/
out_pars	y6.c	/^int out_pars (def)$/
output	y3.c	/^output(){ \/* print the output for the states *\/$/
post_adjuststack	y6.c	/^post_adjuststack ()$/
pr_cpres	y1.c	/^pr_cpres ()$/
pr_rule	y1.c	/^pr_rule (p)$/
pr_stack	y6.c	/^pr_stack ()$/
precftn	y3.c	/^precftn(r,t,s){ \/* decide a shift\/reduce conflict /
pref_stackadjust	y6.c	/^pref_stackadjust ()$/
print_rules	y7.c	/^print_rules ()$/
print_union	y6.c	/^print_union ()$/
prlook	y1.c	/^prlook( p ) struct looksets *p;{$/
proc_alternative	y2.c	/^proc_alternative (lefthand)$/
proc_def	y5.c	/^proc_def ()     \/* process a definition *\/$/
proc_intypes	y5.c	/^proc_intypes (definition)$/
proc_member	y2.c	/^proc_member (ctxt)$/
proc_outtypes	y5.c	/^proc_outtypes (definition)$/
push	y6.c	/^push (def, parno, tag)$/
putitem	y1.c	/^putitem( ptr, lptr )  int *ptr;  struct looksets */
re_init_stack	y6.c	/^re_init_stack ()$/
red_case	y8.c	/^red_case (r, lastred)$/
rule	y2.c	/^rule ()$/
search_stck	y6.c	/^struct stack_elem *search_stck (t)$/
set_input	y6.c	/^set_input (def, typename)$/
set_output	y6.c	/^set_output (def, type_name)$/
setdefined	y6.c	/^setdefined (t)$/
setunion	y1.c	/^setunion( a, b ) register *a, *b; {$/
setup	y2.c	/^setup(argc,argv) int argc; char *argv[];$/
skipcom	y2.c	/^skipcom(){ \/* skip over comments *\/$/
stagen	y1.c	/^stagen(){ \/* generate the states *\/$/
state	y1.c	/^state(c){ \/* sees if last state equals earlier one/
stin	y4.c	/^stin(i){$/
summary	y1.c	/^summary(){ \/* output the summary on the tty *\/$/
symnam	y1.c	/^char *symnam(i){ \/* return a pointer to the name o/
veri_in	y6.c	/^veri_in (def, parno, tag)$/
veri_out	y6.c	/^veri_out (def, parno, tag)$/
warning	y1.c	/^warning(s,a1)$/
warray	y3.c	/^warray( s, v, n ) char *s; int *v, n; {$/
wdef	y3.c	/^wdef( s, n ) char *s; { \/* output a definition of /
wract	y3.c	/^wract(i){ \/* output state i *\/$/
writem	y1.c	/^char *writem(pp) int *pp; { \/* creates output stri/
wrstate	y3.c	/^wrstate(i){ \/* writes state i *\/$/
