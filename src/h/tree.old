#
/*
 * package tree
 *
 * tree.h
 *	ordering of the tree elements is such that
 *	discr d		is first element
 *	ac	   next	is next element
 *	short	prev
 *	char	*tag
 *	ac	enclunit
 *
 *	...
 *
 *	SUB	FILTER			linked
 *	SUB	UNRESOLVED		tag
 *	SUB	PRIVPART		enclunit
 */
#include	"nodes.h"

typedef	byte	discr;

#define	is_enclosed(x)	(XSUB <= g_d (x) && g_d (x) <= XPRIVPART)
#define	has_tag(x)	(XSUB <= (x) -> d && (x) -> d <= XWITH)
#define	is_linked(x)	(XSUB <= x && x <= XFILTER)
#define	exp_types(x)	(XNAME <= x && x <= XINDEXING)

/*
 *	Legitimate flag values
 */
#define	KMASK	017
#define	KVAR	0
#define	KCONST	1
#define	KNUMB	2
#define	KCOMP	3
#define	KDISCR	4
#define	INMODE	5
#define	OUTMODE	6
#define	INOUTMODE	7

#define	MARKED	01000
#define	BUWALK	01000
/*
 *	Kinds of literals to be distinguished
 */
#define	S_INTLIT	1
#define	S_REALLIT	2
#define	S_STRINGLIT	3
#define	S_CHARLIT	4
#define	S_NULLLIT	5

/*
 *	Kinds of subprograms to be considered
 */
#define	NORMAL 0
#define	STD_OP	1

#define	NEWINTTYPE	1
#define	NEWFLOATTYPE	2
#define	NEWFIXEDTYPE	3
/*
 *	ACCESS FUNCTIONS FOR NODE ATTRIBUTES
 */

#define	g_AGG_Voff(x)		((x) -> AGG_Voff)
#define	g_ALLO_Toff(x)		((x) -> ALLO_Toff)
#define	g_ALL_Voff(x)		((x) -> ALL_Voff)
#define	g_FLT_valsize(x)		((x) -> FLT_valsize)
#define	g_FLT_vdoffset(x)		((x) -> FLT_vdoffset)
#define	g_REC_maxpfld(x)		((x) -> REC_maxpfld)
#define	g_REC_ninits(x)		((x) -> REC_ninits)
#define	g_REC_npaths(x)		((x) -> REC_npaths)
#define	g_REC_vsize(x)		((x) -> REC_vsize)
#define	g_VAR_fpath(x)		((x) -> VAR_fpath)
#define	g_VAR_ffld(x)		((x) -> VAR_fpfld)
#define	g_compexpr(x)		((x) -> compexpr)
#define	g_constraint(x)		((x) -> constraint)
#define	g_e_entry(x)		((x) -> e_entry)
#define	g_exitcond(x)		((x) -> exitcond)
#define	g_fidiscr(x)		((x) -> fidiscr)
#define	g_genpars(x)		((struct _gennode *)x -> genpars)
#define	g_genunit(x)		((struct _gennode *)x -> genunit)
#define	g_is_hidden(x)		((struct _inherit *)x -> is_hidden)
#define	g_intype(x)		((x) -> intype)
#define	g_iter_ptr(x)		((x) -> iter_ptr)
#define	g_primary(x)		((x) -> primary)
#define	g_convexpr(x)		((x) -> convexpr)
#define	g_dis(x)		((x) -> dis)
#define	g_expr(x)		((x) -> expr)
#define	g_call_delay(x)		(((ac)(x)) -> call_delay)
#define	g_call_stats(x)		((x) -> call_stats)
#define	g_fbodyloc(x)		((x) -> fbodyloc)
#define	g_fcompas(x)		((x) -> fcompas)
#define	g_foperation(x)		((x) -> foperation)
#define	g_frang_exp(x)		((x) -> frangeexp)
#define	g_fvariant(x)		((x) -> fvariant)
#define	g_impl(x)		((x) -> impl)
#define	g_name(x)		((x) -> name)
#define	g_nametype(x)		((x) -> nametype)
#define	g_nexp(x)		((x) -> nexp)
#define	g_obtype(x)		((x) -> obtype)
#define	g_retexpr(x)		((x) -> retexpr)
#define	g_rhs(x)		((x) -> rhs)
#define	g_varchoice(x)		((x) -> varchoice)
#define	g_ACC_offset(x)		((x) -> ACC_offset)
#define	g_AGG_Doff(x)		((x) -> AGG_Doff)
#define	g_AGG_offset(x)		((x) -> AGG_offset)
#define	g_ALL_Doff(x)		((x) -> ALL_Doff)
#define	g_BLK_SToff(x)		((x) -> BLK_SToff)
#define	g_CASE_Voff(x)		((x) -> CASE_Voff)
#define	g_FLT_offset(x)		((x) -> FLT_offset)
#define	g_LIT_Doff(x)		((x) -> LIT_Doff)
#define	g_LIT_Voff(x)		((x) -> LIT_Voff)
#define	g_OBJ_offset(x)		((x) -> OBJ_offset)
#define	g_PBDY_SToff(x)		((x) -> PBDY_SToff)
#define	g_REC_offset(x)		((x) -> REC_offset)
#define	g_ROBJ_offset(x)		((x) -> ROBJ_offset)
#define	g_SUBS_offset(x)		((x) -> SUBS_offset)
#define	g_SUBS_retoff(x)		((x) -> SUBS_retoff)
#define	g_SBB_valoff(x)		((x) -> SBB_valoff)
#define	g_TCON_Doff(x)		((x) -> TCON_Doff)
#define	g_ALLO_Doff(x)		((x) -> ALLO_Doff)
#define	g_CALL_Doff(x)		((x) -> CALL_Doff)
#define	g_CALL_Voff(x)		((x) -> CALL_Voff)
#define	g_LIT_Doff(x)		((x) -> LIT_Doff)
#define	g_LIT_Voff(x)		((x) -> LIT_Voff)
#define	g_OBJ_descoff(x)		((x) -> OBJ_descoff)
#define	g_SCC_Voff(x)		((x) -> SCC_Voff)
#define	g_SLI_Doff(x)		((x) -> SLI_Doff)
#define	g_BLK_exh(x)		((x) -> BLK_exh)
#define	g_BLK_stats(x)		((x) -> BLK_stats)
#define	g_CASE_items(x)		((x) -> CASE_items)
#define	g_EXH_items(x)		((x) -> EXH_items)
#define	g_FB_stats(x)		((x) -> FB_stats)
#define	g_IF_items(x)		((x) -> IF_items)
#define	g_IF_stats(x)		((x) -> IF_stats)
#define	g_LPB_stats(x)		((x) -> LPB_stats)
#define	g_PB_exh(x)		((x) -> PB_exh)
#define	g_PB_stats(x)		((x) -> PB_stats)
#define	g_SBB_exh(x)		((x) -> SBB_exh)
#define	g_SBB_stats(x)		((x) -> SBB_stats)
#define	g_SELECT_items(x)		((x) -> SELECT_items)
#define	g_WI_stats(x)		((x) -> WI_stats)
#define	g_accept_stats(x)		((x) -> accept_stats)
#define	g_actype(x)		((x) -> actype)
#define	g_aggregate(x)		((x) -> aggregate)
#define	g_aggtype(x)		((x) -> aggtype)
#define	g_altype(x)		((x) -> altype)
#define	g_body_imp(x)		((x) -> body_imp)
#define	g_c_entry(x)		((x) -> c_entry)
#define	g_caseexpr(x)		((x) -> caseexpr)
#define	g_comp(x)		((x) -> comp)
#define	g_complete(x)		((x) -> complete)
#define	g_cond(x)		((x) -> cond)
#define	g_context(x)		((x) -> context)
#define	g_delay_expr(x)		((x) -> delay_expr)
#define	g_desc(x)		((x) -> desc)
#define	g_elem(x)		((x) -> elem)
#define	g_elemtype(x)		((x) -> elemtype)
#define	g_enclsub(x)		((x) -> enclsub)
#define	g_enclunit(x)		((x) -> enclunit)
#define	g_entity(x)		((x) -> entity)
#define	g_exception(x)		((x) -> exception)
#define	g_exptype(x)		((x) -> exptype)
#define	g_fact(x)		((x) -> fact)
#define	g_farg(x)		((x) -> farg)
#define	g_fblockloc(x)		((x) -> fblockloc)
#define	g_fcompchoice(x)		((x) -> fcompchoice)
#define	g_fentity(x)		((x) -> fentity)
#define	g_fentry(x)		((x) -> fentry)
#define	g_fenumlit(x)		((x) -> fenumlit)
#define	g_ffield(x)		((x) -> ffield)
#define	g_fformal(x)		((x) -> fformal)
#define	g_filtype(x)		((x) -> filtype)
#define	g_findex(x)		((x) -> findex)
#define	g_fpdiscr(x)		((x) -> fpdiscr)
#define	g_fprivitem(x)		((x) -> fprivitem)
#define	g_frange(x)		((x) -> frange)
#define	g_fsccexpr(x)		((x) -> fsccexpr)
#define	g_fsetelem(x)		((x) -> fsetelem)
#define	g_ident(x)		((x) -> ident)
#define	g_fvisitem(x)			((x) -> fvisitem)
#define	g_priv(x)			((x) -> priv)
#define	g_fwhenchoice(x)		((x) -> fwhenchoice)
#define	g_ifcond(x)		((x) -> ifcond)
#define	g_indextype(x)		((x) -> indextype)
#define	g_indir(x)		((x) -> indir)
#define	g_inexpr(x)		((x) -> inexpr)
#define	g_inh_oper(x)		((x) -> inh_oper)
#define	g_inh_type(x)		((x) -> inh_type)
#define	g_lab(x)		((x) -> lab)
#define	g_labeldecl(x)		((x) -> labeldecl)
#define	g_lhs(x)		((x) -> lhs)
#define	g_link(x)		((x) -> link)
#define	g_littype(x)		((x) -> littype)
#define	g_loopid(x)		((x) -> loopid)
#define	g_looplocals(x)		((x) -> looplocals)
#define	g_looppar(x)		((x) -> looppar)
#define	g_newtype(x)		((x) -> newtype)
#define	g_next(x)		((x) -> next)
#define	g_objtype(x)		((x) -> objtype)
#define	g_old_type(x)		((x) -> old_type)
#define	g_enlits(x)		((x) -> enlits)
#define	g_pack_body(x)		((x) -> pack_body)
#define	g_packname(x)		((x) -> packname)
#define	g_parenttype(x)		((x) -> parenttype)
#define	g_parname(x)		((x) -> parname)
#define	g_partype(x)		((x) -> partype)
#define	g_qualexpr(x)		((x) -> qualexpr)
#define	g_qualtype(x)		((x) -> qualtype)
#define	g_rangetype(x)		((x) -> rangetype)
#define	g_renname(x)		((x) -> renname)
#define	g_rentype(x)		((x) -> rentype)
#define	g_rettype(x)		((x) -> rettype)
#define	g_rnam(x)		((x) -> rnam)
#define	g_slrange(x)		((x) -> slrange)
#define	g_specif(x)		((x) -> specif)
#define	g_stub(x)		((x) -> stub)
#define	g_stub_spec(x)		((x) -> stub_spec)
#define	g_subexpr(x)		((x) -> subexpr)
#define	g_subname(x)		((x) -> subname)
#define	g_subpr(x)		((x) -> subpr)
#define	g_t_stat(x)		((x) -> t_stat)
#define	g_task_exh(x)		((x) -> task_exh)
#define	g_task_stats(x)		((x) -> task_stats)
#define	g_taskbody(x)		((x) -> taskbody)
#define	g_thexpr(x)		((x) -> thexpr)
#define	g_thunk(x)		((x) -> thunk)
#define	g_tripset(x)		((x) -> tripset)
#define	g_types(x)		((x) -> types)
#define	g_type_spec(x)		((x) -> type_spec)
#define	g_withunit(x)		((x) -> withunit)
#define	g_andthen(x)		((x) -> andthen)
#define	g_ind(x)		((x) -> ind)
#define	g_tag(x)		((x) -> tag)
#define	g_d(x)		((x) -> d)
#define	g_FB_lab(x)		((x) -> FB_lab)
#define	g_LPB_lab(x)		((x) -> LPB_lab)
#define	g_entrycount(x)		((x) -> entrycount)
#define	g_mark(x)		((x) -> mark)
#define	g_val(x)		((x) -> val)
#define	g_ACC_alloc(x)		((x) -> ACC_alloc)
#define	g_ACC_nform(x)		((x) -> ACC_nform)
#define	g_AGG_alloc(x)		((x) -> AGG_alloc)
#define	g_AGG_index(x)		((x) -> AGG_index)
#define	g_AGG_tablab(x)		((x) -> AGG_tablab)
#define	g_ARR_alloc(x)		((x) -> ARR_alloc)
#define	g_ARR_ndims(x)		((x) -> ARR_ndims)
#define	g_ARR_offset(x)		((x) -> ARR_offset)
#define	g_ARR_vdsize(x)		((x) -> ARR_vdsize)
#define	g_FLT_alloc(x)		((x) -> FLT_alloc)
#define	g_OBJ_alloc(x)		((x) -> OBJ_alloc)
#define	g_REC_alloc(x)		((x) -> REC_alloc)
#define	g_REC_nflds(x)		((x) -> REC_nflds)
#define	g_REC_form(x)		((x) -> REC_nform)
#define	g_REC_pathf(x)		((x) -> REC_pathf)
#define	g_REC_vdsize(x)		((x) -> REC_vdsize)
#define	g_ROBJ_alloc(x)		((x) -> ROBJ_alloc)
#define	g_SUBS_alloc(x)		((x) -> SUBS_alloc)
#define	g_SUB_level(x)		((x) -> SUB_level)
#define	g_TH_exprlab(x)		((x) -> TH_exprlab)
#define	g_TH_levlab(x)		((x) -> TH_levlab)
#define	g_attr_value(x)		((x) -> attr_value)
#define	g_e_num(x)		((x) -> e_num)
#define	g_enuml_ord(x)		((x) -> enuml_ord)
#define	g_nenums(x)		((x) -> nenums)
#define	g_CPA_exprlab(x)		((x) -> CPA_exprlab)
#define	g_AGG_flags(x)		((x) -> AGG_flags)
#define	g_ARR_flags(x)		((x) -> ARR_flags)
#define	g_FLT_flags(x)		((x) -> FLT_flags)
#define	g_REC_flags(x)		((x) -> REC_flags)
#define	g_lineno(x)		((x) -> lineno)
#define	g_flags(x)		((x) -> flags)
#define	g_prev(x)		((x) -> prev)
#define	g_rettype(x)		((x) -> rettype)

#define	g_tripsub(x)		((x) -> tripsub)
#define	g_triptype(x)		((x) -> triptype)
#define	g_tripdtype(x)		((x) -> tripdtype)
#define	g_tripnext(x)		((x) -> tripnext)
#define	g_tripmark(x)		((x) -> tripmark)

#define	s_tripsub(x, y)		((x) -> tripsub = (y))
#define	s_triptype(x, y)	((x) -> triptype = (y))
#define	s_tripdtype(x, y)	((x) -> tripdtype = (y))
#define	s_tripnext(x, y)	((x) -> tripnext = (y))
#define	s_tripmark(x, y)	((x) -> tripmark = (y))



#define	s_AGG_Voff(x, y)	((x) -> AGG_Voff = y)
#define	s_ALLO_Toff(x, y)	((x) -> ALLO_Toff = y)
#define	s_ALL_Voff(x, y)	((x) -> ALL_Voff = y)
#define	s_FLT_valsize(x, y)	((x) -> FLT_valsize = y)
#define	s_FLT_vdoffset(x, y)	((x) -> FLT_vdoffset = y)
#define	s_REC_maxpfld(x, y)	((x) -> REC_maxpfld = y)
#define	s_REC_ninits(x, y)	((x) -> REC_ninits = y)
#define	s_REC_npaths(x, y)	((x) -> REC_npaths = y)
#define	s_REC_vsize(x, y)	((x) -> REC_vsize = y)
#define	s_VAR_path(x, y)	((x) -> VAR_fpath = y)
#define	s_VAR_fpfld(x, y)	((x) -> VAR_fpfld = y)
#define	s_compexpr(x, y)	((x) -> compexpr = y)
#define	s_constraint(x, y)	((x) -> constraint = y)
#define	s_e_entry(x, y)		((x) -> e_entry = y)
#define	s_exitcond(x, y)	((x) -> exitcond = y)
#define	s_fidiscr(x, y)	((x) -> fidiscr = y)
#define	s_genpars(x, y)		((struct _gennode *)x -> genpars = ((ac)y))
#define	s_genunit(x, y)		((struct _gennode *)x -> genunit = ((ac)y))
#define	s_intype(x, y)	((x) -> intype = y)
#define	s_is_hidden(x, y)	((struct _inherit *)x -> is_hidden = (y))
#define	s_iter_ptr(x, y)	((x) -> iter_ptr = y)
#define	s_primary(x, y)	((x) -> primary = y)
#define	s_convexpr(x, y)	((x) -> convexpr = y)
#define	s_dis(x, y)	((x) -> dis = y)
#define	s_expr(x, y)	((x) -> expr = y)
#define	s_call_delay(x, y)	((x) -> call_delay = y)
#define	s_call_stats(x, y)	((x) -> call_stats = y)
#define	s_fbodyloc(x, y)	((x) -> fbodyloc = y)
#define	s_fcompas(x, y)	((x) -> fcompas = y)
#define	s_foperation(x, y)	((x) -> foperation = y)
#define	s_frang_exp(x, y)	((x) -> frangeexp = y)
#define	s_fvariant(x, y)	((x) -> fvariant = y)
#define	s_impl(x, y)	((x) -> impl = y)
#define	s_name(x, y)	((x) -> name = y)
#define	s_nametype(x, y)	((x) -> nametype = y)
#define	s_nexp(x, y)	((x) -> nexp = y)
#define	s_obtype(x, y)	((x) -> obtype = y)
#define	s_retexpr(x, y)	((x) -> retexpr = y)
#define	s_rhs(x, y)	((x) -> rhs = y)
#define	s_varchoice(x, y)	((x) -> varchoice = y)
#define	s_ACC_offset(x, y)	((x) -> ACC_offset = y)
#define	s_AGG_Doff(x, y)	((x) -> AGG_Doff = y)
#define	s_AGG_offset(x, y)	((x) -> AGG_offset = y)
#define	s_ALL_Doff(x, y)	((x) -> ALL_Doff = y)
#define	s_BLK_SToff(x, y)	((x) -> BLK_SToff = y)
#define	s_CASE_Voff(x, y)	((x) -> CASE_Voff = y)
#define	s_FLT_offset(x, y)	((x) -> FLT_offset = y)
#define	s_LIT_Doff(x, y)	((x) -> LIT_Doff = y)
#define	s_LIT_Voff(x, y)	((x) -> LIT_Voff = y)
#define	s_OBJ_offset(x, y)	((x) -> OBJ_offset = y)
#define	s_PBDY_SToff(x, y)	((x) -> PBDY_SToff = y)
#define	s_REC_offset(x, y)	((x) -> REC_offset = y)
#define	s_ROBJ_offset(x, y)	((x) -> ROBJ_offset = y)
#define	s_SUBS_offset(x, y)	((x) -> SUBS_offset = y)
#define	s_SUBS_retoff(x, y)	((x) -> SUBS_retoff = y)
#define	s_SBB_valoff(x, y)	((x) -> SBB_valoff = y)
#define	s_TCON_Doff(x, y)	((x) -> TCON_Doff = y)
#define	s_ALLO_Doff(x, y)	((x) -> ALLO_Doff = y)
#define	s_CALL_Doff(x, y)	((x) -> CALL_Doff = y)
#define	s_CALL_Voff(x, y)	((x) -> CALL_Voff = y)
#define	s_LIT_Doff(x, y)	((x) -> LIT_Doff = y)
#define	s_LIT_Voff(x, y)	((x) -> LIT_Voff = y)
#define	s_OBJ_descoff(x, y)	((x) -> OBJ_descoff = y)
#define	s_SCC_Voff(x, y)	((x) -> SCC_Voff = y)
#define	s_SLI_Doff(x, y)	((x) -> SLI_Doff = y)
#define	s_BLK_exh(x, y)	((x) -> BLK_exh = y)
#define	s_BLK_stats(x, y)	((x) -> BLK_stats = y)
#define	s_CASE_items(x, y)	((x) -> CASE_items = y)
#define	s_EXH_items(x, y)	((x) -> EXH_items = y)
#define	s_FB_stats(x, y)	((x) -> FB_stats = y)
#define	s_IF_items(x, y)	((x) -> IF_items = y)
#define	s_IF_stats(x, y)	((x) -> IF_stats = y)
#define	s_LPB_stats(x, y)	((x) -> LPB_stats = y)
#define	s_PB_exh(x, y)	((x) -> PB_exh = y)
#define	s_PB_stats(x, y)	((x) -> PB_stats = y)
#define	s_SBB_exh(x, y)	((x) -> SBB_exh = y)
#define	s_SBB_stats(x, y)	((x) -> SBB_stats = y)
#define	s_SELECT_items(x, y)	((x) -> SELECT_items = y)
#define	s_WI_stats(x, y)	((x) -> WI_stats = y)
#define	s_accept_stats(x, y)	((x) -> accept_stats = y)
#define	s_actype(x, y)	((x) -> actype = y)
#define	s_aggregate(x, y)	((x) -> aggregate = y)
#define	s_aggtype(x, y)	((x) -> aggtype = y)
#define	s_altype(x, y)	((x) -> altype = y)
#define	s_body_imp(x, y)	((x) -> body_imp = y)
#define	s_c_entry(x, y)	((x) -> c_entry = y)
#define	s_caseexpr(x, y)	((x) -> caseexpr = y)
#define	s_comp(x, y)	((x) -> comp = y)
#define	s_complete(x, y)	((x) -> complete = y)
#define	s_cond(x, y)	((x) -> cond = y)
#define	s_context(x, y)	((x) -> context = y)
#define	s_delay_expr(x, y)	((x) -> delay_expr = y)
#define	s_desc(x, y)	((x) -> desc = y)
#define	s_elem(x, y)	((x) -> elem = y)
#define	s_elemtype(x, y)	((x) -> elemtype = y)
#define	s_enclsub(x, y)	((x) -> enclsub = y)
#define	s_enclunit(x, y)	((x) -> enclunit = y)
#define	s_entity(x, y)	((x) -> entity = y)
#define	s_exception(x, y)	((x) -> exception = y)
#define	s_exptype(x, y)	((x) -> exptype = y)
#define	s_fact(x, y)	((x) -> fact = y)
#define	s_farg(x, y)	((x) -> farg = y)
#define	s_fblockloc(x, y)	((x) -> fblockloc = y)
#define	s_fcompchoice(x, y)	((x) -> fcompchoice = y)
#define	s_fentity(x, y)		((x)-> fentity = y)
#define	s_fentry(x, y)	((x) -> fentry = y)
#define	s_fenumlit(x, y)	((x) -> fenumlit = y)
#define	s_ffield(x, y)	((x) -> ffield = y)
#define	s_fformal(x, y)	((x) -> fformal = y)
#define	s_filtype(x, y)	((x) -> filtype = y)
#define	s_findex(x, y)	((x) -> findex = y)
#define	s_fpdiscr(x, y)	((x) -> fpdiscr = y)
#define	s_fprivitem(x, y)	((x) -> fprivitem = y)
#define	s_frange(x, y)	((x) -> frange = y)
#define	s_fsccexpr(x, y)	((x) -> fsccexpr = y)
#define	s_fsetelem(x, y)	((x) -> fsetelem = y)
#define	s_ident(x, y)	((x) -> ident = y)
#define	s_fvisitem(x, y)	((x) -> fvisitem = y)
#define	s_priv(x, y)		((x) -> priv = y)
#define	s_fwhenchoice(x, y)	((x) -> fwhenchoice = y)
#define	s_ifcond(x, y)	((x) -> ifcond = y)
#define	s_indextype(x, y)	((x) -> indextype = y)
#define	s_indir(x, y)	((x) -> indir = y)
#define	s_inexpr(x, y)	((x) -> inexpr = y)
#define	s_inh_oper(x, y)	((x) -> inh_oper = y)
#define	s_inh_type(x, y)	((x) -> inh_type = y)
#define	s_lab(x, y)	((x) -> lab = y)
#define	s_labeldecl(x, y)	((x) -> labeldecl = y)
#define	s_lhs(x, y)	((x) -> lhs = y)
#define	s_link(x, y)	((x) -> link = y)
#define	s_littype(x, y)	((x) -> littype = y)
#define	s_loopid(x, y)	((x) -> loopid = y)
#define	s_looplocals(x, y)	((x) -> looplocals = y)
#define	s_looppar(x, y)	((x) -> looppar = y)
#define	s_newtype(x, y)	((x) -> newtype = y)
#define	s_next(x, y)	((x) -> next = y)
#define	s_objtype(x, y)	((x) -> objtype = y)
#define	s_old_type(x, y)	((x) -> old_type = y)
#define	s_enlits(x, y)		((x) -> enlits = (y))
#define	s_pack_body(x, y)	((x) -> pack_body = y)
#define	s_packname(x, y)	((x) -> packname = y)
#define	s_parenttype(x, y)	((x) -> parenttype = y)
#define	s_parname(x, y)	((x) -> parname = y)
#define	s_partype(x, y)	((x) -> partype = y)
#define	s_qualexpr(x, y)	((x) -> qualexpr = y)
#define	s_qualtype(x, y)	((x) -> qualtype = y)
#define	s_rangetype(x, y)	((x) -> rangetype = y)
#define	s_renname(x, y)	((x) -> renname = y)
#define	s_rentype(x, y)	((x) -> rentype = y)
#define	s_rettype(x, y)	((x) -> rettype = y)
#define	s_rnam(x, y)	((x) -> rnam = y)
#define	s_slrange(x, y)	((x) -> slrange = y)
#define	s_specif(x, y)	((x) -> specif = y)
#define	s_stub(x, y)	((x) -> stub = y)
#define	s_stub_spec(x, y)	((x) -> stub_spec = y)
#define	s_subexpr(x, y)	((x) -> subexpr = y)
#define	s_subname(x, y)	((x) -> subname = y)
#define	s_subpr(x, y)	((x) -> subpr = y)
#define	s_t_stat(x, y)	((x) -> t_stat = y)
#define	s_task_exh(x, y)	((x) -> task_exh = y)
#define	s_task_stats(x, y)	((x) -> task_stats = y)
#define	s_taskbody(x, y)	((x) -> taskbody = y)
#define	s_thexpr(x, y)	((x) -> thexpr = y)
#define	s_thunk(x, y)	((x) -> thunk = y)
#define	s_types(x, y)	((x) -> types = y)
#define	s_type_spec(x, y)	((x) -> type_spec = (y))
#define	s_withunit(x, y)	((x) -> withunit = y)
#define	s_andthen(x, y)	((x) -> andthen = y)
#define	s_ind(x, y)	((x) -> ind = y)
#define	s_tag(x, y)	((x) -> tag = y)
#define	s_d(x, y)	((x) -> d = y)
#define	s_FB_lab(x, y)	((x) -> FB_lab = y)
#define	s_LPB_lab(x, y)	((x) -> LPB_lab = y)
#define	s_entrycount(x, y)	((x) -> entrycount = y)
#define	s_mark(x, y)	((x) -> mark = y)
#define	s_val(x, y)	((x) -> val = y)
#define	s_ACC_alloc(x, y)	((x) -> ACC_alloc = y)
#define	s_ACC_nform(x, y)	((x) -> ACC_nform = y)
#define	s_AGG_alloc(x, y)	((x) -> AGG_alloc = y)
#define	s_AGG_index(x, y)	((x) -> AGG_index = y)
#define	s_AGG_tablab(x, y)	((x) -> AGG_tablab = y)
#define	s_ARR_alloc(x, y)	((x) -> ARR_alloc = y)
#define	s_ARR_ndims(x, y)	((x) -> ARR_ndims = y)
#define	s_ARR_offset(x, y)	((x) -> ARR_offset = y)
#define	s_ARR_vdsize(x, y)	((x) -> ARR_vdsize = y)
#define	s_FLT_alloc(x, y)	((x) -> FLT_alloc = y)
#define	s_OBJ_alloc(x, y)	((x) -> OBJ_alloc = y)
#define	s_REC_alloc(x, y)	((x) -> REC_alloc = y)
#define	s_REC_nflds(x, y)	((x) -> REC_nflds = y)
#define	s_REC_form(x, y)	((x) -> REC_nform = y)
#define	s_REC_pathf(x, y)	((x) -> REC_pathf = y)
#define	s_REC_vdsize(x, y)	((x) -> REC_vdsize = y)
#define	s_ROBJ_alloc(x, y)	((x) -> ROBJ_alloc = y)
#define	s_SUBS_alloc(x, y)	((x) -> SUBS_alloc = y)
#define	s_SUB_level(x, y)	((x) -> SUB_level = y)
#define	s_TH_exprlab(x, y)	((x) -> TH_exprlab = y)
#define	s_TH_levlab(x, y)	((x) -> TH_levlab = y)
#define	s_VAR_ffld(x, y)	((x) -> VAR_ffld = y)
#define	s_attr_value(x, y)	((x) -> attr_value = y)
#define	s_e_num(x, y)	((x) -> e_num = y)
#define	s_enuml_ord(x, y)	((x) -> enuml_ord = y)
#define	s_nenums(x, y)	((x) -> nenums = y)
#define	s_CPA_exprlab(x, y)	((x) -> CPA_exprlab = y)
#define	s_AGG_flags(x, y)	((x) -> AGG_flags = y)
#define	s_ARR_flags(x, y)	((x) -> ARR_flags = y)
#define	s_FLT_flags(x, y)	((x) -> FLT_flags = y)
#define	s_REC_flags(x, y)	((x) -> REC_flags = y)
#define	s_lineno(x, y)	((x) -> lineno = y)
#define	s_flags(x, y)	((x) -> flags = y)
#define	s_prev(x, y)	((x) -> prev = y)
#define	s_rettype(x, y)	((x) -> rettype = y)
#define	DERIVEDTYPE	4


#define	has_expr(x)	((x) -> desc -> expr != NULL)
#define	kind_of(x)	((x) -> flags & 07)
#define	set_kind(x, y)	((x) -> flags |= y & 07)

#define	is_discr(x)	(((x) -> desc -> flags & 07) == KDISCR)
#define	is_number(x)	(((x) -> desc -> flags & 07) == KNUMB)

#define	is_qualif(x)	((x) -> flags & 010)
#define	set_qualif(x)	((x) -> flags |= 010)
#define	un_qualif(x)	((x) -> flags &= ~010)

#define	is_static(x)	(((x) -> flags & 060) == 040)
#define	set_static(x)	((x) -> flags |= 040)
#define	is_error(x)	(((x) -> flags & 060) == 060)
#define	set_error(x)	((x) -> flags |= 060)

#define	is_intro(x)	((x) -> flags & 0100)
#define	set_intro(x)	((x) -> flags |= 0100)
#define	out_intro(x)	((x) -> flags &= ~0100)

#define	is_std_fn(x)	((x) -> flags & 037)
#define	get_std_fun(x)	((x) -> flags & 037)
#define	set_std_fun(x, y)	((x) -> flags |= y & 037)

#define	is_visible(x)	(((x) -> flags & 0100) == 0)
#define	unvisible(x)	((x) -> flags |= 0100)

#define	set_private(x)	((x) -> flags |= 010)
#define	is_limpriv(x)	(((x) -> flags & 010) == 0)
#define	set_limpriv(x)	((x) -> flags |= 000)

#define	set_in(x)	((x) -> flags |= 010)
#define	set_notin(x)	((x) -> flags |= 000)
#define	is_in(x)	((x) -> flags & 010)

#define	set_nocheck(x)	((x) -> flags |= 0100)
#define	nocheck(x)	((x) -> flags & 0100)

#define	FORWARD		010
#define	BACKWARDS	000
#define	set_forward(x, y)	((x) -> flags |= y)
#define	is_forwards(x)	((x) -> flags & 010)

#define	is_unconrec(x)	((x) -> flags & UNCONS_RECORD)
#define	set_uncons(x)	((x) -> flags |= UNCONS_RECORD)

typedef union tree_element *ac;

typedef	struct literal *lit_ptr;

#define	DYNAMIC	1
struct	literal {
	byte	n;
	byte	litkind;
	char	litvalue [DYNAMIC];
};
/*
 *	on allocation of a literal value, the size
 *	of the litvalue is determined dynamically
 *	Note that this can be expressed is DAS
 *	by a suitable record definition and a
 *	access type (unconstrained) to objects of
 *	this type
 */
#define	EOS	'\0'

/* codes for DAS attributes;
 * must be in alphabetical order
 */

#define	A_ADDRESS	0
#define	A_BASE		1
#define	A_FIRST		2
#define	A_LAST		3
#define	A_LENGTH	4
#define	A_POS		5
#define	A_PRED		6
#define	A_RANGE		7
#define	A_SUCC		8
#define	A_VAL		9
#define	A_IMAGE		10
#define	A_SIZE		11

#define	I_NO_TYPE	0
#define	I_ANY_TYPE	1
#define	I_ANY_BOOL_VECTOR	2
#define	I_ANY_AGGREGATE	3
#define	I_ANY_ACCESS_TYPE 4
#define	I_ANY_SCALAR_VECTOR 5
#define	I_ENUM		6
#define	I_INTEGER	7
#define	I_STD_REAL	8
#define	I_ANY_STRING_TYPE 9
#define	I_LONG		10
#define	I_SHORT		11
#define	I_UNIV		12
#define	I_INTTYPES	13

#define	MAX_STR 80

/* 16 bits: 3 for kind, 1 for rec.init, 4 for alignmentfactor */

#define	VISITED		00400
#define	BUSY		01000

# define	SET(x,y)	((x) -> flags |= (y))
# define	UNSET(x,y)	((x) -> flags &= ~(y))
# define	TEST(x,y)	((x) -> flags & (y))

/*
 * the program tree
 * 
 * All structs just define offsets;
 * the struct names are only used to compute
 * the size of each variant
 */

union tree_element {

struct _acctype {
	discr d;	short flags;	short	lineno;
	ac	next;
	short	prev;
	char	*tag;
	ac	enclunit;
	ac	type_spec;
	ac	actype;
#ifndef FRONT
	short	ACC_alloc;
	MAXADDR	ACC_offset;
	short	ACC_nform;
#endif FRONT
} _acctype;

struct _aggregate {	/* kind of aggregate in flags */
	discr d;	short flags;	short	lineno;
	ac	aggtype,
	   fcompas;
#ifndef FRONT
	ac	context;
	short	AGG_flags;
	short	AGG_alloc;
	MAXADDR	AGG_Doff,
		AGG_Voff;
	short	AGG_tablab;
	MAXADDR	AGG_offset;
	short	AGG_index;
#endif FRONT
} _aggregate;

struct _all {
	discr d;	short flags;	short	lineno;
	ac	next;
	ac	types;
#ifndef FRONT
	MAXADDR	ALL_Doff,
		ALL_Voff;
#endif FRONT
} _all;

struct _allocator {	/* obtype is inclusive constraints */
	discr d;	short flags;	short	lineno;
	ac	altype,
	   obtype;
#ifndef FRONT
	MAXADDR ALLO_Doff,
		ALLO_Toff;
#endif FRONT
} _allocator;

struct _arraytype {
	discr d;	short flags;	short	lineno;
	ac	next;
	short	prev;
	char	*tag;
	ac	enclunit;
	ac	type_spec;
	ac	elemtype;
	ac	findex;
#ifndef FRONT
	short	ARR_alloc;
	short	ARR_flags;
	short	ARR_offset;
	short	ARR_vdsize;
	short	ARR_ndims;
#endif FRONT
} _arraytype;

struct _assign {
	discr d;	short flags;	short	lineno;
	ac	next;
	ac	lhs,
	   rhs;
} _assign;

struct _attribute {
	discr d;	short flags;	short	lineno;
	ac	next;
	ac	types;
	ac	entity;
	short	attr_value;
} _attribute;

struct	_entrycall {
	discr	d;	short	flags;	short	lineno;
	ac	next;
	ac	types;
	ac	fact;
	short	e_num;
	ac	e_entry;	/* entry to be called	*/
	ac	call_delay;	/* delay		*/
	ac	call_stats;	/* "else" or "delay" stats	*/
} _entrycall;

struct _block {
	discr d;	short flags;	short	lineno;
	ac	next;
	short	prev;
	char	*tag;
	ac	enclunit;
	ac	fblockloc;
	ac	BLK_stats;
	ac	BLK_exh;
#ifndef FRONT
	MAXADDR	BLK_SToff;
#endif FRONT
} _block;

struct _call {
	discr d;	short flags;	short	lineno;
	ac	next;
	ac	types;
	ac	fact;
#ifndef FRONT
	MAXADDR CALL_Doff;
	MAXADDR CALL_Voff;
#endif FRONT
} _call;

struct _callthunk {
	discr d;	short flags;	short	lineno;
	ac	thunk;
} _callthunk;

struct _case {
	discr d;	short flags;	short	lineno;
	ac	next;
	ac	caseexpr;
	ac	CASE_items;
#ifndef FRONT
	MAXADDR	CASE_Voff;
#endif
} _case;

struct _taskselect {
	discr d;	short flags;	short	lineno;
	ac	next;
	ac	SELECT_items;
} _taskselect;

struct _charlit {
	discr d;	short flags;	short	lineno;
	ac	next;
	short	prev;
	char	*tag;
	ac	enclunit;
	short	enuml_ord;
} _charlit ;

struct _compassoc {
	discr d;	short flags;	short	lineno;
	ac	next;
	ac	fcompchoice,
		compexpr;
#ifndef FRONT
	short 	CPA_exprlab;
#endif FRONT
} _compassoc;

struct _discr {
	discr d;	short flags;	short	lineno;
	ac	comp;
} _discr;

struct _discrcons {
	discr d;	short flags;	short	lineno;
	ac	aggregate;
} _discrcons;

struct _enumlit {
	discr d;	short flags;	short	lineno;
	ac	next;
	short	prev;
	char	*tag;
	ac	enclunit;
	short	enuml_ord;
} _enumlit;

struct _enumtype {
	discr d;	short flags;	short	lineno;
	ac	next;
	short	prev;
	char	*tag;
	ac	enclunit;
	ac	type_spec;
	ac	fenumlit;
	short	nenums;
} _enumtype;

struct _exception {
	discr d;	short flags;	short	lineno;
	ac	next;
	short	prev;
	char	*tag;
	ac	enclunit;
	ac	rnam;
} _exception;

struct _exhandler {
	discr d;	short flags;	short	lineno;
	ac	EXH_items;
} _exhandler;

struct _exit {
	discr d;	short flags;	short	lineno;
	ac	next;
	ac	loopid,
		exitcond;
} _exit;

struct _exp {
	discr d;	short flags;	short	lineno;
	ac	next;
	ac	exptype,
		primary;
} _exp;

struct _filter {
	discr d;	short flags;	short	lineno;
	ac	next;	/*dummy */
	short	prev;
	ac	filtype,
		constraint;
#ifndef FRONT
	short	FLT_alloc;
	short	FLT_flags;
	MAXADDR	FLT_offset,
		FLT_valsize,
		FLT_vdoffset;
#endif FRONT
} _filter;

struct _forblock {	/* direction of iteration in flags */
	discr d;	short flags;	short	lineno;
	ac	next;
	short	prev;
	char	*tag;
	ac	enclunit;
	ac	looppar;
	ac	FB_stats;
#ifndef FRONT
	int	FB_lab;
#endif
} _forblock;

struct _gennode {
	discr d;	short flags;	short	lineno;
	ac	next;
	short	prev;
	char	*tag;
	ac	enclunit;
	ac	genpars;
	ac	genunit;
} _gennode;

struct _genpartype {
	discr	d;	short	flags;	short	lineno;
	ac	next;
	short	prev;
	char	*tag;
	ac	enclunit;
};

struct _goto {
	discr d;	short flags;	short	lineno;
	ac	lab;
} _goto;

struct _if {
	discr d;	short flags;	short	lineno;
	ac	next;
	ac	IF_items;
} _if;

struct	_delay {
	discr	d;	short	flags;	short	lineno;
	ac	next;
	ac	delay_expr;
} _delay;

struct _terminate {
	discr	d;	short	flags;	short	lineno;
} _terminate;

struct _ifitem {
	discr d;	short flags;	short	lineno;
	ac	next;
	ac	ifcond;
	ac	IF_stats;
} _ifitem;

struct _in {		/* not in in flags	*/
	discr d;	short flags;	short	lineno;
	ac	inexpr,
		intype;
} _in;

struct _incomplete {
	discr d;	short flags;	short	lineno;
	ac	next;
	short	prev;
	char	*tag;
	ac	enclunit;
	ac	type_spec;
	ac	complete,
		fidiscr;
} _incomplete;

struct _index {
	discr d;	short flags;	short	lineno;
	ac	next;
	ac	indextype;
} _index;

struct _indexcons {
	discr d;	short flags;	short	lineno;
	ac	frange;
} _indexcons;

struct _indexing {
	discr d;	short flags;	short	lineno;
	ac	next;
	ac	types;
	ac	entity;
	ac	farg;
} _indexing;

struct _indirect {
	discr d;	short flags;	short	lineno;
	ac	indir;
} _indirect;

struct _internal {
	discr d;	short flags;	short	lineno;
	ac	next;
	short	prev;
	char	*tag;
	ac	xxx2;	/* dummy		*/
	ac	type_spec;
	byte	ind;
} _internal;

struct _labdef {
	discr d;	short flags;	short	lineno;
	ac	labeldecl;
} _labdef;

struct _literal {
	discr d;	short flags;	short	lineno;
	ac	littype;
	lit_ptr val;
#ifndef FRONT
	MAXADDR	LIT_Voff;
	MAXADDR	LIT_Doff;
#endif FRONT
} _literal;

struct _loopblock {
	discr d;	short flags;	short	lineno;
	ac	next;
	short	prev;
	char	*tag;
	ac	enclunit;
	ac	looplocals;
	ac	cond;
	ac	LPB_stats;
#ifndef FRONT
	int	LPB_lab;
#endif
} _loopblock;

struct _mark {
	discr d;	short flags;	short	lineno;

} _mark;

struct _newtype {
	discr d;	short flags;	short	lineno;
	ac	next;
	short	prev;
	char	*tag;
	ac	enclunit;
	ac	type_spec;
	ac	old_type;
	int	mark;
	ac	enlits;
} _newtype;

struct _inherit {
	discr d;	short flags;	short	lineno;
	ac	next;
	short	prev;
	char	*tag;
	ac	enclunit;
	ac	xxyy;		/* plain dummy	*/
	ac	old_type;
	ac	inh_type;
	ac	inh_oper;
	short	is_hidden;
} _inherit;

struct _name {
	discr d;	short flags;	short	lineno;
	ac	next;
	ac	types;
	ac	fentity,
	   foperation;
} _name;

struct _namedass {
	discr d;	short flags;	short	lineno;
	ac	next;
	ac	parname,
	   nexp;
} _namedass;

struct _objdesc {	/* object kind in flags	*/
	discr d;	short flags;	short	lineno;
	ac	next;
	short	prev;
	ac	objtype,
	   expr;
} _objdesc;

struct _object {
	discr d;	short flags;	short	lineno;
	ac	next;
	short	prev;
	char	*tag;
	ac	enclunit;
	ac	desc;
#ifndef FRONT
	short	OBJ_alloc;
	MAXADDR	OBJ_offset;
	MAXADDR OBJ_descoff;
#endif FRONT
} _object;

struct _package {
	discr d;	short flags;	short	lineno;
	ac	next;
	short	prev;
	char	*tag;
	ac	enclunit;
	ac	fvisitem,priv;
	ac	pack_body;
} _package;

struct _tasktype {
	discr d;	short flags;	short	lineno;
	ac	next;
	short	prev;
	char	*tag;
	ac	enclunit;
	ac	type_spec;
	ac	fentry;
	ac	taskbody;
} _tasktype;

struct _packbody {
	discr d;	short flags;	short	lineno;
	ac	next;
	short	prev;
	char	*tag;
	ac	enclunit;
	ac	specif,
	   fbodyloc;
	ac	PB_stats;
	ac	PB_exh;
#ifndef FRONT
	MAXADDR	PBDY_SToff;
#endif FRONT
} _packbody;

struct _parenths {
	discr d;	short flags;	short	lineno;
	ac	subexpr;
} _parenth;

struct _privpart {
	discr d;	short flags;	short	lineno;
	ac	next;
	short	prev;
	char	*tag;
	ac	enclunit;	/* i.e. the package specification */
	ac	fprivitem;
} _privpart;

struct _privtype {	/* limited flag in flags	*/
	discr d;	short flags;	short	lineno;
	ac	next;
	short	prev;
	char	*tag;
	ac	enclunit;
	ac	type_spec;
	ac	fpdiscr,
	   impl;
} _privtype;

struct _raise {
	discr d;	short flags;	short	lineno;
	ac	next;
	ac	exception;	/* indirect */
} _raise;

struct _range {
	discr d;	short flags;	short	lineno;
	ac	next;
	ac	rangetype,
	   frangeexp;
} _range;

struct _rectype {
	discr d;	short flags;	short	lineno;
	ac	next;
	short prev;
	char	*tag;
	ac	enclunit;
	ac	type_spec;
	ac	ffield,
	   fvariant,
	   dis;
#ifndef FRONT
	short	REC_alloc;
	short	REC_flags;
	MAXADDR	REC_offset;
	short	REC_nform;
	short	REC_vdsize;
	short	REC_nflds,
		REC_ninits,
		REC_npaths,
		REC_maxpfld,
		REC_vsize;
	short	REC_pathf;
#endif FRONT
} _rectype;

struct _renobj {
	discr d;	short flags;	short	lineno;
	ac	next;
	short	prev;
	char	*tag;
	ac	enclunit;
	ac	rentype,
	   name;
#ifndef FRONT
	short	ROBJ_alloc;
	MAXADDR	ROBJ_offset;
#endif FRONT
} _renobj;

struct _renpack {
	discr d;	short flags;	short	lineno;
	ac	next;
	short	prev;
	char	*tag;
	ac	enclunit;
	ac	renname;
} _renpack;

struct _rensub {
	discr d;	short flags;	short	lineno;
	ac	next;
	short	prev;
	char	*tag;
	ac	enclunit;
	ac	fformal, rettype;
	ac	subname;
} _rensub;

struct _return {
	discr d;	short flags;	short	lineno;
	ac	next;
	ac	enclsub,
	   retexpr;
} _return;

struct _scc {
	discr d;	short flags;	short	lineno;
	bool andthen;
	ac	fsccexpr;
#ifndef FRONT
	MAXADDR SCC_Voff;
#endif
} _scc;

struct _select {
	discr d;	short flags;	short	lineno;
	ac	next;
	ac	types;
	ac	entity;
} _select;

struct _set {
	discr d;	short flags;	short	lineno;
	ac	fsetelem,
		iter_ptr;
} _set;

struct	_separate {
	discr d;	short	flags;	short	lineno;
	ac	next;
	short	prev;
	char	*tag;		
	ac	stub;
} _separate;

struct _setelem {	/* code in flags */
	discr d;	short flags;	short	lineno;
	ac	next;
	ac	elem;
} _setelem;

struct _slice {
	discr d;	short flags;	short	lineno;
	ac	next;
	ac	types;
	ac	slrange;
#ifndef FRONT
	MAXADDR SLI_Doff;
#endif FRONT
} _slice;

struct	_stub {
	discr	d; short	flags;	short	lineno;
	ac	next;
	short	prev;
	char	*tag;		
	ac	enclunit;
	ac	stub_spec;
} _stub;

#ifndef FRONT
struct _stringlit {
	/* see dutinfa!docs/stringlit */
	discr d;	short flags;	short	lineno;
	ac	littype;
	lit_ptr	val;
	MAXADDR LIT_Voff;
	MAXADDR LIT_Doff;
} _stringlit;
#endif FRONT

struct _sub {
	discr d;	short flags;	short	lineno;
	ac	next;
	short	prev;
	char	*tag;
	ac	enclunit;
	ac	fformal;
	ac	rettype;
	ac	body_imp;
#ifndef FRONT
	MAXADDR	SUBS_retoff;
	short	SUBS_alloc;
	MAXADDR	SUBS_offset;
#endif FRONT
} _sub;

struct _entry {
	discr d;	short flags;	short	lineno;
	ac	next;
	short	prev;
	char	*tag;
	ac	enclunit;
	ac	fformal;
	ac	rettype;
	int	entrycount;
} _entry;

struct _subbody {
	discr d;	short flags;	short	lineno;
	ac	next;
	short	prev;
	char	*tag;
	ac	enclunit;
	ac	specif,
	   fbodyloc;
	ac	SBB_stats;
	ac	SBB_exh;
#ifndef FRONT
	short	SUB_level;
	MAXADDR	SBB_valoff;	/* return value		*/
#endif FRONT
} _subbody;

struct _taskbody {
	discr d;	short flags;	short	lineno;
	ac	next;
	short	prev;
	char	*tag;
	ac	enclunit;
	ac	specif,
	   fbodyloc;
	ac	task_stats;
	ac	task_exh;
} _taskbody;

struct _accept {
	discr d;	short flags;	short	lineno;
	ac	next;
	short	prev;
	char	*tag;	/* a dummy, really	*/
	ac	enclunit;
	ac	specif;
	ac	accept_stats;
} _accept;

struct _subcall {
	discr d;	short flags;	short	lineno;
	ac	next;
	ac	subpr;
} _subcall;

struct _subtype {
	discr d;	short flags;	short	lineno;
	ac	next;
	short	prev;
	char	*tag;
	ac	enclunit;
	ac	type_spec;
	ac	parenttype;
} _subtype;

struct _tagstat {
	discr d;	short flags;	short	lineno;
	ac	next;
	short	prev;
	char	*tag;
	ac	t_stat;
} _tagstat;

struct _thunk {
	discr d;	short flags;	short	lineno;
	ac	next;
	short	prev;
	ac	thexpr;
#ifndef FRONT
	short	TH_exprlab;
	short	TH_levlab;
#endif FRONT
} _thunk;

struct _typeconv {
	discr d;	short flags;	short	lineno;
	ac	newtype,
	   convexpr;
#ifndef FRONT
	MAXADDR	TCON_Doff;
#endif FRONT
} _typeconv;

struct _use {
	discr d;	short flags;	short	lineno;
	ac	next;
	ac	packname;
} _use;

struct	_unresrec {
	discr d;	short flags;	short	lineno;
	ac	next;
	char	*ident;
} _unresrec;

struct	_unreschar {
	discr	d;	short	flags;	short	lineno;
	ac	next;	/* unused			*/
	char	*ident;
} _unreschar;

struct _variant {
	discr d;	short flags;	short	lineno;
	ac	next;
	short	prev;
	char	*tag;	/* dummy	*/
	ac	enclunit;
	ac	xxxx;	/* dummy	*/
	ac	ffield,
	   fvariant,
	   dis,
	   varchoice;
#ifndef FRONT
	short	VAR_ffld,
		VAR_fpath,
		VAR_fpfld;
#endif FRONT
} _variant;

struct _whenitem {
	discr d;	short flags;	short	lineno;
	ac	next;
	ac	fwhenchoice;
	ac	WI_stats;
} _whenitem;

struct _with {
	discr d;	short flags;	short	lineno;
	ac	next;
	short	prev;
	char	*tag;
	ac	withunit;
} _with;

struct _qualif {
	discr d;	short flags;	short	lineno;
	ac	qualtype;
	ac	qualexpr;
} _qualif;

struct _triple {
	discr d;	short flags; short	lineno;
	ac	next;
	ac	tripsub;
	ac	triptype;
	ac	tripdtype;
	ac	tripnext;
	ac	tripmark;
} _triple;

};
/* end of union sluithaak */

typedef	struct _triple	TRIP;

#define	STD_LUN		2
#define	SPEC		01
#define	XBODY		02
#define	GEN		04
/*
 *	definition of "operator symbols"
 */

#define		O_EQ		1
#define		O_LESS		2
#define		O_GR		3
#define		O_LE		4
#define		O_GE		5

#define		O_PLUS		6
#define		O_MIN		7
#define		O_MUL		8
#define		O_DIV		9
#define		O_MOD		10

#define		O_REM		11
#define		O_CAT		12
#define		O_NOT		13
#define		O_POW		14
#define		O_AND		15

#define		O_OR		16
#define		O_XOR		17
#define		O_ABS		18
#define		O_FREE		19

#ifdef DEBUG
#define	ASSERT(x, y)	if (!(x)) sys_error y
#else
#define	ASSERT(x, y)
#endif

#ifdef DEBUG
#define	DEFAULT(x)	default: sys_error x
#else
#define	DEFAULT(x)
#endif

#define	FORALL(x, y)	for (x = (y); x != NULL; x = g_next (x))
#define	FORSET(x, y)	for (x = first (y); x != NULL; x = next_elem (y))
