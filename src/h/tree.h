/*
 *	tree.h
 *	specification of the DAS tree, it's flags and it's
 *	access functions
 *
 *	Verify the correctness by running "make"
 */

/*
 *	General type defs
 *	BPB indicated Bits per Byte
 */
#define	BPB	8
#define	BMASK	01
#define	CMASK	0377

#define	FNL	50
#define	IDL	50

typedef	char	*t_tag;
typedef	char	*string;
typedef	string	filename;
typedef	char	byte;
typedef	short	t_index;
typedef	byte	char_value;
typedef	short	bool;

#define	FALSE	0
#define	TRUE	1
#define	NULL	0
typedef	byte	discr;
typedef	union tree_element *ac;
typedef struct _triple TRIP;
typedef	struct literal *lit_ptr;

#include	"../h/rt_defs.h"
#include	"../h/nodes.h"

/*
 *	General predicate routines,
 *	should be generated by a tool
 */
#define	is_enclosed(x)	(XSUB <= g_d (x) && g_d (x) <= XPRIVPART)
#define	has_tag(x)	(XSUB <= g_d (x) && g_d (x) <= XSEPARATE)
#define	has_link(x)	(XSUB <= g_d (x) && g_d (x) <= XFILTER)

#define	has_expr(x)	(g_expr (g_desc (x)) != (ac) NULL)

#define	kind_of(x)	(g_flags (x) & 07)
#define	set_kind(x, y)	(s_flags (x, g_flags (x) | (y & 07)))

#define	is_discr(x)	((g_flags (g_desc (x)) & 07) == KDISCR)
#define is_recfield(x)	((g_flags (g_desc (x)) & 07) == KCOMP)
#define	is_number(x)	((g_flags (g_desc (x)) & 07) == KNUMB)

#define	is_qualif(x)	(g_flags (x) & 010)
#define	set_qualif(x)	(s_flags (x, g_flags (x) | 010))
#define	un_qualif(x)	(s_flags (x, g_flags (x) & ~010))

#define	is_static(x)	((g_flags (x) & 060) == 040)
#define	set_static(x)	(s_flags (x, g_flags (x) | 040))

#define	is_error(x)	((g_flags (x) & 060) == 060)
#define	set_error(x)	(s_flags (x, g_flags (x) | 060))

#define	is_std_fn(x)	(g_flags (x) & 037)
#define	get_std_fun(x)	(g_flags (x) & 037)
#define	set_std_fun(x, y)	(s_flags (x, g_flags (x) | (y & 037)))


#define	is_intro(x)	(g_flags (x) & 0100)
#define	set_intro(x)	(s_flags (x, g_flags (x) | 0100))
#define	out_intro(x)	(s_flags (x, g_flags (x) & ~0100))
#define	is_visible(x)	((g_flags (x) & 0100) == 0)
#define	unvisible(x)	(s_flags (x, g_flags (x) | 0100))
#define	is_generic(x)	((g_flags (x) & 0200) == 0200)
#define	set_generic(x)	(s_flags (x, g_flags (x) | 0200))
#define	is_instantiated(x)	((g_flags (x) & 011000) == 011000)
#define set_instantiated(x) (s_flags (x, g_flags (x) | 011000))
#define	is_genpar(x)	((g_flags (x) & 0500) == 0500)
#define	set_genpar(x)	(s_flags (x, g_flags (x) | 0500))
#define	has_sdefault(x)	((g_flags (x) & 01200) == 01200)
#define set_sdefault(x)	(s_flags (x, g_flags (x) | 01200))

#define	set_in(x)	(s_flags (x, g_flags (x) | 010))
#define	set_notin(x)	(s_flags (x, g_flags (x) & ~010))
#define	is_in(x)	(g_flags (x) & 010)

#define	set_nocheck(x)	(s_flags (x, g_flags (x) | 0100))
#define	nocheck(x)	(g_flags (x) & 0100)

#define	FORWARD		010
#define	BACKWARDS	000
#define	set_forward(x, y)	(s_flags (x, g_flags (x) | y))
#define	is_forwards(x)	(g_flags (x) & 010)

#define	is_unconrec(x)	((x) -> flags & UNCONS_RECORD)
#define	set_uncons(x)	((x) -> flags |= UNCONS_RECORD)

#define	LIMIT		0x7000
#define	HAS_ASSIGN	02
/*
 *	Legitimate flag values
 */
#define	KMASK	017
#define	KVAR	0
#define	KCONST	1
#define	KNUMB	2
#define	KCOMP	3
#define	KDISCR	4
#define	INMODE	5
#define	OUTMODE	6
#define	INOUTMODE	7

#define	MARKED	01000
#define	BUWALK	01000

#define	C_type	010000
#define	set_as_C(x)	(s_flags (x, g_flags (x) | C_type))
#define	is_as_C(x)	(g_flags (x) & C_type)
/*
 *	Kinds of literals to be distinguished
 */
#define	S_INTLIT	1
#define	S_REALLIT	2
#define	S_STRINGLIT	3
#define	S_CHARLIT	4
#define	S_NULLLIT	5

/*
 *	Kinds of subprograms to be considered
 */
#define	NORMAL 0
#define	STD_OP	1

/*
 *	Kind of derived types to be considered
 */
#define	NEWINTTYPE	1
#define	NEWFLOATTYPE	2
#define	NEWFIXEDTYPE	3
#define	DERIVEDTYPE	4
#define	GENPRIVTYPE	5
#define	SCALARTYPE	6
/*
 *	ACCESS FUNCTIONS FOR NODE ATTRIBUTES
 */
#include	"access.h"


#define	DYNAMIC	1
struct	literal {
	byte	n;
	byte	litkind;
	char	litvalue [DYNAMIC];
};
/*
 *	on allocation of a literal value, the size
 *	of the litvalue is determined dynamically
 *	Note that this can be expressed is DAS
 *	by a suitable record definition and a
 *	access type (unconstrained) to objects of
 *	this type
 */
#define	EOS	'\0'

/* codes for DAS attributes;
 * must be in alphabetical order
 */

#define	A_ADDRESS	0
#define	A_BASE		1
#define	A_FIRST		2
#define	A_LAST		3
#define	A_LENGTH	4
#define	A_POS		5
#define	A_PRED		6
#define	A_RANGE		7
#define	A_SUCC		8
#define	A_VAL		9
#define	A_IMAGE		10
#define	A_SIZE		11
#define	A_WIDTH		12
#define	A_CALLABLE	13
#define	A_COUNT		14
#define	A_STORAGE_SIZE	15
#define	A_TERMINATED	16
#define	A_VALUE		17

#define	I_NO_TYPE	0
#define	I_ANY_TYPE	1
#define	I_ANY_BOOL_VECTOR	2
#define	I_ANY_AGGREGATE	3
#define	I_ANY_ACCESS_TYPE 4
#define	I_ANY_SCALAR_VECTOR 5
#define	I_ENUM		6
#define	I_INTEGER	7
#define	I_STD_REAL	8
#define	I_ANY_STRING_TYPE 9
#define	I_LONG		10
#define	I_SHORT		11
#define	I_UNIV		12
#define	I_INTTYPES	13

#define	MAX_STR 80

/*
 *	include the program tree
 */
#include	"../h/nodedefs.h"

#define	STD_LUN		2
#define	SPEC		01
#define	XBODY		02
#define	GEN		04
/*
 *	Default datasize for task objects
 */
#define	DEFSTACKSIZE	4096
/*
 *	definition of "operator symbols"
 */

#define		O_EQ		1
#define		O_LESS		2
#define		O_GR		3
#define		O_LE		4
#define		O_GE		5

#define		O_PLUS		6
#define		O_MIN		7
#define		O_MUL		8
#define		O_DIV		9
#define		O_MOD		10

#define		O_REM		11
#define		O_CAT		12
#define		O_NOT		13
#define		O_POW		14
#define		O_AND		15

#define		O_OR		16
#define		O_XOR		17
#define		O_ABS		18
#define		O_FREE		19

#ifdef DEBUG
#define	ASSERT(x, y)	if (!(x)) sys_error y
#else
#define	ASSERT(x, y)
#endif

#ifdef DEBUG
#define	DEFAULT(x)	default: sys_error x
#else
#define	DEFAULT(x)
#endif

#define	FORALL(x, y)	for (x = (y); x != NULL; x = g_next (x))
#define	FORSET(x, y)	for (x = first (y); x != NULL; x = next_elem (y))
